diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..04b6992
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,266 @@
+#	NetHack Makefile.
+#	SCCS Id: @(#)Makefile.top	3.4	1995/01/05
+
+# newer makes predefine $(MAKE) to 'make' and do smarter processing of
+# recursive make calls if $(MAKE) is used
+# these makes allow $(MAKE) to be overridden by the environment if someone
+# wants to (or has to) use something other than the standard make, so we do
+# not want to unconditionally set $(MAKE) here
+#
+# unfortunately, some older makes do not predefine $(MAKE); if you have one of
+# these, uncomment the following line
+# (you will know that you have one if you get complaints about unable to
+# execute things like 'data' and 'rumors')
+# MAKE = make
+
+# make NetHack
+PREFIX	 = /usr
+GAME     = nethack
+# GAME     = nethack.prg
+GAMEUID  = root
+GAMEGRP  = root
+
+# Permissions - some places use setgid instead of setuid, for instance
+# See also the option "SECURE" in include/config.h
+GAMEPERM = 04755
+FILEPERM = 0644
+EXEPERM  = 0755
+DIRPERM  = 0755
+
+# GAMEDIR also appears in config.h as "HACKDIR".
+# VARDIR may also appear in unixconf.h as "VAR_PLAYGROUND" else GAMEDIR
+#
+# note that 'make install' believes in creating a nice tidy GAMEDIR for
+# installation, free of debris from previous NetHack versions --
+# therefore there should not be anything in GAMEDIR that you want to keep
+# (if there is, you'll have to do the installation by hand or modify the
+# instructions)
+GAMEDIR  = $(PREFIX)/share/$(GAME)
+VARDIR  = $(GAMEDIR)
+SHELLDIR = $(PREFIX)/bin
+
+# per discussion in Install.X11 and Install.Qt
+VARDATND = 
+# VARDATND = x11tiles NetHack.ad pet_mark.xbm
+# VARDATND = x11tiles NetHack.ad pet_mark.xbm rip.xpm
+# for Atari/Gem
+# VARDATND = nh16.img title.img GEM_RSC.RSC rip.img
+# for BeOS
+# VARDATND = beostiles
+# for Gnome
+# VARDATND = x11tiles pet_mark.xbm rip.xpm mapbg.xpm
+
+VARDATD = data oracles options quest.dat rumors
+VARDAT = $(VARDATD) $(VARDATND)
+
+# Some versions of make use the SHELL environment variable as the shell
+# for running commands.  We need this to be a Bourne shell.
+# SHELL = /bin/sh
+# for Atari
+# SHELL=E:/GEMINI2/MUPFEL.TTP
+
+# Commands for setting the owner and group on files during installation.
+# Some systems fail with one or the other when installing over NFS or for
+# other permission-related reasons.  If that happens, you may want to set the
+# command to "true", which is a no-op. Note that disabling chown or chgrp
+# will only work if setuid (or setgid) behavior is not desired or required.
+CHOWN = chown
+CHGRP = chgrp
+
+#
+# end of configuration
+#
+
+DATHELP = help hh cmdhelp history opthelp wizhelp
+
+SPEC_LEVS = asmodeus.lev baalz.lev bigrm-?.lev castle.lev fakewiz?.lev \
+	juiblex.lev knox.lev medusa-?.lev minend-?.lev minefill.lev \
+	minetn-?.lev oracle.lev orcus.lev sanctum.lev soko?-?.lev \
+	tower?.lev valley.lev wizard?.lev \
+	astral.lev air.lev earth.lev fire.lev water.lev
+QUEST_LEVS = ???-goal.lev ???-fil?.lev ???-loca.lev ???-strt.lev
+
+DATNODLB = $(VARDATND) license
+DATDLB = $(DATHELP) dungeon $(SPEC_LEVS) $(QUEST_LEVS) $(VARDATD)
+DAT = $(DATNODLB) $(DATDLB)
+
+$(GAME):
+	( cd src ; $(MAKE) )
+
+all:	$(GAME) recover Guidebook $(VARDAT) dungeon spec_levs check-dlb
+	@echo "Done."
+
+# Note: many of the dependencies below are here to allow parallel make
+# to generate valid output
+
+Guidebook:
+	( cd doc ; $(MAKE) Guidebook )
+
+manpages:
+	( cd doc ; $(MAKE) manpages )
+
+data: $(GAME)
+	( cd dat ; $(MAKE) data )
+
+rumors: $(GAME)
+	( cd dat ; $(MAKE) rumors )
+
+oracles: $(GAME)
+	( cd dat ; $(MAKE) oracles )
+
+#	Note: options should have already been made with make, but...
+options: $(GAME)
+	( cd dat ; $(MAKE) options )
+
+quest.dat: $(GAME)
+	( cd dat ; $(MAKE) quest.dat )
+
+spec_levs: dungeon
+	( cd util ; $(MAKE) lev_comp )
+	( cd dat ; $(MAKE) spec_levs )
+	( cd dat ; $(MAKE) quest_levs )
+
+dungeon: $(GAME)
+	( cd util ; $(MAKE) dgn_comp )
+	( cd dat ; $(MAKE) dungeon )
+
+nhtiles.bmp: $(GAME)
+	( cd dat ; $(MAKE) nhtiles.bmp )
+
+x11tiles: $(GAME)
+	( cd util ; $(MAKE) tile2x11 )
+	( cd dat ; $(MAKE) x11tiles )
+
+beostiles: $(GAME)
+	( cd util ; $(MAKE) tile2beos )
+	( cd dat ; $(MAKE) beostiles )
+
+NetHack.ad: $(GAME)
+	( cd dat ; $(MAKE) NetHack.ad )
+
+pet_mark.xbm:
+	( cd dat ; $(MAKE) pet_mark.xbm )
+
+rip.xpm:
+	( cd dat ; $(MAKE) rip.xpm )
+
+mapbg.xpm:
+	(cd dat ; $(MAKE) mapbg.xpm )
+
+nhsplash.xpm:
+	( cd dat ; $(MAKE) nhsplash.xpm )
+
+nh16.img: $(GAME)
+	( cd util ; $(MAKE) tile2img.ttp )
+	( cd dat ; $(MAKE) nh16.img )
+
+rip.img:
+	( cd util ; $(MAKE) xpm2img.ttp )
+	( cd dat ; $(MAKE) rip.img )
+GEM_RSC.RSC:
+	( cd dat ; $(MAKE) GEM_RSC.RSC )
+
+title.img:
+	( cd dat ; $(MAKE) title.img )
+
+check-dlb: options
+	@if egrep -s librarian dat/options ; then $(MAKE) dlb ; else true ; fi
+
+dlb:
+	( cd util ; $(MAKE) dlb )
+	( cd dat ; ../util/dlb cf nhdat $(DATDLB) )
+
+# recover can be used when INSURANCE is defined in include/config.h
+# and the checkpoint option is true
+recover: $(GAME)
+	( cd util ; $(MAKE) recover )
+
+dofiles:
+	target=`sed -n					\
+		-e '/librarian/{' 			\
+		-e	's/.*/dlb/p' 			\
+		-e	'q' 				\
+		-e '}' 					\
+	  	-e '$$s/.*/nodlb/p' < dat/options` ;	\
+	$(MAKE) dofiles-$${target-nodlb}
+	cp src/$(GAME) $(GAMEDIR)
+	cp util/recover $(GAMEDIR)
+	-rm -f $(SHELLDIR)/$(GAME)
+	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
+		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
+		< sys/unix/nethack.sh \
+		> $(SHELLDIR)/$(GAME)
+# set up their permissions
+	-( cd $(GAMEDIR) ; $(CHOWN) $(GAMEUID) $(GAME) recover ; \
+			$(CHGRP) $(GAMEGRP) $(GAME) recover )
+	chmod $(GAMEPERM) $(GAMEDIR)/$(GAME)
+	chmod $(EXEPERM) $(GAMEDIR)/recover
+	-$(CHOWN) $(GAMEUID) $(SHELLDIR)/$(GAME)
+	$(CHGRP) $(GAMEGRP) $(SHELLDIR)/$(GAME)
+	chmod $(EXEPERM) $(SHELLDIR)/$(GAME)
+
+dofiles-dlb: check-dlb
+	( cd dat ; cp nhdat $(DATNODLB) $(GAMEDIR) )
+# set up their permissions
+	-( cd $(GAMEDIR) ; $(CHOWN) $(GAMEUID) nhdat $(DATNODLB) ; \
+			$(CHGRP) $(GAMEGRP) nhdat $(DATNODLB) ; \
+			chmod $(FILEPERM) nhdat $(DATNODLB) )
+
+dofiles-nodlb:
+# copy over the game files
+	( cd dat ; cp $(DAT) $(GAMEDIR) )
+# set up their permissions
+	-( cd $(GAMEDIR) ; $(CHOWN) $(GAMEUID) $(DAT) ; \
+			$(CHGRP) $(GAMEGRP) $(DAT) ; \
+			chmod $(FILEPERM) $(DAT) )
+
+update: $(GAME) recover $(VARDAT) dungeon spec_levs
+#	(don't yank the old version out from under people who're playing it)
+	-mv $(GAMEDIR)/$(GAME) $(GAMEDIR)/$(GAME).old
+#	quest.dat is also kept open and has the same problems over NFS
+#	(quest.dat may be inside nhdat if dlb is in use)
+	-mv $(GAMEDIR)/quest.dat $(GAMEDIR)/quest.dat.old
+	-mv $(GAMEDIR)/nhdat $(GAMEDIR)/nhdat.old
+# set up new versions of the game files
+	( $(MAKE) dofiles )
+# touch time-sensitive files
+	-touch -c $(VARDIR)/bones* $(VARDIR)/?lock* $(VARDIR)/wizard*
+	-touch -c $(VARDIR)/save/*
+	touch $(VARDIR)/perm $(VARDIR)/record
+# and a reminder
+	@echo You may also want to install the man pages via the doc Makefile.
+
+install: $(GAME) recover $(VARDAT) dungeon spec_levs
+# set up the directories
+# not all mkdirs have -p; those that don't will create a -p directory
+	-mkdir -p $(SHELLDIR)
+#	-rm -rf $(GAMEDIR) $(VARDIR)
+	-mkdir -p $(GAMEDIR) $(VARDIR) $(VARDIR)/save $(VARDIR)/bones
+	-rmdir ./-p
+	-$(CHOWN) $(GAMEUID) $(GAMEDIR) $(VARDIR) $(VARDIR)/save $(VARDIR)/bones
+	$(CHGRP) $(GAMEGRP) $(GAMEDIR) $(VARDIR) $(VARDIR)/save $(VARDIR)/bones
+	chmod $(DIRPERM) $(GAMEDIR) $(VARDIR) $(VARDIR)/save $(VARDIR)/bones
+# set up the game files
+	( $(MAKE) dofiles )
+# set up some additional files
+	touch $(VARDIR)/perm $(VARDIR)/record $(VARDIR)/logfile
+	-( cd $(VARDIR) ; $(CHOWN) $(GAMEUID) perm record logfile ; \
+			$(CHGRP) $(GAMEGRP) perm record logfile ; \
+			chmod $(FILEPERM) perm record logfile )
+# and a reminder
+	@echo You may also want to reinstall the man pages via the doc Makefile.
+
+
+# 'make clean' removes all the .o files, but leaves around all the executables
+# and compiled data files
+clean:
+	( cd src ; $(MAKE) clean )
+	( cd util ; $(MAKE) clean )
+
+# 'make spotless' returns the source tree to near-distribution condition.
+# it removes .o files, executables, and compiled data files
+spotless:
+	( cd src ; $(MAKE) spotless )
+	( cd util ; $(MAKE) spotless )
+	( cd dat ; $(MAKE) spotless )
+	( cd doc ; $(MAKE) spotless )
diff --git a/README.menucolor b/README.menucolor
new file mode 100644
index 0000000..071653a
--- /dev/null
+++ b/README.menucolor
@@ -0,0 +1,96 @@
+
+   This is version 1.3 of the menucolors patch.
+
+   This patch allows the user to define in what color menus are shown.
+   For example, putting
+
+   OPTIONS=menucolors
+   MENUCOLOR=" blessed "=green
+   MENUCOLOR=" holy "=green
+   MENUCOLOR=" cursed "=red
+   MENUCOLOR=" unholy "=red
+   MENUCOLOR=" cursed .* (being worn)"=orange&underline
+
+   in the configuration file makes all known blessed items
+   show up in green, all cursed items show up in red and
+   all cursed worn items show up in orange and underlined
+   when viewing inventory.
+
+   If you do not have GNU regex.h, comment
+   #define MENU_COLOR_REGEX out from include/config.h
+   and replace the MENUCOLOR lines in your config file with these:
+
+   MENUCOLOR="* blessed *"=green
+   MENUCOLOR="* holy *"=green
+   MENUCOLOR="* cursed *"=red
+   MENUCOLOR="* unholy *"=red
+   MENUCOLOR="* cursed * (being worn)"=orange&underline
+
+
+   Colors: black, red, green, brown, blue, magenta, cyan, gray, orange,
+           lightgreen, yellow, lightblue, lightmagenta, lightcyan, white.
+   Attributes: none, bold, dim, underline, blink, inverse.
+
+   Note that the terminal is free to interpret the attributes however
+   it wants.
+
+
+   TODO/BUGS:
+
+    o Only works with TTY
+    o You can't use '=' or '&' in the match-string.
+    o Maybe add color-field to tty_menu_item in include/wintty.h
+      (so there's no need to find the color for the line again)
+    o Guidebook is not up to date
+    o Better place to put the functions, colornames[] and attrnames[]?
+    o Some menus do not need coloring; maybe add new parameter
+      to process_menu_window()?
+
+
+   FIXES:
+
+   v1.3:
+    o Updated to use 3.4.3 codebase.
+    o Added a text to #version to show menucolors is compiled in.
+
+   v1.2:
+    o Updated to use 3.4.2 codebase.
+
+   v1.1:
+    o Updated to use 3.4.1 codebase.
+    o replaced USE_REGEX_MATCH with MENU_COLOR_REGEX
+
+   v1.04:
+    o Oops! 1.03 worked only on *nixes... (GNU regex.h)
+    o Compile-time option USE_REGEX_MATCH: if it's defined, use regex,
+      otherwise use globbing. ('?' and '*' wildcards)
+
+   v1.03:
+
+    o Now using Nethack 3.4.0 codebase
+    o Compile-time option MENU_COLOR
+    o Strings match using regular expressions instead of globbing
+    o You can use attribute with color (attr must come after '&')
+    o Use ``MENUCOLOR="foo"=color'' instead of ``OPTIONS=menucolor=...''
+      (Both work, but OPTIONS complains if you define menucolor
+      more than once)
+
+   v1.02:
+
+    o Should now work with OS/2, thanks to Jukka Lahtinen
+    o Strings match now using simple globbing. ('?' and '*' wildcards)
+
+   v1.01:
+
+    o Moved 'menucolors' boolean option, so now the options-menu
+      is in alphabetical order.
+    o Fixed 'menucolor' description in dat/opthelp.
+    o menu_colorings is now initialized to null in src/decl.c.
+
+   v1.0:
+
+    o Initial release
+
+--
+ Pasi Kallinen
+ pkalli@cs.joensuu.fi
diff --git a/README.nh343jl b/README.nh343jl
new file mode 100644
index 0000000..a7357ea
--- /dev/null
+++ b/README.nh343jl
@@ -0,0 +1,121 @@
+nh343jl.diff is a diff for Nethack 3.4.3, containing the following
+patches (better explanations and diffs for most individual patches
+available at http://www.netsonic.fi/~walker/nethack.html) :
+
+- Tom Friedetzky's "dump character" patch somewhat modified by me, Darshan
+  Shaligram and some others (include/decl.h, include/extern.h,
+        src/botl.c, src/cmd.c, src/decl.c, src/display.c, src/end.c,
+        src/invent.c, src/options.c, src/spell.c, src/topten.c, src/weapon.c,
+        win/tty/wintty.c, dat/opthelp, doc/Guidebook.*)
+- record the number of moves, and mark wizard/explore mode games in
+  logfile / record (src/topten.c)
+- show extincted monsters among the genocided ones and the numbers of 
+  different monsters born in the "vanquished" list after the numbers killed.
+  (Wingnut, Jukka Lahtinen) 
+        (include/flag.h, src/cmd.c, src/end.c, src/options.c, 
+        dat/opthelp, dat/wizhelp, doc/Guidebook.*)
+- paranoid, by David Damerell, Jonathan Nieder, Jukka Lahtinen and
+  Stanislav Traykov
+        (include/flag.h, src/cmd.c, src/do_wear.c, src/end.c, src/options.c,
+        src/potion.c, src/uhitm.c, dat/opthelp, doc/Guidebook.*)
+- Ralph Churchill's colored Hp monitor (src/botl.c)
+- Compile-time options for not writing #quit games to the record file
+  (FORGET_QUITTER) and not writing explore mode games to the logfile
+  (PROMPT_LOGEXP). (src/end.c, src/topten.c)
+- The compile time setting SCORE_ON_BOTL is overriden in the magic number
+  in the bones and save files, so compatibility with the official binaries
+  can be kept regardless of that option. (src/version.c)
+- Allow definitions for variable playground locations, such as separate
+  bones and levels directories, for OS/2. Use bones in directory "bones"
+  under the playground directory in unix systems.
+  (include/os2conf.h, src/files.c, sys/share/pcunix.c)
+- prompt for entering explore mode at death (include/flag.h, src/cmd.c,
+        src/end.c, src/options.c, dat/opthelp, doc/Guidebook.*)
+- Jeroen Demeyer's sortloot patch to optionally sort the pickup lists to
+  ascending order of descriptions within each item class
+  	(dat/opthelp, doc/Guidebook.*, include/extern.h, include/flag.h,
+	src/end.c, src/invent.c, src/objnam.c, src/options.c, src/pickup.c)
+- Pasi Kallinen's menucolor patch (http://www.cs.joensuu.fi/~pkalli)
+        (dat/opthelp, include/color.h, include/extern.h, include/flag.h,
+        src/decl.c, src/files.c, src/options.c, src/save.c,
+        win/tty/wintty.c)
+- Pasi Kallinen's window edge patch, optionally aligning menus and text
+  windows left instead of right in the tty interface.
+  http://cs.joensuu.fi/~pkalli/code/nh342-winedge.diff
+	(doc/Guidebook.*, dat/opthelp, include/flag.h, src/options.c, 
+	win/tty/wintty.c)
+- Stanislav Traykov's patch for additional item categories in the menus
+  http://home.in.tum.de/~traykovs/nethack/
+        (dat/opthelp, doc/Guidebook.*, include/extern.h, include/flag.h,
+        include/hack.h, include/objclass.h, include/obj.h, src/do.c,
+        src/invent.c, src/options.c, src/pickup.c)
+- Sam Dennis's patch to allow the #adjust command to split stacks
+        (src/invent.c)
+- Pasi Kallinen's helplessness patch that replaces the "while helpless"
+        text to be written to the record/logfile with the reason of
+        helplessness
+        (include/decl.h, include/extern.h, src/allmain.c, src/apply.c,
+        src/artifact.c, src/ball.c, src/decl.c, src/detect.c, src/dig.c,
+        src/dothrow.c, src/do_wear.c, src/eat.c, src/end.c, src/engrave.c,
+        src/explode.c, src/hack.c, src/mcastu.c, src/mhitu.c, src/mthrowu.c,
+        src/muse.c, src/pickup.c, src/polyself.c, src/potion.c, src/pray.c,
+        src/priest.c, src/save.c, src/sounds.c, src/spell.c, src/steal.c,
+        src/teleport.c, src/timeout.c, src/trap.c, src/uhitm.c, src/vault.c,
+        src/zap.c)
+- Pasi Kallinen's extra status attributes patch that adds statuses like 
+	encuberance, hunger, confusion, food poisoning, illness, blindness,
+	stun, hallucination and sliming to the minimal enlightenment screen
+	shown with ^X (http://bilious.homelinux.org/?226)
+	(include/extern.h, src/botl.c, src/cmd.c)
+- Make the f (fire) command prompt for ammuntition to quiver, when used
+	and nothing is quivered.
+	(dat/opthelp, doc/Guidebook.mn, doc/Guidebook.tex, doc/Guidebook.txt,
+	include.flag.h, src/dothrow.c, src/options.c)
+- Allow priest role to be played as any race (Haakon Studebaker)
+	(src/role.c, compile option PRIEST_RACES)
+- Patric Mueller's fixes for known bugs C343-100, C343-179, C343-218, 
+	C343-275, C343-276 and C343-324
+	(include/extern.h, src/apply.c, src/do.c, src/dokick.c, src/dothrow.c,
+	src/shk.c, src/trap.c, src/worm.c, src/zap.c)
+
+Most of these patches need some #define in include/config.h to get
+compiled in. I included a diff for config.h to show them.
+
+On unix systems with the dump patch, it is recommended for security reasons
+to define the DUMP_FN in include/config.h to prevent users from defining 
+the dumpfile name themselves, but here it is commented out because there is 
+no single directory name that would be good for EVERY patched Nethack 
+installation to have the dump files in and I try to keep this patch 
+collection as generic as possible.
+
+If you find any bugs in these patches, please let me know.
+For now, you can reach me at jtfjdehf@hotmail.com). 
+And I read rec.games.roguelike.nethack regularly.
+
+Of course, if you have some other changes made to the same files, you may
+need to edit some of the source files to insert some chunks of this diff
+manually. Check especially include/config.h for options that you may like
+to be set differently from my setup. 
+
+Some of the patches also need some options defined in your configuration file
+(~/.nethackrc in Linux and other unix-like systems, nethack.cnf in OS/2,
+defaults.nh on modern windows platforms, maybe something else on some 
+other platform) to take effect. To turn all of thse on, set
+
+OPTIONS=dumpfile:%n.nh (for the dump character patch in single user systems)
+OPTIONS=showborn        (to see the numbers of monsters born)
+OPTIONS=paranoid_hit,paranoid_quit,paranoid_remove   (for the paranoid patch)
+OPTIONS=death_explore   (to be prompted for explore mode when you die)
+OPTIONS=sortloot:loot   (for the sortloot patch)
+OPTIONS=win_edge	(for the window edge patch)
+OPTIONS=quiver_fired	(for the quiver fired ammunition patch)
+OPTIONS=menucolors      (to turn on the menucolor option)
+MENUCOLOR="* blessed *"=green    (some menucolor definition examples)
+MENUCOLOR="* holy *"=green       (if you have MENU_COLOR_REGEX defined
+MENUCOLOR="* cursed *"=red        in config.h, leave the asterisks out from
+MENUCOLOR="* unholy *"=red        the beginning and ending of the options)
+MENUCOLOR="* cursed .* (being worn)*"=orange&underline
+
+--
+Jukka Lahtinen, 3.1.2009
+jtfjdehf@hotmail.com
diff --git a/dat/Makefile b/dat/Makefile
new file mode 100644
index 0000000..75a5aa8
--- /dev/null
+++ b/dat/Makefile
@@ -0,0 +1,144 @@
+#	NetHack Makefile.
+#	SCCS Id: @(#)Makefile.dat	3.4	1992/09/18
+
+# for Atari
+# SHELL=E:/GEMINI2/MUPFEL.TTP
+# UUDECODE=uudecode
+
+VARDAT = data rumors quest.dat oracles options
+
+all:	$(VARDAT) spec_levs quest_levs dungeon
+
+../util/makedefs:
+	(cd ../util ; make makedefs)
+
+../util/dgn_comp:
+	(cd ../util ; make dgn_comp)
+
+../util/lev_comp:
+	(cd ../util ; make lev_comp)
+
+../util/tile2x11:
+	(cd ../util ; make tile2x11)
+
+../util/tile2beos:
+	(cd ../util ; make tile2beos)
+
+../util/tile2bmp:
+	(cd ../util ; make tile2bmp)
+
+x11tiles: ../util/tile2x11 ../win/share/monsters.txt ../win/share/objects.txt \
+				../win/share/other.txt
+	../util/tile2x11 ../win/share/monsters.txt ../win/share/objects.txt \
+				../win/share/other.txt
+
+beostiles: ../util/tile2beos ../win/share/monsters.txt ../win/share/objects.txt \
+				../win/share/other.txt
+	../util/tile2beos ../win/share/monsters.txt ../win/share/objects.txt \
+				../win/share/other.txt
+
+nhtiles.bmp: ../util/tile2bmp ../win/share/monsters.txt ../win/share/objects.txt \
+				../win/share/other.txt
+	../util/tile2bmp $@
+
+NetHack.ad: ../win/X11/NetHack.ad
+	cp ../win/X11/NetHack.ad NetHack.ad
+
+pet_mark.xbm: ../win/X11/pet_mark.xbm
+	cp ../win/X11/pet_mark.xbm pet_mark.xbm
+
+rip.xpm: ../win/X11/rip.xpm
+	cp ../win/X11/rip.xpm rip.xpm
+
+mapbg.xpm: ../win/gnome/mapbg.xpm
+	cp ../win/gnome/mapbg.xpm mapbg.xpm
+
+nhsplash.xpm: ../win/Qt/nhsplash.xpm
+	cp ../win/Qt/nhsplash.xpm nhsplash.xpm
+
+nethack.icns: ../win/Qt/nhicns.uu
+	$(UUDECODE) ../win/Qt/nhicns.uu
+
+Info.plist: ../win/Qt/Info.pli
+	cp ../win/Qt/Info.pli Info.plist
+
+../util/tile2img.ttp:
+	(cd ../util ; make tile2img.ttp)
+
+../util/xpm2img.ttp:
+	(cd ../util ; make xpm2img.ttp)
+nh16.img: ../util/tile2img.ttp ../win/share/monsters.txt \
+				../win/share/objects.txt ../win/share/other.txt
+	../util/tile2img.ttp nh16.img
+
+rip.img: ../util/xpm2img.ttp
+	../util/xpm2img.ttp ../win/X11/rip.xpm rip.img
+title.img:
+	# cp ../win/gem/title.img title.img
+	$(UUDECODE) ../win/gem/title.uu
+
+GEM_RSC.RSC:
+	# cp ../win/gem/GEM_RSC.RSC GEM_RSC.RSC
+	$(UUDECODE) ../win/gem/gem_rsc.uu
+
+
+data:	data.base ../util/makedefs
+	../util/makedefs -d
+
+rumors:	rumors.tru rumors.fal ../util/makedefs
+	../util/makedefs -r
+
+quest.dat:	quest.txt ../util/makedefs
+	../util/makedefs -q
+
+oracles:	oracles.txt ../util/makedefs
+	../util/makedefs -h
+
+# note: 'options' should have already been made when include/date.h was created
+options:	../util/makedefs
+	../util/makedefs -v
+
+
+spec_levs: ../util/lev_comp \
+	bigroom.des castle.des endgame.des gehennom.des knox.des medusa.des \
+	mines.des oracle.des sokoban.des tower.des yendor.des
+	../util/lev_comp bigroom.des
+	../util/lev_comp castle.des
+	../util/lev_comp endgame.des
+	../util/lev_comp gehennom.des
+	../util/lev_comp knox.des
+	../util/lev_comp medusa.des
+	../util/lev_comp mines.des
+	../util/lev_comp oracle.des
+	../util/lev_comp sokoban.des
+	../util/lev_comp tower.des
+	../util/lev_comp yendor.des
+	touch spec_levs
+
+quest_levs: ../util/lev_comp \
+	Arch.des Barb.des Caveman.des Healer.des Knight.des Monk.des \
+	Priest.des Ranger.des Rogue.des Samurai.des Tourist.des Valkyrie.des \
+	Wizard.des
+	../util/lev_comp Arch.des
+	../util/lev_comp Barb.des
+	../util/lev_comp Caveman.des
+	../util/lev_comp Healer.des
+	../util/lev_comp Knight.des
+	../util/lev_comp Monk.des
+	../util/lev_comp Priest.des
+	../util/lev_comp Ranger.des
+	../util/lev_comp Rogue.des
+	../util/lev_comp Samurai.des
+	../util/lev_comp Tourist.des
+	../util/lev_comp Valkyrie.des
+	../util/lev_comp Wizard.des
+	touch quest_levs
+
+dungeon: dungeon.def ../util/makedefs ../util/dgn_comp
+	../util/makedefs -e
+	../util/dgn_comp dungeon.pdf
+
+spotless:
+	-rm -f spec_levs quest_levs *.lev $(VARDAT) dungeon dungeon.pdf
+	-rm -f nhdat x11tiles beostiles pet_mark.xbm rip.xpm mapbg.xpm
+	-rm -f rip.img GEM_RSC.RSC title.img nh16.img NetHack.ad
diff --git a/dat/opthelp b/dat/opthelp
index 4dade58..fdec199 100644
--- a/dat/opthelp
+++ b/dat/opthelp
@@ -51,6 +51,10 @@ verbose        print more commentary during the game              [TRUE]
 
 There are further boolean options controlled by compilation flags.
 
+Boolean option if ITEMCAT was set at compile time:
+like_swimming   allow category "Items known to be Rustprone" in
+                selection menus                                   [FALSE]
+
 Boolean option if INSURANCE was set at compile time:
 checkpoint save game state after each level change, for possible  [TRUE]
            recovery after program crash
@@ -61,6 +65,9 @@ news       print any news from game administrator on startup      [TRUE]
 Boolean option if MFLOPPY was set at compile time:
 checkspace check free disk space before writing files to disk     [TRUE]
 
+Boolean option if DEATH_EXPLORE was set at compile time:
+death_explore prompt for changing to explore mode when you die    [FALSE]
+
 Boolean option if EXP_ON_BOTL was set at compile time:
 showexp    display your accumulated experience points             [FALSE]
 
@@ -71,17 +78,41 @@ Boolean options if TEXTCOLOR was set at compile time:
 color      use different colors for objects on screen   [TRUE for micros]
 hilite_pet display pets in a highlighted manner                   [FALSE]
 
+Boolean option if TEXTCOLOR and MENU_COLOR were set at compile time:
+menucolors use different colors for menus               [TRUE for micros]
+
+Boolean option if PARANOID was set at compile time:
+paranoid_hit   ask for explicit 'yes' when hitting peacefuls      [FALSE]
+
+Boolean option if PARANOID was set at compile time:
+paranoid_quit  ask for explicit 'yes' when quitting               [FALSE]
+
+Boolean option if PARANOID was set at compile time:
+paranoid_remove always show menu with the T and R commands        [FALSE]
+
+Boolean option if SHOW_BORN was set at compile time:
+showborn   show numbers of created monsters after the number
+           vanquished                                             [FALSE]
+
 Boolean option if TIMED_DELAY was set at compile time (tty interface only):
 timed_delay    on unix and VMS, use a timer instead of sending
                extra screen output when attempting to pause for
                display effect.  on MSDOS without the termcap
                lib, whether or not to pause for visual effect.    [TRUE]
 
+Boolean option if QUIVER_FIRED was set at compile time:
+quiver_fired   when using the f (fire) command and no ammunition
+               is quivered, prompt for ammunition to quiver, then 
+               fire it.                                           [FALSE]
+
 Boolean option if USE_TILES was set at compile time (MSDOS protected mode only):
 preload_tiles  control whether tiles get pre-loaded into RAM at the
                start of the game.  Doing so enhances performance
                of the tile graphics, but uses more memory.        [TRUE]
 
+Boolean option if WIN_EDGE was set at compile time (tty interface only):
+win_edge       align menus and text windows left instead of right [FALSE]
+
 Any Boolean option can be negated by prefixing it with a '!' or 'no'.
 
 
@@ -92,6 +123,9 @@ Compound options which can be set during the game are:
 boulder       override the default boulder symbol with another default: [`]
 disclose      the types of information you want offered at the end of the
               game  [ni na nv ng nc]
+dumpfile      the name of the file where to dump the disclosure information
+              when the game ends (only if the patch has been compiled in)
+              [none]
 fruit         the name of a fruit you enjoy eating  [slime mold]
               (basically a whimsy which NetHack uses from time to time).
 menustyle     user interface for selection of multiple objects:
@@ -120,6 +154,11 @@ runmode       controls how often the map window is updated when performing
 scores        the parts of the score list you wish to see when the game ends
               You choose a combination of top scores, scores around the top
               scores, and all of your own scores.  [!own/3 top/2 around]
+sortloot      controls the sortloot patch [none]:
+              full -- All pickup lists of items are sorted by item description
+              loot -- When inventory letters are shown, has no effect.
+                      Otherwise sorts by description
+              none -- Works the traditional way, like without the patch
 suppress_alert disable various version-specific warnings about changes
               in game play or the user interface, such as notification given
               for the 'Q' command that quitting is now done via #quit
@@ -169,6 +208,21 @@ gender     Your starting gender (gender:male or gender:female).
            still denote your gender using the "male" and "female"
            options, the "gender" option will take precedence.  [RANDOM]
 horsename  the name of your first horse  [NONE]
+menucolor  Set colors for menus. (menucolor:"regex_string"=color)
+           If boolean option ``menucolors'' is true, menus will be shown
+	   with different colors.
+	   For example, setting ``menucolor:" blessed "=green'' shows
+	   all lines in a menu with the text " blessed " in green.
+	   The string is matched using regular expressions.
+	   Valid values for the color are black, red, green, brown, blue,
+	   magenta, cyan, gray, orange, lightgreen, yellow, lightblue,
+	   lightmagenta, lightcyan and white.
+	   You can define menucolor as many times as you wish; those
+	   defined later will take precedence.
+	   Instead of using this with OPTIONS, consider using
+	   MENUCOLOR="regex_string"=color in the configuration file.
+	   Setting menucolor has effect only if TEXTCOLOR and MENU_COLOR
+	   were set at compile time.  [NONE]
 menu_*     create single character accelerators for menu commands.  Below
            is a list of all commands.  Each is followed by a list of window-
            ports that implement them:  'x' is X11, 't' is tty, 'g' is Gem,
diff --git a/dat/options b/dat/options
new file mode 100644
index 0000000..b1b4231
--- /dev/null
+++ b/dat/options
@@ -0,0 +1,29 @@
+
+    NetHack version 3.4.3
+
+Options compiled into this edition:
+
+    autopickup_exceptions, color, data file compression, data librarian,
+    debug mode, Elbereth, experience points on status line,
+    insurance files for recovering from crashes, Keystone Kops, log file,
+    mail daemon, news file, redo command, rogue level, saddles and riding,
+    score on status line, screen clipping, seduction, shell command, sinks,
+    suspend command, terminal info library, timed wait for display effects,
+    tourists, walled mazes,
+    save and bones files accepted from versions 3.4.0 through 3.4.3,
+    patch: colored Hp monitor, patch: dump game end info,
+    patch: explore mode at death, patch: extra status attributes,
+    patch: helplessness reasons, patch: item categories,
+    patch: log move counter, patch: no record entry for quitting,
+    patch: paranoid, patch: priests for every race,
+    patch: prompt explore/wizard mode logging,
+    patch: quiver with the f command, patch: show extinct monsters,
+    patch: show monsters born, patch: sortloot, patch: splittable #adjust,
+    patch: tty menu colors via regular expressions, patch: win_edge,
+    basic NetHack features.
+
+Supported windowing systems:
+
+    traditional tty-based graphics,
+    with a default of tty.
+
diff --git a/dat/wizhelp b/dat/wizhelp
index 6b38bc8..6d3c01b 100644
--- a/dat/wizhelp
+++ b/dat/wizhelp
@@ -16,6 +16,7 @@ Debug-Mode Quick Reference:
 #panic == panic test
 #polyself == polymorph self
 #seenv == show seen vectors
+#showkills == show numbers of monsters killed
 #stats == show memory statistics
 #timeout == look at timeout queue
 #vision == show vision array
diff --git a/doc/Guidebook.mn b/doc/Guidebook.mn
index f67f02f..2e7e48d 100644
--- a/doc/Guidebook.mn
+++ b/doc/Guidebook.mn
@@ -1723,6 +1723,8 @@ new players if it detects some anticipated mistakes (default on).
 .lp "confirm "
 Have user confirm attacks on pets, shopkeepers, and other
 peaceable creatures (default on).
+.lp death_explore
+Prompt for changing to explore mode when your character dies.
 .lp DECgraphics
 Use a predefined selection of characters from the DEC VT-xxx/DEC
 Rainbow/ANSI line-drawing character set to display the dungeon/effects/traps
@@ -1770,6 +1772,12 @@ traps and each other as well as by you.
 .lp dogname
 Name your starting dog (ex. ``dogname:Fang'').
 Cannot be set with the `O' command.
+.lp dumpfile
+The name of a file where the disclosure information is written when the
+game ends. You may use the macro %n that will be replaced with the name
+of your player character. The game must have write permissions to the
+directory where the file is written. Normally /tmp may be used for unix
+systems.
 .lp dungeon
 Set the graphics symbols for displaying the dungeon
 (default \&``\ |--------||.-|++##.##<><>_|\e\e#{}.}..##\ #}'').
@@ -1874,6 +1882,8 @@ even if you override the selections with your own graphics strings.
 Ignore interrupt signals, including breaks (default off).
 .lp legacy
 Display an introductory message when starting the game (default on).
+.lp like_swimming
+Allow category ``Items known to be Rustprone'' in selection menus.
 .lp lit_corridor
 Show corridor squares seen by night vision or a light source held by your
 character as lit (default off).
@@ -2027,6 +2037,15 @@ Specify the order to list object types in (default ``")[%?+!=/(*`0_'').
 The value of this option should be a string containing the
 symbols for the various object types.  Any omitted types are filled in
 at the end from the previous order.
+.lp paranoid_hit
+If true, asks you to type the word ``yes'' when hitting any peaceful
+monster, not just the letter ``y''.
+.lp paranoid_quit
+If true, asks you to type the word ``yes'' when quitting or entering
+Explore mode, not just the letter ``y''.
+.lp paranoid_remove
+If true, always show menu with the R and T commands even when there is
+only one item to remove or take off.
 .lp perm_invent
 If true, always display your current inventory in a window.  This only
 makes sense for windowing system interfaces that implement this feature.
@@ -2054,6 +2073,9 @@ Prompt for confirmation before praying (default on).
 .lp pushweapon
 Using the `w' (wield) command when already wielding
 something pushes the old item into your alternate weapon slot (default off).
+.lp quiver_fired
+Using the 'f' (fire) command when nothing is quivered, prompts for ammunition 
+to quiver, then fires it (default off).
 .lp race
 Selects your race (for example, ``race:human'').  Default is random.
 Cannot be set with the `O' command.
@@ -2088,6 +2110,10 @@ Prevent you from (knowingly) attacking your pets (default on).
 Control what parts of the score list you are shown at the end (ex.
 ``scores:5 top scores/4 around my score/own scores'').  Only the first
 letter of each category (`t', `a', or `o') is necessary.
+.lp showborn
+When the game ends, show the number of each monster created
+in the "Vanquished creatures" list, if it differs from the
+number of those monsters killed.
 .lp showexp
 Show your accumulated experience points on bottom line (default off).
 .lp showrace
@@ -2098,6 +2124,18 @@ the appearance of the display, not the way the game treats you.
 Show your approximate accumulated score on bottom line (default off).
 .lp "silent  "
 Suppress terminal beeps (default on).
+.lp sortloot
+Controls the behavior of the sortloot patch that sorts pickup lists for
+inventory and #loot commands and some others.
+The possible values are:
+.sd
+.si
+full - always sort the lists;
+loot - only sort the lists that don't use inventory
+       letters, like with the #loot and pickup commands;
+none - show lists the traditional way without sorting.
+.ei
+.ed
 .lp sortpack
 Sort the pack contents by type when displaying inventory (default on).
 .lp sound
@@ -2157,6 +2195,8 @@ Provide more commentary during the game (default on).
 Select which windowing system to use, such as ``tty'' or ``X11''
 (default depends on version).
 Cannot be set with the `O' command.
+.lp win_edge
+Align menus and text windows in tty left instead of right. (default off)
 .hn 2
 Window Port Customization options
 .pg
diff --git a/doc/Guidebook.tex b/doc/Guidebook.tex
index f76398f..7ae6d8b 100644
--- a/doc/Guidebook.tex
+++ b/doc/Guidebook.tex
@@ -2161,6 +2161,9 @@ players if it detects some anticipated mistakes (default on).
 Have user confirm attacks on pets, shopkeepers, and other
 peaceable creatures (default on).
 %.lp
+\item[\ib{death_explore}]
+Prompt for changing to explore mode when your character dies.
+%.lp
 \item[\ib{DECgraphics}]
 Use a predefined selection of characters from the DEC VT-xxx/DEC
 Rainbow/ANSI line-drawing character set to display the dungeon/effects/traps
@@ -2209,6 +2212,13 @@ traps and each other as well as by you.
 Name your starting dog (ex.\ ``{\tt dogname:Fang}'').
 Cannot be set with the `{\tt O}' command.
 %.lp
+\item[\ib{dumpfile}]
+The name of a file where the disclosure information is written when the
+game ends. You may use the macro %n that will be replaced with the name
+of your player character. The game must have write permissions to the
+directory where the file is written. Normally /tmp may be used for unix
+systems.
+%.lp
 \item[\ib{dungeon}]
 Set the graphics symbols for displaying the dungeon (default
 ``\verb& |--------||.-|++##& \verb&.##<><>_|\\#{}.}..## #}&'').
@@ -2321,6 +2331,9 @@ Ignore interrupt signals, including breaks (default off).
 \item[\ib{legacy}]
 Display an introductory message when starting the game (default on).
 %.lp
+\item[\ib{like\_swimming}]
+Allow category ``Items known to be Rustprone'' in selection menus.
+%.lp
 \item[\ib{lit\_corridor}]
 Show corridor squares seen by night vision or a light source held by your
 character as lit (default off).
@@ -2486,6 +2499,18 @@ Specify the order to list object types in (default
 containing the symbols for the various object types.  Any omitted types
 are filled in at the end from the previous order.
 %.lp
+\item[\ib{paranoid\_hit}]
+If true, asks you to type the word ``yes'' when hitting any peaceful
+monster, not just the letter ``y''.
+%.lp
+\item[\ib{paranoid\_quit}]
+If true, asks you to type the word ``yes'' when quitting or entering
+Explore mode, not just the letter ``y''.
+%.lp
+\item[\ib{paranoid\_remove}]
+If true, always show menu with the R and T commands even when there is
+only one item to remove or take off.
+%.lp
 \item[\ib{perm\_invent}]
 If true, always display your current inventory in a window.  This only
 makes sense for windowing system interfaces that implement this feature.
@@ -2515,6 +2540,10 @@ Prompt for confirmation before praying (default on).
 \item[\ib{pushweapon}]
 Using the `w' (wield) command when already wielding
 something pushes the old item into your alternate weapon slot (default off).
+%.lp
+\item[\ib{quiver_fired}]
+Using the 'f' (fire) command when nothing is quivered, prompts for ammunition 
+to quiver, then fires it (default off).
 %.Ip
 \item[\ib{race}]
 Selects your race (for example, ``{\tt race:human}'').  Default is random.
@@ -2559,6 +2588,11 @@ Control what parts of the score list you are shown at the end (ex.\
 ``{\tt scores:5top scores/4around my score/own scores}'').  Only the first
 letter of each category (`{\tt t}', `{\tt a}' or `{\tt o}') is necessary.
 %.lp
+\item[\ib{showborn}]
+When the game ends, show the number of each monster created
+in the ``Vanquished creatures'' list, if it differs from the
+number of those monsters killed.
+%.lp
 \item[\ib{showexp}]
 Show your accumulated experience points on bottom line (default off).
 %.lp
@@ -2573,6 +2607,21 @@ Show your approximate accumulated score on bottom line (default off).
 \item[\ib{silent}]
 Suppress terminal beeps (default on).
 %.lp
+\item[\ib{sortloot}]
+Controls the behavior of the sortloot patch that sorts pickup lists for
+inventory and \#loot commands and some others.
+
+The possible values are:
+%.sd
+%.si
+{\tt full} --- always sort the lists;\\
+{\tt loot} --- only sort the lists that don't use inventory
+       letters, like with the \#loot and pickup commands;\\
+{\tt none} --- show lists the traditional way without sorting.
+%.ei
+%.ed
+%.lp
+The default is 'none', the way an unpatched game works.
 \item[\ib{sortpack}]
 Sort the pack contents by type when displaying inventory (default on).
 %.lp
@@ -2640,6 +2689,9 @@ Provide more commentary during the game (default on).
 Select which windowing system to use, such as ``{\tt tty}'' or ``{\tt X11}''
 (default depends on version).
 Cannot be set with the `{\tt O}' command.
+%.lp
+\item[\ib{win_edge}]
+Align menus and text windows in tty left instead of right. (default off)
 \elist
 
 %.hn 2
diff --git a/doc/Guidebook.txt b/doc/Guidebook.txt
index f0f9f7d..6dd2f98 100644
--- a/doc/Guidebook.txt
+++ b/doc/Guidebook.txt
@@ -2223,6 +2223,9 @@
             Have  user  confirm  attacks  on  pets,  shopkeepers, and other
             peaceable creatures (default on).
 
+          death_explore
+            Prompt for changing to explore mode when your character dies.
+
           DECgraphics
             Use a predefined selection  of  characters  from  the  DEC  VT-
             xxx/DEC  Rainbow/ANSI line-drawing character set to display the
@@ -2274,6 +2277,13 @@
             Name  your  starting dog (ex. ``dogname:Fang'').  Cannot be set
             with the `O' command.
 
+          dumpfile
+            The name of a file where the disclosure information is
+            written when the game ends. You may use the macro %n that
+            will be replaced with the name of your player character.
+            The game must have write permissions to the directory where
+            the file is written. Normally /tmp may be used for unixes.
+
           dungeon
             Set the graphics symbols for displaying  the  dungeon  (default
             `` |--------||.-|++##.##<><>_|\\#{}.}..## #}'').   The  dungeon
@@ -2413,6 +2423,10 @@
             Display an introductory message when starting the game (default
             on).
 
+          like_swimming
+            Allow category "Items known to be Rustprone" in selection
+            menus.
+
           lit_corridor
             Show corridor squares seen by night vision or  a  light  source
             held by your character as lit (default off).
@@ -2607,6 +2621,18 @@
             Any  omitted  types  are filled in at the end from the previous
             order.
 
+          paranoid_hit
+            If true, asks you to type the word ``yes'' when hitting any
+            peaceful monster, not just the letter ``y''.
+
+          paranoid_quit
+            If true, asks you  to type the word ``yes'' when quitting or
+            entering Explore mode, not just the letter ``y''.
+
+          paranoid_remove
+            If true, always show menu with the R and T commands even when
+            there is only one item to remove or take off.
+
           perm_invent
             If true, always display your current  inventory  in  a  window.
             This  only makes sense for windowing system interfaces that im-
@@ -2652,6 +2678,10 @@
             pushes  the  old  item into your alternate weapon slot (default
             off).
 
+          quiver_fired
+            Using the 'f' (fire) command when nothing is quivered, prompts
+            for ammunition to quiver, then fires it (default off).
+
           race
             Selects your race (for example,  ``race:human'').   Default  is
             random.  Cannot be set with the `O' command.
@@ -2693,6 +2723,11 @@
             Only the first letter of each category (`t', `a',  or  `o')  is
             necessary.
 
+          showborn
+               When the game ends, show the number of each monster created
+               in the "Vanquished creatures" list, if it differs from the
+               number of those monsters killed.
+
           showexp
             Show your accumulated experience points on bottom line (default
             off).
@@ -2723,6 +2758,18 @@
           silent
             Suppress terminal beeps (default on).
 
+          sortloot
+            Controls the behavior of the sortloot patch that sorts
+            pickup lists for inventory and #loot commands and some
+            others.
+            The possible values are:
+
+                 full - always sort the lists
+                 loot - only sort the lists that don't use inventory
+                        letters, like with the #loot and pickup commands
+                 none - show lists the traditional way without sorting
+            The default is 'none', the way an unpatched game works.
+
           sortpack
             Sort the pack contents by type when displaying  inventory  (de-
             fault on).
@@ -2808,6 +2855,10 @@
             ``X11''  (default  depends on version).  Cannot be set with the
             `O' command.
 
+          win_edge
+            Align menus and text windows in tty left instead of right.
+            (default off)
+
           9.5.  Window Port Customization options
 
                Here are explanations of the various options that  are  used
diff --git a/doc/Makefile b/doc/Makefile
new file mode 100644
index 0000000..647e90a
--- /dev/null
+++ b/doc/Makefile
@@ -0,0 +1,95 @@
+#	NetHack Makefile.
+#	SCCS Id: @(#)Makefile.doc	3.4	1996/03/23
+
+# for Atari
+# SHELL=E:/GEMINI2/MUPFEL.TTP
+
+GUIDEBOOK = Guidebook		# regular ASCII file
+#GUIDEBOOK = Guidebook.ps	# PostScript file
+#GUIDEBOOK = Guidebook.dvi	# TeX device-independent file
+
+# Some versions of col need -x to keep them from converting spaces to tabs;
+# some versions of col don't do the conversion by default and don't
+# recognize the option.  Sigh.
+COLCMD = col -bx
+#COLCMD = col -b
+
+# The command to use to generate a PostScript file
+# PSCMD = ditroff | psdit
+PSCMD = groff
+
+# Use the "cat" GUIDECMD if nroff and/or tbl and/or col are not installed
+# Not appropriate for creating Guidebook.txt.
+# GUIDECMD = cat Guidebook.txt
+# The following works better with groff-1.18, eg on Linux
+# GUIDECMD = tbl tmac.n Guidebook.mn | nroff -c -Tascii | $(COLCMD)
+GUIDECMD = tbl tmac.n Guidebook.mn | nroff | $(COLCMD)
+
+# the basic guidebook
+Guidebook:	Guidebook.mn
+	$(GUIDECMD) > Guidebook
+
+# Fancier output for those with ditroff, psdit and a PostScript printer.
+Guidebook.ps:	Guidebook.mn
+	tbl tmac.n Guidebook.mn | $(PSCMD) > Guidebook.ps
+
+# Guidebook.tex is the same as Guidebook.mn but formatted with LaTeX.
+# - The invocation command for LaTeX may vary in different installations.
+# - To print Guidebook.dvi you need to use a suitable dvi-driver.
+Guidebook.dvi:	Guidebook.tex
+	latex Guidebook.tex
+
+
+GAME	= nethack
+MANDIR	= /usr/man/man6
+MANEXT	= 6
+
+# manual installation for most BSD-style systems
+GAMEMANCREATE = cp nethack.6
+LEVMANCREATE = cp lev_comp.6
+DGNMANCREATE = cp dgn_comp.6
+RCVRMANCREATE = cp recover.6
+DLBMANCREATE = cp dlb.6
+# manual installation for most SYSV-style systems
+# GAMEMANCREATE = nroff -man nethack.6 >
+# LEVMANCREATE = nroff -man lev_comp.6 >
+# DGNMANCREATE = nroff -man dgn_comp.6 >
+# RCVRMANCREATE = nroff -man recover.6 >
+# DLBMANCREATE = nroff -man dlb.6 >
+
+manpages:
+	-$(GAMEMANCREATE) $(MANDIR)/$(GAME).$(MANEXT)
+	-$(LEVMANCREATE) $(MANDIR)/lev_comp.$(MANEXT)
+	-$(DGNMANCREATE) $(MANDIR)/dgn_comp.$(MANEXT)
+	-$(RCVRMANCREATE) $(MANDIR)/recover.$(MANEXT)
+	-$(DLBMANCREATE) $(MANDIR)/dlb.$(MANEXT)
+
+# manual creation for distribution
+DISTRIB = Guidebook.txt nethack.txt lev_comp.txt dgn_comp.txt recover.txt dlb.txt
+
+distrib: $(DISTRIB)
+	@echo "Plain text documentation is up to date."
+
+Guidebook.txt	: Guidebook.mn tmac.n
+	$(GUIDECMD) > Guidebook.txt
+nethack.txt	: nethack.6
+	nroff -man nethack.6 | $(COLCMD) > nethack.txt
+lev_comp.txt	: lev_comp.6
+	nroff -man lev_comp.6 | $(COLCMD) > lev_comp.txt
+dgn_comp.txt	: dgn_comp.6
+	nroff -man dgn_comp.6 | $(COLCMD) > dgn_comp.txt
+recover.txt	: recover.6
+	nroff -man recover.6 | $(COLCMD) > recover.txt
+dlb.txt		: dlb.6
+	nroff -man dlb.6 | $(COLCMD) > dlb.txt
+
+
+clean:
+	-rm -f Guidebook.aux Guidebook.log
+
+spotless: clean
+	-rm -f Guidebook Guidebook.ps Guidebook.dvi
+
+maintainer-clean: spotless
+	-rm -f $(DISTRIB)
+#	-rm -f Makefile
diff --git a/include/color.h b/include/color.h
index 2fe85d1..9344977 100644
--- a/include/color.h
+++ b/include/color.h
@@ -5,6 +5,12 @@
 #ifndef COLOR_H
 #define COLOR_H
 
+#ifdef MENU_COLOR
+# ifdef MENU_COLOR_REGEX
+#  include <regex.h>
+# endif
+#endif
+
 /*
  * The color scheme used is tailored for an IBM PC.  It consists of the
  * standard 8 colors, folowed by their bright counterparts.  There are
@@ -49,4 +55,16 @@
 #define DRAGON_SILVER	CLR_BRIGHT_CYAN
 #define HI_ZAP		CLR_BRIGHT_BLUE
 
+#ifdef MENU_COLOR
+struct menucoloring {
+# ifdef MENU_COLOR_REGEX
+    struct re_pattern_buffer match;
+# else
+    char *match;
+# endif
+    int color, attr;
+    struct menucoloring *next;
+};
+#endif /* MENU_COLOR */
+
 #endif /* COLOR_H */
diff --git a/include/config.h b/include/config.h
index 3efbfa2..1e3c972 100644
--- a/include/config.h
+++ b/include/config.h
@@ -169,8 +169,8 @@
 
 #ifdef UNIX
 /* path and file name extension for compression program */
-#define COMPRESS "/usr/bin/compress"	/* Lempel-Ziv compression */
-#define COMPRESS_EXTENSION ".Z"		/* compress's extension */
+#define COMPRESS "/bin/gzip"	/* Lempel-Ziv compression */
+#define COMPRESS_EXTENSION ".gz"		/* compress's extension */
 /* An example of one alternative you might want to use: */
 /* #define COMPRESS "/usr/local/bin/gzip" */	/* FSF gzip compression */
 /* #define COMPRESS_EXTENSION ".gz" */		/* normal gzip extension */
@@ -185,7 +185,7 @@
  *	a tar-like file, thus making a neater installation.  See *conf.h
  *	for detailed configuration.
  */
-/* #define DLB */	/* not supported on all platforms */
+#define DLB	/* not supported on all platforms */
 
 /*
  *	Defining INSURANCE slows down level changes, but allows games that
@@ -204,7 +204,7 @@
  * otherwise it will be the current directory.
  */
 # ifndef HACKDIR
-#  define HACKDIR "/usr/games/lib/nethackdir"
+#  define HACKDIR "/usr/share/nethack"
 # endif
 
 /*
@@ -338,7 +338,7 @@ typedef unsigned char	uchar;
 #endif
 
 #define EXP_ON_BOTL	/* Show experience on bottom line */
-/* #define SCORE_ON_BOTL */	/* added by Gary Erickson (erickson@ucivax) */
+#define SCORE_ON_BOTL	/* added by Gary Erickson (erickson@ucivax) */
 
 /*
  * Section 5:  EXPERIMENTAL STUFF
@@ -349,7 +349,36 @@ typedef unsigned char	uchar;
  */
 
 /*#define GOLDOBJ */	/* Gold is kept on obj chains - Helge Hafting */
-/*#define AUTOPICKUP_EXCEPTIONS */ /* exceptions to autopickup */
+#define AUTOPICKUP_EXCEPTIONS  /* exceptions to autopickup */
+#define DUMP_LOG	/* Dump game end information to a file */
+/* #define DUMP_FN "/tmp/%n.nh" */	/* Fixed dumpfile name, if you want
+					 * to prevent definition by users */
+#define DUMPMSGS 20	/* Number of latest messages in the dump file  */
+#define LOG_MOVES	/* Move count and wiz/exp mode info in logfile */
+#define SHOW_BORN	/* Show numbers of each monster created */
+#define SHOW_EXTINCT	/* Show extinct species in the genocide list */
+#define SORTLOOT	/* Enable alphabetical sorting of pickup lists */
+#define PARANOID	/* Require "yes" for quit or switch to explore */
+#ifdef TTY_GRAPHICS
+# define HPMON		/* Color hp monitor */
+# define MENU_COLOR
+# define MENU_COLOR_REGEX
+/* if MENU_COLOR_REGEX is defined, use regular expressions (GNU regex.h)
+ * otherwise use pmatch() to match menu color lines.
+ * pmatch() provides basic globbing: '*' and '?' wildcards.
+ */
+# define WIN_EDGE	/* windows aligned left&top */
+#endif
+#define FORGET_QUITTER	/* No record entry for quitters */
+#define PROMPT_LOGEXP	/* Prompt for log entry in wizard or explore mode */
+#define DEATH_EXPLORE	/* Prompt for explore mode on death */
+#define ITEMCAT		/* Additional item categories */
+#define ITEMCAT_JP	/* "just picked" category */
+#define ADJSPLIT	/* splittable #adjust command */
+#define HELPLESS	/* "while helpless" patch */
+#define ENL_STATS	/* extra status attributes patch */
+#define QUIVER_FIRED	/* prompt quivering on f command */
+#define PRIEST_RACES	/* allow all races for priest role */
 
 /* End of Section 5 */
 
diff --git a/include/date.h b/include/date.h
new file mode 100644
index 0000000..de58b6b
--- /dev/null
+++ b/include/date.h
@@ -0,0 +1,16 @@
+/*	SCCS Id: @(#)date.h	3.4	2002/02/03 */
+
+/* This source file is generated by 'makedefs'.  Do not edit. */
+#define BUILD_DATE "Mon Feb 16 15:27:21 2009"
+#define BUILD_TIME (1234816041L)
+
+#define VERSION_NUMBER 0x03040300UL
+#define VERSION_FEATURES 0x003e0cc6UL
+#define IGNORED_FEATURES 0x00b20000UL
+#define VERSION_SANITY1 0x211b117eUL
+#define VERSION_SANITY2 0xa48195c8UL
+
+#define VERSION_STRING "3.4.3"
+#define VERSION_ID \
+ "Unix NetHack Version 3.4.3 - last build Mon Feb 16 15:27:21 2009."
+
diff --git a/include/decl.h b/include/decl.h
index 76f9533..1298c82 100644
--- a/include/decl.h
+++ b/include/decl.h
@@ -27,6 +27,9 @@ E char SAVEP[];
 E NEARDATA int bases[MAXOCLASSES];
 
 E NEARDATA int multi;
+#ifdef HELPLESS
+E char multi_txt[BUFSZ];
+#endif
 #if 0
 E NEARDATA int warnlevel;
 #endif
@@ -184,6 +187,9 @@ E const char *delayed_killer;
 E long done_money;
 #endif
 E char killer_buf[BUFSZ];
+#ifdef DUMP_LOG
+E char dump_fn[];		/* dumpfile name (dump patch) */
+#endif
 E const char *configfile;
 E NEARDATA char plname[PL_NSIZ];
 E NEARDATA char dogname[];
diff --git a/include/extern.h b/include/extern.h
index 4e2314d..4a657e5 100644
--- a/include/extern.h
+++ b/include/extern.h
@@ -116,6 +116,10 @@ E void NDECL(drag_down);
 
 /* ### bones.c ### */
 
+#ifdef ENL_STATS
+E const char *NDECL(encstat);
+E const char *NDECL(hunstat);
+#endif
 E boolean NDECL(can_make_bones);
 E void FDECL(savebones, (struct obj *));
 E int NDECL(getbones);
@@ -131,6 +135,10 @@ E long NDECL(botl_score);
 E int FDECL(describe_level, (char *));
 E const char *FDECL(rank_of, (int,SHORT_P,BOOLEAN_P));
 E void NDECL(bot);
+#ifdef DUMP_LOG
+E void FDECL(bot1str, (char *));
+E void FDECL(bot2str, (char *));
+#endif
 
 /* ### cmd.c ### */
 
@@ -166,6 +174,10 @@ E int NDECL(doextlist);
 E int NDECL(extcmd_via_menu);
 E void FDECL(enlightenment, (int));
 E void FDECL(show_conduct, (int));
+#ifdef DUMP_LOG
+E void FDECL(dump_enlightenment, (int));
+E void FDECL(dump_conduct, (int));
+#endif
 E int FDECL(xytod, (SCHAR_P,SCHAR_P));
 E void FDECL(dtoxy, (coord *,int));
 E int FDECL(movecmd, (CHAR_P));
@@ -281,6 +293,9 @@ E void NDECL(clear_glyph_buffer);
 E void FDECL(row_refresh, (int,int,int));
 E void NDECL(cls);
 E void FDECL(flush_screen, (int));
+#ifdef DUMP_LOG
+E void NDECL(dump_screen);
+#endif
 E int FDECL(back_to_glyph, (XCHAR_P,XCHAR_P));
 E int FDECL(zapdir_to_glyph, (int,int,int));
 E int FDECL(glyph_at, (XCHAR_P,XCHAR_P));
@@ -553,6 +568,10 @@ E void VDECL(panic, (const char *,...)) PRINTF_F(1,2);
 #if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
 E void FDECL(done, (int));
 E void FDECL(container_contents, (struct obj *,BOOLEAN_P,BOOLEAN_P));
+#ifdef DUMP_LOG
+E void FDECL(dump, (char *, char *));
+E void FDECL(do_containerconts, (struct obj *,BOOLEAN_P,BOOLEAN_P,BOOLEAN_P,BOOLEAN_P));
+#endif
 E void FDECL(terminate, (int));
 E int NDECL(num_genocides);
 
@@ -694,7 +713,11 @@ E void FDECL(check_special_room, (BOOLEAN_P));
 E int NDECL(dopickup);
 E void NDECL(lookaround);
 E int NDECL(monster_nearby);
+#ifdef HELPLESS
+E void FDECL(nomul, (int, const char *));
+#else
 E void FDECL(nomul, (int));
+#endif
 E void FDECL(unmul, (const char *));
 E void FDECL(losehp, (int,const char *,BOOLEAN_P));
 E int NDECL(weight_cap);
@@ -790,6 +813,9 @@ E void FDECL(prinv, (const char *,struct obj *,long));
 E char *FDECL(xprname, (struct obj *,const char *,CHAR_P,BOOLEAN_P,long,long));
 E int NDECL(ddoinv);
 E char FDECL(display_inventory, (const char *,BOOLEAN_P));
+#ifdef DUMP_LOG
+E char FDECL(dump_inventory, (const char *,BOOLEAN_P,BOOLEAN_P));
+#endif
 E int FDECL(display_binventory, (int,int,BOOLEAN_P));
 E struct obj *FDECL(display_cinventory,(struct obj *));
 E struct obj *FDECL(display_minventory,(struct monst *,int,char *));
@@ -1360,6 +1386,9 @@ E char *FDECL(doname, (struct obj *));
 E boolean FDECL(not_fully_identified, (struct obj *));
 E char *FDECL(corpse_xname, (struct obj *,BOOLEAN_P));
 E char *FDECL(cxname, (struct obj *));
+#ifdef SORTLOOT
+E char *FDECL(cxname2, (struct obj *));
+#endif
 E char *FDECL(killer_xname, (struct obj *));
 E const char *FDECL(singular, (struct obj *,char *(*)(OBJ_P)));
 E char *FDECL(an, (const char *));
@@ -1405,6 +1434,9 @@ E void FDECL(set_option_mod_status, (const char *,int));
 E int FDECL(add_autopickup_exception, (const char *));
 E void NDECL(free_autopickup_exceptions);
 #endif /* AUTOPICKUP_EXCEPTIONS */
+#ifdef MENU_COLOR
+E boolean FDECL(add_menu_coloring, (char *));
+#endif /* MENU_COLOR */
 
 /* ### pager.c ### */
 
@@ -1483,6 +1515,9 @@ E int FDECL(ck_bag, (struct obj *));
 E int FDECL(in_container, (struct obj *));
 E int FDECL(out_container, (struct obj *));
 #endif
+#ifdef ITEMCAT_JP
+E void FDECL(jpick_free, (struct obj *));
+#endif
 E int FDECL(pickup, (int));
 E int FDECL(pickup_object, (struct obj *, long, BOOLEAN_P));
 E int FDECL(query_category, (const char *, struct obj *, int,
@@ -2016,7 +2051,7 @@ E void NDECL(float_up);
 E void FDECL(fill_pit, (int,int));
 E int FDECL(float_down, (long, long));
 E int FDECL(fire_damage, (struct obj *,BOOLEAN_P,BOOLEAN_P,XCHAR_P,XCHAR_P));
-E void FDECL(water_damage, (struct obj *,BOOLEAN_P,BOOLEAN_P));
+E boolean FDECL(water_damage, (struct obj *,BOOLEAN_P,BOOLEAN_P));
 E boolean NDECL(drown);
 E void FDECL(drain_en, (int));
 E int NDECL(dountrap);
@@ -2237,6 +2272,9 @@ E int FDECL(mon_wield_item, (struct monst *));
 E int NDECL(abon);
 E int NDECL(dbon);
 E int NDECL(enhance_weapon_skill);
+#ifdef DUMP_LOG
+E void NDECL(dump_weapon_skill);
+#endif
 E void FDECL(unrestrict_weapon_skill, (int));
 E void FDECL(use_skill, (int,int));
 E void FDECL(add_weapon_skill, (int));
@@ -2367,7 +2405,7 @@ E const char *FDECL(exclam, (int force));
 E void FDECL(hit, (const char *,struct monst *,const char *));
 E void FDECL(miss, (const char *,struct monst *));
 E struct monst *FDECL(bhit, (int,int,int,int,int (*)(MONST_P,OBJ_P),
-			     int (*)(OBJ_P,OBJ_P),struct obj *));
+			     int (*)(OBJ_P,OBJ_P),struct obj *, boolean *));
 E struct monst *FDECL(boomhit, (int,int));
 E int FDECL(burn_floor_paper, (int,int,BOOLEAN_P,BOOLEAN_P));
 E void FDECL(buzz, (int,int,XCHAR_P,XCHAR_P,int,int));
diff --git a/include/flag.h b/include/flag.h
index 1807a0b..1700deb 100644
--- a/include/flag.h
+++ b/include/flag.h
@@ -155,6 +155,9 @@ struct flag {
  */
 
 struct instance_flags {
+#ifdef ITEMCAT
+        boolean  like_swimming; /* category r - Items known to be Rustprone */
+#endif /* ITEMCAT */
 	boolean  cbreak;	/* in cbreak mode, rogue format */
 	boolean  DECgraphics;	/* use DEC VT-xxx extended character set */
 	boolean  echo;		/* 1 to echo characters */
@@ -183,6 +186,12 @@ struct instance_flags {
 	char prevmsg_window;	/* type of old message window to use */
 	boolean  extmenu;	/* extended commands use menu interface */
 #endif
+#ifdef MENU_COLOR
+	boolean use_menu_color;	/* use color in menus; only if wc_color */
+#endif
+#ifdef WIN_EDGE
+	boolean  win_edge;	/* are the menus aligned left&top */
+#endif
 #ifdef MFLOPPY
 	boolean  checkspace;	/* check disk space before writing files */
 				/* (in iflags to allow restore after moving
@@ -216,6 +225,23 @@ struct instance_flags {
 	boolean lan_mail;	/* mail is initialized */
 	boolean lan_mail_fetched; /* mail is awaiting display */
 #endif
+#ifdef SHOW_BORN
+	boolean show_born;	/* show numbers of created monsters */
+#endif
+#ifdef SORTLOOT
+	char sortloot;          /* sort items to loot alphabetically */
+#endif
+#ifdef PARANOID
+	boolean  paranoid_hit;  /* Ask for 'yes' when hitting peacefuls */
+	boolean  paranoid_quit; /* Ask for 'yes' when quitting */
+	boolean  paranoid_remove; /* Always show menu for 'T' and 'R' */
+#endif
+#ifdef DEATH_EXPLORE
+	boolean death_expl;	/* prompt for explore mode at death */
+#endif
+#ifdef QUIVER_FIRED
+	boolean quiver_fired;	/* quiver with f command */
+#endif
 /*
  * Window capability support.
  */
diff --git a/include/hack.h b/include/hack.h
index b7b5835..e8f528a 100644
--- a/include/hack.h
+++ b/include/hack.h
@@ -169,6 +169,13 @@ NEARDATA extern coord bhitpos;	/* place where throw or zap hits or stops */
 #define BUC_UNCURSED 0x200
 #define BUC_UNKNOWN  0x400
 #define BUC_ALLBKNOWN (BUC_BLESSED|BUC_CURSED|BUC_UNCURSED)
+#ifdef ITEMCAT
+#define UNIDENTIFIED 0x800
+#define RUSTPRONE    0x1000
+#endif
+#ifdef ITEMCAT_JP
+#define JUSTPICKED   0x2000
+#endif
 #define ALL_TYPES_SELECTED -2
 
 /* Flags to control find_mid() */
diff --git a/include/obj.h b/include/obj.h
index 516fc35..537c88d 100644
--- a/include/obj.h
+++ b/include/obj.h
@@ -303,4 +303,17 @@ struct obj {
 #define CONTAINED_TOO	0x1
 #define BURIED_TOO	0x2
 
+#ifdef ITEMCAT
+#ifdef MAIL
+#define BKNOWN(otmp) (otmp->bknown || otmp->otyp == SCR_MAIL)
+#else
+#define BKNOWN(otmp) (otmp->bknown)
+#endif
+
+/* faster version of not_fully_identified() for item selection
+ * (invent.c/pickup.c) */
+#define NOT_FULLY_IDENTIFIED(otmp) (otmp->oclass != COIN_CLASS && !(otmp->known && otmp->dknown && BKNOWN(otmp) && objects[otmp->otyp].oc_name_known) || (otmp->oartifact && undiscovered_artifact(otmp->oartifact)) || (!otmp->rknown && ((otmp->oclass == ARMOR_CLASS || otmp->oclass == WEAPON_CLASS || is_weptool(otmp) || otmp->oclass == BALL_CLASS)) && (is_rustprone(otmp) || is_corrodeable(otmp) || is_flammable(otmp))))
+
+#endif /* ITEMCAT */
+
 #endif /* OBJ_H */
diff --git a/include/objclass.h b/include/objclass.h
index 0af21a4..c5f224d 100644
--- a/include/objclass.h
+++ b/include/objclass.h
@@ -70,6 +70,14 @@ struct objclass {
 /* primary damage: fire/rust/--- */
 /* is_flammable(otmp), is_rottable(otmp) in mkobj.c */
 #define is_rustprone(otmp)	(objects[otmp->otyp].oc_material == IRON)
+#ifdef ITEMCAT
+/* is rustprone, and rust matters (is displayed in inventory listing) */
+#define is_rustprone2(otmp)     (is_rustprone(otmp) && (otmp->oclass==WEAPON_CLASS || otmp->oclass==ARMOR_CLASS || otmp->oclass==TOOL_CLASS || otmp->oclass==WAND_CLASS || otmp->oclass==RING_CLASS || otmp->oclass==BALL_CLASS || otmp->oclass==CHAIN_CLASS))
+/* rustproneness should not be immediately visible */
+#define hide_rust(otmp)         ((otmp->otyp==GAUNTLETS_OF_POWER || otmp->otyp==KICKING_BOOTS) && !otmp->oeroded)
+/* object is known to be rustprone and is NOT known to be rustproof */
+#define is_known_rustprone(otmp)	(is_rustprone2(otmp) && !(otmp->rknown && otmp->oerodeproof) && (!hide_rust(otmp) || objects[otmp->otyp].oc_name_known))
+#endif /* ITEMCAT */
 
 /* secondary damage: rot/acid/acid */
 #define is_corrodeable(otmp)	(objects[otmp->otyp].oc_material == COPPER || objects[otmp->otyp].oc_material == IRON)
diff --git a/include/onames.h b/include/onames.h
new file mode 100644
index 0000000..7584a9f
--- /dev/null
+++ b/include/onames.h
@@ -0,0 +1,474 @@
+/*	SCCS Id: @(#)onames.h	3.4	2002/02/03 */
+
+/* This source file is generated by 'makedefs'.  Do not edit. */
+#ifndef ONAMES_H
+#define ONAMES_H
+
+#define	STRANGE_OBJECT	0
+#define	ARROW	1
+#define	ELVEN_ARROW	2
+#define	ORCISH_ARROW	3
+#define	SILVER_ARROW	4
+#define	YA	5
+#define	CROSSBOW_BOLT	6
+#define	DART	7
+#define	SHURIKEN	8
+#define	BOOMERANG	9
+#define	SPEAR	10
+#define	ELVEN_SPEAR	11
+#define	ORCISH_SPEAR	12
+#define	DWARVISH_SPEAR	13
+#define	SILVER_SPEAR	14
+#define	JAVELIN	15
+#define	TRIDENT	16
+#define	DAGGER	17
+#define	ELVEN_DAGGER	18
+#define	ORCISH_DAGGER	19
+#define	SILVER_DAGGER	20
+#define	ATHAME	21
+#define	SCALPEL	22
+#define	KNIFE	23
+#define	STILETTO	24
+#define	WORM_TOOTH	25
+#define	CRYSKNIFE	26
+#define	AXE	27
+#define	BATTLE_AXE	28
+#define	SHORT_SWORD	29
+#define	ELVEN_SHORT_SWORD	30
+#define	ORCISH_SHORT_SWORD	31
+#define	DWARVISH_SHORT_SWORD	32
+#define	SCIMITAR	33
+#define	SILVER_SABER	34
+#define	BROADSWORD	35
+#define	ELVEN_BROADSWORD	36
+#define	LONG_SWORD	37
+#define	TWO_HANDED_SWORD	38
+#define	KATANA	39
+#define	TSURUGI	40
+#define	RUNESWORD	41
+#define	PARTISAN	42
+#define	RANSEUR	43
+#define	SPETUM	44
+#define	GLAIVE	45
+#define	LANCE	46
+#define	HALBERD	47
+#define	BARDICHE	48
+#define	VOULGE	49
+#define	DWARVISH_MATTOCK	50
+#define	FAUCHARD	51
+#define	GUISARME	52
+#define	BILL_GUISARME	53
+#define	LUCERN_HAMMER	54
+#define	BEC_DE_CORBIN	55
+#define	MACE	56
+#define	MORNING_STAR	57
+#define	WAR_HAMMER	58
+#define	CLUB	59
+#define	RUBBER_HOSE	60
+#define	QUARTERSTAFF	61
+#define	AKLYS	62
+#define	FLAIL	63
+#define	BULLWHIP	64
+#define	BOW	65
+#define	ELVEN_BOW	66
+#define	ORCISH_BOW	67
+#define	YUMI	68
+#define	SLING	69
+#define	CROSSBOW	70
+#define	ELVEN_LEATHER_HELM	71
+#define	ORCISH_HELM	72
+#define	DWARVISH_IRON_HELM	73
+#define	FEDORA	74
+#define	CORNUTHAUM	75
+#define	DUNCE_CAP	76
+#define	DENTED_POT	77
+#define	HELMET	78
+#define	HELM_OF_BRILLIANCE	79
+#define	HELM_OF_OPPOSITE_ALIGNMENT	80
+#define	HELM_OF_TELEPATHY	81
+#define	GRAY_DRAGON_SCALE_MAIL	82
+#define	SILVER_DRAGON_SCALE_MAIL	83
+#define	RED_DRAGON_SCALE_MAIL	84
+#define	WHITE_DRAGON_SCALE_MAIL	85
+#define	ORANGE_DRAGON_SCALE_MAIL	86
+#define	BLACK_DRAGON_SCALE_MAIL	87
+#define	BLUE_DRAGON_SCALE_MAIL	88
+#define	GREEN_DRAGON_SCALE_MAIL	89
+#define	YELLOW_DRAGON_SCALE_MAIL	90
+#define	GRAY_DRAGON_SCALES	91
+#define	SILVER_DRAGON_SCALES	92
+#define	RED_DRAGON_SCALES	93
+#define	WHITE_DRAGON_SCALES	94
+#define	ORANGE_DRAGON_SCALES	95
+#define	BLACK_DRAGON_SCALES	96
+#define	BLUE_DRAGON_SCALES	97
+#define	GREEN_DRAGON_SCALES	98
+#define	YELLOW_DRAGON_SCALES	99
+#define	PLATE_MAIL	100
+#define	CRYSTAL_PLATE_MAIL	101
+#define	BRONZE_PLATE_MAIL	102
+#define	SPLINT_MAIL	103
+#define	BANDED_MAIL	104
+#define	DWARVISH_MITHRIL_COAT	105
+#define	ELVEN_MITHRIL_COAT	106
+#define	CHAIN_MAIL	107
+#define	ORCISH_CHAIN_MAIL	108
+#define	SCALE_MAIL	109
+#define	STUDDED_LEATHER_ARMOR	110
+#define	RING_MAIL	111
+#define	ORCISH_RING_MAIL	112
+#define	LEATHER_ARMOR	113
+#define	LEATHER_JACKET	114
+#define	HAWAIIAN_SHIRT	115
+#define	T_SHIRT	116
+#define	MUMMY_WRAPPING	117
+#define	ELVEN_CLOAK	118
+#define	ORCISH_CLOAK	119
+#define	DWARVISH_CLOAK	120
+#define	OILSKIN_CLOAK	121
+#define	ROBE	122
+#define	ALCHEMY_SMOCK	123
+#define	LEATHER_CLOAK	124
+#define	CLOAK_OF_PROTECTION	125
+#define	CLOAK_OF_INVISIBILITY	126
+#define	CLOAK_OF_MAGIC_RESISTANCE	127
+#define	CLOAK_OF_DISPLACEMENT	128
+#define	SMALL_SHIELD	129
+#define	ELVEN_SHIELD	130
+#define	URUK_HAI_SHIELD	131
+#define	ORCISH_SHIELD	132
+#define	LARGE_SHIELD	133
+#define	DWARVISH_ROUNDSHIELD	134
+#define	SHIELD_OF_REFLECTION	135
+#define	LEATHER_GLOVES	136
+#define	GAUNTLETS_OF_FUMBLING	137
+#define	GAUNTLETS_OF_POWER	138
+#define	GAUNTLETS_OF_DEXTERITY	139
+#define	LOW_BOOTS	140
+#define	IRON_SHOES	141
+#define	HIGH_BOOTS	142
+#define	SPEED_BOOTS	143
+#define	WATER_WALKING_BOOTS	144
+#define	JUMPING_BOOTS	145
+#define	ELVEN_BOOTS	146
+#define	KICKING_BOOTS	147
+#define	FUMBLE_BOOTS	148
+#define	LEVITATION_BOOTS	149
+#define	RIN_ADORNMENT	150
+#define	RIN_GAIN_STRENGTH	151
+#define	RIN_GAIN_CONSTITUTION	152
+#define	RIN_INCREASE_ACCURACY	153
+#define	RIN_INCREASE_DAMAGE	154
+#define	RIN_PROTECTION	155
+#define	RIN_REGENERATION	156
+#define	RIN_SEARCHING	157
+#define	RIN_STEALTH	158
+#define	RIN_SUSTAIN_ABILITY	159
+#define	RIN_LEVITATION	160
+#define	RIN_HUNGER	161
+#define	RIN_AGGRAVATE_MONSTER	162
+#define	RIN_CONFLICT	163
+#define	RIN_WARNING	164
+#define	RIN_POISON_RESISTANCE	165
+#define	RIN_FIRE_RESISTANCE	166
+#define	RIN_COLD_RESISTANCE	167
+#define	RIN_SHOCK_RESISTANCE	168
+#define	RIN_FREE_ACTION	169
+#define	RIN_SLOW_DIGESTION	170
+#define	RIN_TELEPORTATION	171
+#define	RIN_TELEPORT_CONTROL	172
+#define	RIN_POLYMORPH	173
+#define	RIN_POLYMORPH_CONTROL	174
+#define	RIN_INVISIBILITY	175
+#define	RIN_SEE_INVISIBLE	176
+#define	RIN_PROTECTION_FROM_SHAPE_CHAN	177
+#define	AMULET_OF_ESP	178
+#define	AMULET_OF_LIFE_SAVING	179
+#define	AMULET_OF_STRANGULATION	180
+#define	AMULET_OF_RESTFUL_SLEEP	181
+#define	AMULET_VERSUS_POISON	182
+#define	AMULET_OF_CHANGE	183
+#define	AMULET_OF_UNCHANGING	184
+#define	AMULET_OF_REFLECTION	185
+#define	AMULET_OF_MAGICAL_BREATHING	186
+#define	FAKE_AMULET_OF_YENDOR	187
+#define	AMULET_OF_YENDOR	188
+#define	LARGE_BOX	189
+#define	CHEST	190
+#define	ICE_BOX	191
+#define	SACK	192
+#define	OILSKIN_SACK	193
+#define	BAG_OF_HOLDING	194
+#define	BAG_OF_TRICKS	195
+#define	SKELETON_KEY	196
+#define	LOCK_PICK	197
+#define	CREDIT_CARD	198
+#define	TALLOW_CANDLE	199
+#define	WAX_CANDLE	200
+#define	BRASS_LANTERN	201
+#define	OIL_LAMP	202
+#define	MAGIC_LAMP	203
+#define	EXPENSIVE_CAMERA	204
+#define	MIRROR	205
+#define	CRYSTAL_BALL	206
+#define	LENSES	207
+#define	BLINDFOLD	208
+#define	TOWEL	209
+#define	SADDLE	210
+#define	LEASH	211
+#define	STETHOSCOPE	212
+#define	TINNING_KIT	213
+#define	TIN_OPENER	214
+#define	CAN_OF_GREASE	215
+#define	FIGURINE	216
+#define	MAGIC_MARKER	217
+#define	LAND_MINE	218
+#define	BEARTRAP	219
+#define	TIN_WHISTLE	220
+#define	MAGIC_WHISTLE	221
+#define	WOODEN_FLUTE	222
+#define	MAGIC_FLUTE	223
+#define	TOOLED_HORN	224
+#define	FROST_HORN	225
+#define	FIRE_HORN	226
+#define	HORN_OF_PLENTY	227
+#define	WOODEN_HARP	228
+#define	MAGIC_HARP	229
+#define	BELL	230
+#define	BUGLE	231
+#define	LEATHER_DRUM	232
+#define	DRUM_OF_EARTHQUAKE	233
+#define	PICK_AXE	234
+#define	GRAPPLING_HOOK	235
+#define	UNICORN_HORN	236
+#define	CANDELABRUM_OF_INVOCATION	237
+#define	BELL_OF_OPENING	238
+#define	TRIPE_RATION	239
+#define	CORPSE	240
+#define	EGG	241
+#define	MEATBALL	242
+#define	MEAT_STICK	243
+#define	HUGE_CHUNK_OF_MEAT	244
+#define	MEAT_RING	245
+#define	KELP_FROND	246
+#define	EUCALYPTUS_LEAF	247
+#define	APPLE	248
+#define	ORANGE	249
+#define	PEAR	250
+#define	MELON	251
+#define	BANANA	252
+#define	CARROT	253
+#define	SPRIG_OF_WOLFSBANE	254
+#define	CLOVE_OF_GARLIC	255
+#define	SLIME_MOLD	256
+#define	LUMP_OF_ROYAL_JELLY	257
+#define	CREAM_PIE	258
+#define	CANDY_BAR	259
+#define	FORTUNE_COOKIE	260
+#define	PANCAKE	261
+#define	LEMBAS_WAFER	262
+#define	CRAM_RATION	263
+#define	FOOD_RATION	264
+#define	K_RATION	265
+#define	C_RATION	266
+#define	TIN	267
+#define	POT_GAIN_ABILITY	268
+#define	POT_RESTORE_ABILITY	269
+#define	POT_CONFUSION	270
+#define	POT_BLINDNESS	271
+#define	POT_PARALYSIS	272
+#define	POT_SPEED	273
+#define	POT_LEVITATION	274
+#define	POT_HALLUCINATION	275
+#define	POT_INVISIBILITY	276
+#define	POT_SEE_INVISIBLE	277
+#define	POT_HEALING	278
+#define	POT_EXTRA_HEALING	279
+#define	POT_GAIN_LEVEL	280
+#define	POT_ENLIGHTENMENT	281
+#define	POT_MONSTER_DETECTION	282
+#define	POT_OBJECT_DETECTION	283
+#define	POT_GAIN_ENERGY	284
+#define	POT_SLEEPING	285
+#define	POT_FULL_HEALING	286
+#define	POT_POLYMORPH	287
+#define	POT_BOOZE	288
+#define	POT_SICKNESS	289
+#define	POT_FRUIT_JUICE	290
+#define	POT_ACID	291
+#define	POT_OIL	292
+#define	POT_WATER	293
+#define	SCR_ENCHANT_ARMOR	294
+#define	SCR_DESTROY_ARMOR	295
+#define	SCR_CONFUSE_MONSTER	296
+#define	SCR_SCARE_MONSTER	297
+#define	SCR_REMOVE_CURSE	298
+#define	SCR_ENCHANT_WEAPON	299
+#define	SCR_CREATE_MONSTER	300
+#define	SCR_TAMING	301
+#define	SCR_GENOCIDE	302
+#define	SCR_LIGHT	303
+#define	SCR_TELEPORTATION	304
+#define	SCR_GOLD_DETECTION	305
+#define	SCR_FOOD_DETECTION	306
+#define	SCR_IDENTIFY	307
+#define	SCR_MAGIC_MAPPING	308
+#define	SCR_AMNESIA	309
+#define	SCR_FIRE	310
+#define	SCR_EARTH	311
+#define	SCR_PUNISHMENT	312
+#define	SCR_CHARGING	313
+#define	SCR_STINKING_CLOUD	314
+#define	SCR_MAIL	319
+#define	SCR_BLANK_PAPER	320
+#define	SPE_DIG	321
+#define	SPE_MAGIC_MISSILE	322
+#define	SPE_FIREBALL	323
+#define	SPE_CONE_OF_COLD	324
+#define	SPE_SLEEP	325
+#define	SPE_FINGER_OF_DEATH	326
+#define	SPE_LIGHT	327
+#define	SPE_DETECT_MONSTERS	328
+#define	SPE_HEALING	329
+#define	SPE_KNOCK	330
+#define	SPE_FORCE_BOLT	331
+#define	SPE_CONFUSE_MONSTER	332
+#define	SPE_CURE_BLINDNESS	333
+#define	SPE_DRAIN_LIFE	334
+#define	SPE_SLOW_MONSTER	335
+#define	SPE_WIZARD_LOCK	336
+#define	SPE_CREATE_MONSTER	337
+#define	SPE_DETECT_FOOD	338
+#define	SPE_CAUSE_FEAR	339
+#define	SPE_CLAIRVOYANCE	340
+#define	SPE_CURE_SICKNESS	341
+#define	SPE_CHARM_MONSTER	342
+#define	SPE_HASTE_SELF	343
+#define	SPE_DETECT_UNSEEN	344
+#define	SPE_LEVITATION	345
+#define	SPE_EXTRA_HEALING	346
+#define	SPE_RESTORE_ABILITY	347
+#define	SPE_INVISIBILITY	348
+#define	SPE_DETECT_TREASURE	349
+#define	SPE_REMOVE_CURSE	350
+#define	SPE_MAGIC_MAPPING	351
+#define	SPE_IDENTIFY	352
+#define	SPE_TURN_UNDEAD	353
+#define	SPE_POLYMORPH	354
+#define	SPE_TELEPORT_AWAY	355
+#define	SPE_CREATE_FAMILIAR	356
+#define	SPE_CANCELLATION	357
+#define	SPE_PROTECTION	358
+#define	SPE_JUMPING	359
+#define	SPE_STONE_TO_FLESH	360
+#define	SPE_BLANK_PAPER	361
+#define	SPE_BOOK_OF_THE_DEAD	362
+#define	WAN_LIGHT	363
+#define	WAN_SECRET_DOOR_DETECTION	364
+#define	WAN_ENLIGHTENMENT	365
+#define	WAN_CREATE_MONSTER	366
+#define	WAN_WISHING	367
+#define	WAN_NOTHING	368
+#define	WAN_STRIKING	369
+#define	WAN_MAKE_INVISIBLE	370
+#define	WAN_SLOW_MONSTER	371
+#define	WAN_SPEED_MONSTER	372
+#define	WAN_UNDEAD_TURNING	373
+#define	WAN_POLYMORPH	374
+#define	WAN_CANCELLATION	375
+#define	WAN_TELEPORTATION	376
+#define	WAN_OPENING	377
+#define	WAN_LOCKING	378
+#define	WAN_PROBING	379
+#define	WAN_DIGGING	380
+#define	WAN_MAGIC_MISSILE	381
+#define	WAN_FIRE	382
+#define	WAN_COLD	383
+#define	WAN_SLEEP	384
+#define	WAN_DEATH	385
+#define	WAN_LIGHTNING	386
+#define	GOLD_PIECE	390
+#define	DILITHIUM_CRYSTAL	391
+#define	DIAMOND	392
+#define	RUBY	393
+#define	JACINTH	394
+#define	SAPPHIRE	395
+#define	BLACK_OPAL	396
+#define	EMERALD	397
+#define	TURQUOISE	398
+#define	CITRINE	399
+#define	AQUAMARINE	400
+#define	AMBER	401
+#define	TOPAZ	402
+#define	JET	403
+#define	OPAL	404
+#define	CHRYSOBERYL	405
+#define	GARNET	406
+#define	AMETHYST	407
+#define	JASPER	408
+#define	FLUORITE	409
+#define	OBSIDIAN	410
+#define	AGATE	411
+#define	JADE	412
+/* #define	WORTHLESS_PIECE_OF_WHITE_GLASS	413 */
+/* #define	WORTHLESS_PIECE_OF_BLUE_GLASS	414 */
+/* #define	WORTHLESS_PIECE_OF_RED_GLASS	415 */
+/* #define	WORTHLESS_PIECE_OF_YELLOWISH_BROWN_GLASS	416 */
+/* #define	WORTHLESS_PIECE_OF_ORANGE_GLASS	417 */
+/* #define	WORTHLESS_PIECE_OF_YELLOW_GLASS	418 */
+/* #define	WORTHLESS_PIECE_OF_BLACK_GLASS	419 */
+/* #define	WORTHLESS_PIECE_OF_GREEN_GLASS	420 */
+/* #define	WORTHLESS_PIECE_OF_VIOLET_GLASS	421 */
+#define	LUCKSTONE	422
+#define	LOADSTONE	423
+#define	TOUCHSTONE	424
+#define	FLINT	425
+#define	ROCK	426
+#define	BOULDER	427
+#define	STATUE	428
+#define	HEAVY_IRON_BALL	429
+#define	IRON_CHAIN	430
+#define	BLINDING_VENOM	431
+#define	ACID_VENOM	432
+#define	LAST_GEM	(JADE)
+#define	MAXSPELL	43
+#define	NUM_OBJECTS	433
+
+/* Artifacts (unique objects) */
+
+#define	ART_EXCALIBUR	1
+#define	ART_STORMBRINGER	2
+#define	ART_MJOLLNIR	3
+#define	ART_CLEAVER	4
+#define	ART_GRIMTOOTH	5
+#define	ART_ORCRIST	6
+#define	ART_STING	7
+#define	ART_MAGICBANE	8
+#define	ART_FROST_BRAND	9
+#define	ART_FIRE_BRAND	10
+#define	ART_DRAGONBANE	11
+#define	ART_DEMONBANE	12
+#define	ART_WEREBANE	13
+#define	ART_GRAYSWANDIR	14
+#define	ART_GIANTSLAYER	15
+#define	ART_OGRESMASHER	16
+#define	ART_TROLLSBANE	17
+#define	ART_VORPAL_BLADE	18
+#define	ART_SNICKERSNEE	19
+#define	ART_SUNSWORD	20
+#define	ART_ORB_OF_DETECTION	21
+#define	ART_HEART_OF_AHRIMAN	22
+#define	ART_SCEPTRE_OF_MIGHT	23
+#define	ART_STAFF_OF_AESCULAPIUS	24
+#define	ART_MAGIC_MIRROR_OF_MERLIN	25
+#define	ART_EYES_OF_THE_OVERWORLD	26
+#define	ART_MITRE_OF_HOLINESS	27
+#define	ART_LONGBOW_OF_DIANA	28
+#define	ART_MASTER_KEY_OF_THIEVERY	29
+#define	ART_TSURUGI_OF_MURAMASA	30
+#define	ART_YENDORIAN_EXPRESS_CARD	31
+#define	ART_ORB_OF_FATE	32
+#define	ART_EYE_OF_THE_AETHIOPICA	33
+#define	NROFARTIFACTS	33
+
+#endif /* ONAMES_H */
diff --git a/include/os2conf.h b/include/os2conf.h
index b706df1..e955c42 100644
--- a/include/os2conf.h
+++ b/include/os2conf.h
@@ -23,12 +23,15 @@
  */
 
 #define OS2_USESYSHEADERS	/* use compiler's own system headers */
-/* #define OS2_HPFS		/* use OS/2 High Performance File System */
+#define OS2_HPFS		/* use OS/2 High Performance File System */
 
 #if defined(OS2_GCC) || defined(OS2_CSET2)
 # define OS2_32BITAPI		/* enable for compilation in OS/2 2.0 */
 #endif
-
+/* These are needed to allow defining directory names in the config file */
+#define NOCWD_ASSUMPTIONS
+#define PC_LOCKING
+#define HLOCK "NHPERM"
 /*
  * Other configurable options.  Generally no
  * reason to touch the defaults, I think.
@@ -41,6 +44,10 @@
 #define ANSI_DEFAULT		/* allows NetHack to run without termcap file */
 #define TEXTCOLOR		/* allow color */
 
+#ifdef TIMED_DELAY
+# define msleep(k) _sleep2(k)
+#endif
+
 /*
  * The remaining code shouldn't need modification.
  */
diff --git a/include/pm.h b/include/pm.h
new file mode 100644
index 0000000..8cf7a0c
--- /dev/null
+++ b/include/pm.h
@@ -0,0 +1,393 @@
+/*	SCCS Id: @(#)pm.h	3.4	2002/02/03 */
+
+/* This source file is generated by 'makedefs'.  Do not edit. */
+#ifndef PM_H
+#define PM_H
+
+#define	PM_PLAYERMON	(-1)
+#define	PM_GIANT_ANT	0
+#define	PM_KILLER_BEE	1
+#define	PM_SOLDIER_ANT	2
+#define	PM_FIRE_ANT	3
+#define	PM_GIANT_BEETLE	4
+#define	PM_QUEEN_BEE	5
+#define	PM_ACID_BLOB	6
+#define	PM_QUIVERING_BLOB	7
+#define	PM_GELATINOUS_CUBE	8
+#define	PM_CHICKATRICE	9
+#define	PM_COCKATRICE	10
+#define	PM_PYROLISK	11
+#define	PM_JACKAL	12
+#define	PM_FOX	13
+#define	PM_COYOTE	14
+#define	PM_WEREJACKAL	15
+#define	PM_LITTLE_DOG	16
+#define	PM_DOG	17
+#define	PM_LARGE_DOG	18
+#define	PM_DINGO	19
+#define	PM_WOLF	20
+#define	PM_WEREWOLF	21
+#define	PM_WARG	22
+#define	PM_WINTER_WOLF_CUB	23
+#define	PM_WINTER_WOLF	24
+#define	PM_HELL_HOUND_PUP	25
+#define	PM_HELL_HOUND	26
+#define	PM_GAS_SPORE	27
+#define	PM_FLOATING_EYE	28
+#define	PM_FREEZING_SPHERE	29
+#define	PM_FLAMING_SPHERE	30
+#define	PM_SHOCKING_SPHERE	31
+#define	PM_KITTEN	32
+#define	PM_HOUSECAT	33
+#define	PM_JAGUAR	34
+#define	PM_LYNX	35
+#define	PM_PANTHER	36
+#define	PM_LARGE_CAT	37
+#define	PM_TIGER	38
+#define	PM_GREMLIN	39
+#define	PM_GARGOYLE	40
+#define	PM_WINGED_GARGOYLE	41
+#define	PM_HOBBIT	42
+#define	PM_DWARF	43
+#define	PM_BUGBEAR	44
+#define	PM_DWARF_LORD	45
+#define	PM_DWARF_KING	46
+#define	PM_MIND_FLAYER	47
+#define	PM_MASTER_MIND_FLAYER	48
+#define	PM_MANES	49
+#define	PM_HOMUNCULUS	50
+#define	PM_IMP	51
+#define	PM_LEMURE	52
+#define	PM_QUASIT	53
+#define	PM_TENGU	54
+#define	PM_BLUE_JELLY	55
+#define	PM_SPOTTED_JELLY	56
+#define	PM_OCHRE_JELLY	57
+#define	PM_KOBOLD	58
+#define	PM_LARGE_KOBOLD	59
+#define	PM_KOBOLD_LORD	60
+#define	PM_KOBOLD_SHAMAN	61
+#define	PM_LEPRECHAUN	62
+#define	PM_SMALL_MIMIC	63
+#define	PM_LARGE_MIMIC	64
+#define	PM_GIANT_MIMIC	65
+#define	PM_WOOD_NYMPH	66
+#define	PM_WATER_NYMPH	67
+#define	PM_MOUNTAIN_NYMPH	68
+#define	PM_GOBLIN	69
+#define	PM_HOBGOBLIN	70
+#define	PM_ORC	71
+#define	PM_HILL_ORC	72
+#define	PM_MORDOR_ORC	73
+#define	PM_URUK_HAI	74
+#define	PM_ORC_SHAMAN	75
+#define	PM_ORC_CAPTAIN	76
+#define	PM_ROCK_PIERCER	77
+#define	PM_IRON_PIERCER	78
+#define	PM_GLASS_PIERCER	79
+#define	PM_ROTHE	80
+#define	PM_MUMAK	81
+#define	PM_LEOCROTTA	82
+#define	PM_WUMPUS	83
+#define	PM_TITANOTHERE	84
+#define	PM_BALUCHITHERIUM	85
+#define	PM_MASTODON	86
+#define	PM_SEWER_RAT	87
+#define	PM_GIANT_RAT	88
+#define	PM_RABID_RAT	89
+#define	PM_WERERAT	90
+#define	PM_ROCK_MOLE	91
+#define	PM_WOODCHUCK	92
+#define	PM_CAVE_SPIDER	93
+#define	PM_CENTIPEDE	94
+#define	PM_GIANT_SPIDER	95
+#define	PM_SCORPION	96
+#define	PM_LURKER_ABOVE	97
+#define	PM_TRAPPER	98
+#define	PM_WHITE_UNICORN	99
+#define	PM_GRAY_UNICORN	100
+#define	PM_BLACK_UNICORN	101
+#define	PM_PONY	102
+#define	PM_HORSE	103
+#define	PM_WARHORSE	104
+#define	PM_FOG_CLOUD	105
+#define	PM_DUST_VORTEX	106
+#define	PM_ICE_VORTEX	107
+#define	PM_ENERGY_VORTEX	108
+#define	PM_STEAM_VORTEX	109
+#define	PM_FIRE_VORTEX	110
+#define	PM_BABY_LONG_WORM	111
+#define	PM_BABY_PURPLE_WORM	112
+#define	PM_LONG_WORM	113
+#define	PM_PURPLE_WORM	114
+#define	PM_GRID_BUG	115
+#define	PM_XAN	116
+#define	PM_YELLOW_LIGHT	117
+#define	PM_BLACK_LIGHT	118
+#define	PM_ZRUTY	119
+#define	PM_COUATL	120
+#define	PM_ALEAX	121
+#define	PM_ANGEL	122
+#define	PM_KI_RIN	123
+#define	PM_ARCHON	124
+#define	PM_BAT	125
+#define	PM_GIANT_BAT	126
+#define	PM_RAVEN	127
+#define	PM_VAMPIRE_BAT	128
+#define	PM_PLAINS_CENTAUR	129
+#define	PM_FOREST_CENTAUR	130
+#define	PM_MOUNTAIN_CENTAUR	131
+#define	PM_BABY_GRAY_DRAGON	132
+#define	PM_BABY_SILVER_DRAGON	133
+#define	PM_BABY_RED_DRAGON	134
+#define	PM_BABY_WHITE_DRAGON	135
+#define	PM_BABY_ORANGE_DRAGON	136
+#define	PM_BABY_BLACK_DRAGON	137
+#define	PM_BABY_BLUE_DRAGON	138
+#define	PM_BABY_GREEN_DRAGON	139
+#define	PM_BABY_YELLOW_DRAGON	140
+#define	PM_GRAY_DRAGON	141
+#define	PM_SILVER_DRAGON	142
+#define	PM_RED_DRAGON	143
+#define	PM_WHITE_DRAGON	144
+#define	PM_ORANGE_DRAGON	145
+#define	PM_BLACK_DRAGON	146
+#define	PM_BLUE_DRAGON	147
+#define	PM_GREEN_DRAGON	148
+#define	PM_YELLOW_DRAGON	149
+#define	PM_STALKER	150
+#define	PM_AIR_ELEMENTAL	151
+#define	PM_FIRE_ELEMENTAL	152
+#define	PM_EARTH_ELEMENTAL	153
+#define	PM_WATER_ELEMENTAL	154
+#define	PM_LICHEN	155
+#define	PM_BROWN_MOLD	156
+#define	PM_YELLOW_MOLD	157
+#define	PM_GREEN_MOLD	158
+#define	PM_RED_MOLD	159
+#define	PM_SHRIEKER	160
+#define	PM_VIOLET_FUNGUS	161
+#define	PM_GNOME	162
+#define	PM_GNOME_LORD	163
+#define	PM_GNOMISH_WIZARD	164
+#define	PM_GNOME_KING	165
+#define	PM_GIANT	166
+#define	PM_STONE_GIANT	167
+#define	PM_HILL_GIANT	168
+#define	PM_FIRE_GIANT	169
+#define	PM_FROST_GIANT	170
+#define	PM_STORM_GIANT	171
+#define	PM_ETTIN	172
+#define	PM_TITAN	173
+#define	PM_MINOTAUR	174
+#define	PM_JABBERWOCK	175
+#define	PM_KEYSTONE_KOP	176
+#define	PM_KOP_SERGEANT	177
+#define	PM_KOP_LIEUTENANT	178
+#define	PM_KOP_KAPTAIN	179
+#define	PM_LICH	180
+#define	PM_DEMILICH	181
+#define	PM_MASTER_LICH	182
+#define	PM_ARCH_LICH	183
+#define	PM_KOBOLD_MUMMY	184
+#define	PM_GNOME_MUMMY	185
+#define	PM_ORC_MUMMY	186
+#define	PM_DWARF_MUMMY	187
+#define	PM_ELF_MUMMY	188
+#define	PM_HUMAN_MUMMY	189
+#define	PM_ETTIN_MUMMY	190
+#define	PM_GIANT_MUMMY	191
+#define	PM_RED_NAGA_HATCHLING	192
+#define	PM_BLACK_NAGA_HATCHLING	193
+#define	PM_GOLDEN_NAGA_HATCHLING	194
+#define	PM_GUARDIAN_NAGA_HATCHLING	195
+#define	PM_RED_NAGA	196
+#define	PM_BLACK_NAGA	197
+#define	PM_GOLDEN_NAGA	198
+#define	PM_GUARDIAN_NAGA	199
+#define	PM_OGRE	200
+#define	PM_OGRE_LORD	201
+#define	PM_OGRE_KING	202
+#define	PM_GRAY_OOZE	203
+#define	PM_BROWN_PUDDING	204
+#define	PM_BLACK_PUDDING	205
+#define	PM_GREEN_SLIME	206
+#define	PM_QUANTUM_MECHANIC	207
+#define	PM_RUST_MONSTER	208
+#define	PM_DISENCHANTER	209
+#define	PM_GARTER_SNAKE	210
+#define	PM_SNAKE	211
+#define	PM_WATER_MOCCASIN	212
+#define	PM_PIT_VIPER	213
+#define	PM_PYTHON	214
+#define	PM_COBRA	215
+#define	PM_TROLL	216
+#define	PM_ICE_TROLL	217
+#define	PM_ROCK_TROLL	218
+#define	PM_WATER_TROLL	219
+#define	PM_OLOG_HAI	220
+#define	PM_UMBER_HULK	221
+#define	PM_VAMPIRE	222
+#define	PM_VAMPIRE_LORD	223
+#define	PM_VLAD_THE_IMPALER	224
+#define	PM_BARROW_WIGHT	225
+#define	PM_WRAITH	226
+#define	PM_NAZGUL	227
+#define	PM_XORN	228
+#define	PM_MONKEY	229
+#define	PM_APE	230
+#define	PM_OWLBEAR	231
+#define	PM_YETI	232
+#define	PM_CARNIVOROUS_APE	233
+#define	PM_SASQUATCH	234
+#define	PM_KOBOLD_ZOMBIE	235
+#define	PM_GNOME_ZOMBIE	236
+#define	PM_ORC_ZOMBIE	237
+#define	PM_DWARF_ZOMBIE	238
+#define	PM_ELF_ZOMBIE	239
+#define	PM_HUMAN_ZOMBIE	240
+#define	PM_ETTIN_ZOMBIE	241
+#define	PM_GIANT_ZOMBIE	242
+#define	PM_GHOUL	243
+#define	PM_SKELETON	244
+#define	PM_STRAW_GOLEM	245
+#define	PM_PAPER_GOLEM	246
+#define	PM_ROPE_GOLEM	247
+#define	PM_GOLD_GOLEM	248
+#define	PM_LEATHER_GOLEM	249
+#define	PM_WOOD_GOLEM	250
+#define	PM_FLESH_GOLEM	251
+#define	PM_CLAY_GOLEM	252
+#define	PM_STONE_GOLEM	253
+#define	PM_GLASS_GOLEM	254
+#define	PM_IRON_GOLEM	255
+#define	PM_HUMAN	256
+#define	PM_HUMAN_WERERAT	257
+#define	PM_HUMAN_WEREJACKAL	258
+#define	PM_HUMAN_WEREWOLF	259
+#define	PM_ELF	260
+#define	PM_WOODLAND_ELF	261
+#define	PM_GREEN_ELF	262
+#define	PM_GREY_ELF	263
+#define	PM_ELF_LORD	264
+#define	PM_ELVENKING	265
+#define	PM_DOPPELGANGER	266
+#define	PM_NURSE	267
+#define	PM_SHOPKEEPER	268
+#define	PM_GUARD	269
+#define	PM_PRISONER	270
+#define	PM_ORACLE	271
+#define	PM_ALIGNED_PRIEST	272
+#define	PM_HIGH_PRIEST	273
+#define	PM_SOLDIER	274
+#define	PM_SERGEANT	275
+#define	PM_LIEUTENANT	276
+#define	PM_CAPTAIN	277
+#define	PM_WATCHMAN	278
+#define	PM_WATCH_CAPTAIN	279
+#define	PM_MEDUSA	280
+#define	PM_WIZARD_OF_YENDOR	281
+#define	PM_CROESUS	282
+#define	PM_GHOST	283
+#define	PM_SHADE	284
+#define	PM_WATER_DEMON	285
+#define	PM_HORNED_DEVIL	286
+#define	PM_SUCCUBUS	287
+#define	PM_INCUBUS	288
+#define	PM_ERINYS	289
+#define	PM_BARBED_DEVIL	290
+#define	PM_MARILITH	291
+#define	PM_VROCK	292
+#define	PM_HEZROU	293
+#define	PM_BONE_DEVIL	294
+#define	PM_ICE_DEVIL	295
+#define	PM_NALFESHNEE	296
+#define	PM_PIT_FIEND	297
+#define	PM_BALROG	298
+#define	PM_JUIBLEX	299
+#define	PM_YEENOGHU	300
+#define	PM_ORCUS	301
+#define	PM_GERYON	302
+#define	PM_DISPATER	303
+#define	PM_BAALZEBUB	304
+#define	PM_ASMODEUS	305
+#define	PM_DEMOGORGON	306
+#define	PM_DEATH	307
+#define	PM_PESTILENCE	308
+#define	PM_FAMINE	309
+#define	PM_MAIL_DAEMON	310
+#define	PM_DJINNI	311
+#define	PM_SANDESTIN	312
+#define	PM_JELLYFISH	313
+#define	PM_PIRANHA	314
+#define	PM_SHARK	315
+#define	PM_GIANT_EEL	316
+#define	PM_ELECTRIC_EEL	317
+#define	PM_KRAKEN	318
+#define	PM_NEWT	319
+#define	PM_GECKO	320
+#define	PM_IGUANA	321
+#define	PM_BABY_CROCODILE	322
+#define	PM_LIZARD	323
+#define	PM_CHAMELEON	324
+#define	PM_CROCODILE	325
+#define	PM_SALAMANDER	326
+#define	PM_LONG_WORM_TAIL	327
+#define	PM_ARCHEOLOGIST	328
+#define	PM_BARBARIAN	329
+#define	PM_CAVEMAN	330
+#define	PM_CAVEWOMAN	331
+#define	PM_HEALER	332
+#define	PM_KNIGHT	333
+#define	PM_MONK	334
+#define	PM_PRIEST	335
+#define	PM_PRIESTESS	336
+#define	PM_RANGER	337
+#define	PM_ROGUE	338
+#define	PM_SAMURAI	339
+#define	PM_TOURIST	340
+#define	PM_VALKYRIE	341
+#define	PM_WIZARD	342
+#define	PM_LORD_CARNARVON	343
+#define	PM_PELIAS	344
+#define	PM_SHAMAN_KARNOV	345
+#define	PM_HIPPOCRATES	346
+#define	PM_KING_ARTHUR	347
+#define	PM_GRAND_MASTER	348
+#define	PM_ARCH_PRIEST	349
+#define	PM_ORION	350
+#define	PM_MASTER_OF_THIEVES	351
+#define	PM_LORD_SATO	352
+#define	PM_TWOFLOWER	353
+#define	PM_NORN	354
+#define	PM_NEFERET_THE_GREEN	355
+#define	PM_MINION_OF_HUHETOTL	356
+#define	PM_THOTH_AMON	357
+#define	PM_CHROMATIC_DRAGON	358
+#define	PM_CYCLOPS	359
+#define	PM_IXOTH	360
+#define	PM_MASTER_KAEN	361
+#define	PM_NALZOK	362
+#define	PM_SCORPIUS	363
+#define	PM_MASTER_ASSASSIN	364
+#define	PM_ASHIKAGA_TAKAUJI	365
+#define	PM_LORD_SURTUR	366
+#define	PM_DARK_ONE	367
+#define	PM_STUDENT	368
+#define	PM_CHIEFTAIN	369
+#define	PM_NEANDERTHAL	370
+#define	PM_ATTENDANT	371
+#define	PM_PAGE	372
+#define	PM_ABBOT	373
+#define	PM_ACOLYTE	374
+#define	PM_HUNTER	375
+#define	PM_THUG	376
+#define	PM_NINJA	377
+#define	PM_ROSHI	378
+#define	PM_GUIDE	379
+#define	PM_WARRIOR	380
+#define	PM_APPRENTICE	381
+
+#define	NUMMONS	382
+
+#endif /* PM_H */
diff --git a/include/unixconf.h b/include/unixconf.h
index fe1b006..4d0cf48 100644
--- a/include/unixconf.h
+++ b/include/unixconf.h
@@ -37,7 +37,7 @@
 #define NETWORK		/* if running on a networked system */
 			/* e.g. Suns sharing a playground through NFS */
 /* #define SUNOS4 */	/* SunOS 4.x */
-/* #define LINUX */	/* Another Unix clone */
+#define LINUX	/* Another Unix clone */
 /* #define CYGWIN32 */	/* Unix on Win32 -- use with case sensitive defines */
 /* #define GENIX */	/* Yet Another Unix Clone */
 /* #define HISX */	/* Bull Unix for XPS Machines */
@@ -132,7 +132,7 @@
  * "extra output" method is used, but not all systems provide access to
  * a fine-grained timer.
  */
-/* #define TIMED_DELAY */	/* usleep() */
+#define TIMED_DELAY	/* usleep() */
 #endif
 
 /*
diff --git a/include/vis_tab.h b/include/vis_tab.h
new file mode 100644
index 0000000..6312239
--- /dev/null
+++ b/include/vis_tab.h
@@ -0,0 +1,4 @@
+/* This source file is generated by 'makedefs'.  Do not edit. */
+#ifdef VISION_TABLES
+
+#endif /* VISION_TABLES */
diff --git a/nh343jl/README.nh343jl b/nh343jl/README.nh343jl
new file mode 100644
index 0000000..a7357ea
--- /dev/null
+++ b/nh343jl/README.nh343jl
@@ -0,0 +1,121 @@
+nh343jl.diff is a diff for Nethack 3.4.3, containing the following
+patches (better explanations and diffs for most individual patches
+available at http://www.netsonic.fi/~walker/nethack.html) :
+
+- Tom Friedetzky's "dump character" patch somewhat modified by me, Darshan
+  Shaligram and some others (include/decl.h, include/extern.h,
+        src/botl.c, src/cmd.c, src/decl.c, src/display.c, src/end.c,
+        src/invent.c, src/options.c, src/spell.c, src/topten.c, src/weapon.c,
+        win/tty/wintty.c, dat/opthelp, doc/Guidebook.*)
+- record the number of moves, and mark wizard/explore mode games in
+  logfile / record (src/topten.c)
+- show extincted monsters among the genocided ones and the numbers of 
+  different monsters born in the "vanquished" list after the numbers killed.
+  (Wingnut, Jukka Lahtinen) 
+        (include/flag.h, src/cmd.c, src/end.c, src/options.c, 
+        dat/opthelp, dat/wizhelp, doc/Guidebook.*)
+- paranoid, by David Damerell, Jonathan Nieder, Jukka Lahtinen and
+  Stanislav Traykov
+        (include/flag.h, src/cmd.c, src/do_wear.c, src/end.c, src/options.c,
+        src/potion.c, src/uhitm.c, dat/opthelp, doc/Guidebook.*)
+- Ralph Churchill's colored Hp monitor (src/botl.c)
+- Compile-time options for not writing #quit games to the record file
+  (FORGET_QUITTER) and not writing explore mode games to the logfile
+  (PROMPT_LOGEXP). (src/end.c, src/topten.c)
+- The compile time setting SCORE_ON_BOTL is overriden in the magic number
+  in the bones and save files, so compatibility with the official binaries
+  can be kept regardless of that option. (src/version.c)
+- Allow definitions for variable playground locations, such as separate
+  bones and levels directories, for OS/2. Use bones in directory "bones"
+  under the playground directory in unix systems.
+  (include/os2conf.h, src/files.c, sys/share/pcunix.c)
+- prompt for entering explore mode at death (include/flag.h, src/cmd.c,
+        src/end.c, src/options.c, dat/opthelp, doc/Guidebook.*)
+- Jeroen Demeyer's sortloot patch to optionally sort the pickup lists to
+  ascending order of descriptions within each item class
+  	(dat/opthelp, doc/Guidebook.*, include/extern.h, include/flag.h,
+	src/end.c, src/invent.c, src/objnam.c, src/options.c, src/pickup.c)
+- Pasi Kallinen's menucolor patch (http://www.cs.joensuu.fi/~pkalli)
+        (dat/opthelp, include/color.h, include/extern.h, include/flag.h,
+        src/decl.c, src/files.c, src/options.c, src/save.c,
+        win/tty/wintty.c)
+- Pasi Kallinen's window edge patch, optionally aligning menus and text
+  windows left instead of right in the tty interface.
+  http://cs.joensuu.fi/~pkalli/code/nh342-winedge.diff
+	(doc/Guidebook.*, dat/opthelp, include/flag.h, src/options.c, 
+	win/tty/wintty.c)
+- Stanislav Traykov's patch for additional item categories in the menus
+  http://home.in.tum.de/~traykovs/nethack/
+        (dat/opthelp, doc/Guidebook.*, include/extern.h, include/flag.h,
+        include/hack.h, include/objclass.h, include/obj.h, src/do.c,
+        src/invent.c, src/options.c, src/pickup.c)
+- Sam Dennis's patch to allow the #adjust command to split stacks
+        (src/invent.c)
+- Pasi Kallinen's helplessness patch that replaces the "while helpless"
+        text to be written to the record/logfile with the reason of
+        helplessness
+        (include/decl.h, include/extern.h, src/allmain.c, src/apply.c,
+        src/artifact.c, src/ball.c, src/decl.c, src/detect.c, src/dig.c,
+        src/dothrow.c, src/do_wear.c, src/eat.c, src/end.c, src/engrave.c,
+        src/explode.c, src/hack.c, src/mcastu.c, src/mhitu.c, src/mthrowu.c,
+        src/muse.c, src/pickup.c, src/polyself.c, src/potion.c, src/pray.c,
+        src/priest.c, src/save.c, src/sounds.c, src/spell.c, src/steal.c,
+        src/teleport.c, src/timeout.c, src/trap.c, src/uhitm.c, src/vault.c,
+        src/zap.c)
+- Pasi Kallinen's extra status attributes patch that adds statuses like 
+	encuberance, hunger, confusion, food poisoning, illness, blindness,
+	stun, hallucination and sliming to the minimal enlightenment screen
+	shown with ^X (http://bilious.homelinux.org/?226)
+	(include/extern.h, src/botl.c, src/cmd.c)
+- Make the f (fire) command prompt for ammuntition to quiver, when used
+	and nothing is quivered.
+	(dat/opthelp, doc/Guidebook.mn, doc/Guidebook.tex, doc/Guidebook.txt,
+	include.flag.h, src/dothrow.c, src/options.c)
+- Allow priest role to be played as any race (Haakon Studebaker)
+	(src/role.c, compile option PRIEST_RACES)
+- Patric Mueller's fixes for known bugs C343-100, C343-179, C343-218, 
+	C343-275, C343-276 and C343-324
+	(include/extern.h, src/apply.c, src/do.c, src/dokick.c, src/dothrow.c,
+	src/shk.c, src/trap.c, src/worm.c, src/zap.c)
+
+Most of these patches need some #define in include/config.h to get
+compiled in. I included a diff for config.h to show them.
+
+On unix systems with the dump patch, it is recommended for security reasons
+to define the DUMP_FN in include/config.h to prevent users from defining 
+the dumpfile name themselves, but here it is commented out because there is 
+no single directory name that would be good for EVERY patched Nethack 
+installation to have the dump files in and I try to keep this patch 
+collection as generic as possible.
+
+If you find any bugs in these patches, please let me know.
+For now, you can reach me at jtfjdehf@hotmail.com). 
+And I read rec.games.roguelike.nethack regularly.
+
+Of course, if you have some other changes made to the same files, you may
+need to edit some of the source files to insert some chunks of this diff
+manually. Check especially include/config.h for options that you may like
+to be set differently from my setup. 
+
+Some of the patches also need some options defined in your configuration file
+(~/.nethackrc in Linux and other unix-like systems, nethack.cnf in OS/2,
+defaults.nh on modern windows platforms, maybe something else on some 
+other platform) to take effect. To turn all of thse on, set
+
+OPTIONS=dumpfile:%n.nh (for the dump character patch in single user systems)
+OPTIONS=showborn        (to see the numbers of monsters born)
+OPTIONS=paranoid_hit,paranoid_quit,paranoid_remove   (for the paranoid patch)
+OPTIONS=death_explore   (to be prompted for explore mode when you die)
+OPTIONS=sortloot:loot   (for the sortloot patch)
+OPTIONS=win_edge	(for the window edge patch)
+OPTIONS=quiver_fired	(for the quiver fired ammunition patch)
+OPTIONS=menucolors      (to turn on the menucolor option)
+MENUCOLOR="* blessed *"=green    (some menucolor definition examples)
+MENUCOLOR="* holy *"=green       (if you have MENU_COLOR_REGEX defined
+MENUCOLOR="* cursed *"=red        in config.h, leave the asterisks out from
+MENUCOLOR="* unholy *"=red        the beginning and ending of the options)
+MENUCOLOR="* cursed .* (being worn)*"=orange&underline
+
+--
+Jukka Lahtinen, 3.1.2009
+jtfjdehf@hotmail.com
diff --git a/src/Makefile b/src/Makefile
new file mode 100644
index 0000000..bd77fab
--- /dev/null
+++ b/src/Makefile
@@ -0,0 +1,814 @@
+#	NetHack Makefile.
+#	SCCS Id: @(#)Makefile.src	3.4	2002/03/02
+
+# newer makes predefine $(MAKE) to 'make' and do smarter processing of
+# recursive make calls if $(MAKE) is used
+# these makes allow $(MAKE) to be overridden by the environment if someone
+# wants to (or has to) use something other than the standard make, so we do
+# not want to unconditionally set $(MAKE) here
+#
+# unfortunately, some older makes do not predefine $(MAKE); if you have one of
+# these, uncomment the following line
+# (you will know that you have one if you get complaints about being unable
+# to find 'makedefs')
+# MAKE = make
+
+# This makefile replaces the previous Makefile.unix, Makefile.xenix,
+# Makefile.3B2, Makefile.att, and Makefile.tos.
+# Set SYSTEM to one of:
+#	'Sysunix'	-- generic UNIX
+#	'Sys3B2'	-- AT&T 3B2, 3B5, etc.
+#	'Sysatt'	-- AT&T UNIXPC, 7300, 3B1
+#	'SysV-AT'	-- Microport 286 UNIX (put -DDUMB in CFLAGS)
+#	'Systos'	-- Atari
+#	'SysBe'		-- BeOS
+SYSTEM = Sysunix
+
+#
+# Make sure that your bourne shell is specified here, as you have to spawn
+# some of the commands (eg. depend) in bourne shell for them to work.
+#
+# For Systos users compiling on the ST, you'll either need a bourne shell
+# clone or you'll need to do make depend, etc. by hand. In either case,
+# the line below probably needs changing
+SHELL=/bin/sh
+# for Atari
+# SHELL=E:/GEMINI2/MUPFEL.TTP
+
+# Normally, the C compiler driver is used for linking:
+LINK=$(CC)
+
+# Pick the SYSSRC and SYSOBJ lines corresponding to your desired operating
+# system.
+#
+# for UNIX systems
+SYSSRC = ../sys/share/ioctl.c ../sys/share/unixtty.c ../sys/unix/unixmain.c \
+	../sys/unix/unixunix.c ../sys/unix/unixres.c
+SYSOBJ = ioctl.o unixmain.o unixtty.o unixunix.o unixres.o
+#
+# for Systos
+# SYSSRC = ../sys/atari/tos.c ../sys/share/pcmain.c ../sys/share/pcsys.c \
+#	../sys/share/pctty.c ../sys/share/pcunix.c
+# SYSOBJ = tos.o pcmain.o pcsys.o pctty.o pcunix.o
+#
+# for BeOS
+#SYSSRC = ../sys/be/bemain.c ../sys/share/unixtty.c ../sys/share/ioctl.c
+#SYSOBJ = bemain.o unixtty.o ioctl.o
+
+
+# if you are using gcc as your compiler:
+#	uncomment the CC definition below if it's not in your environment
+#	if you get setcgtty() warnings during execution, you are feeding gcc
+#		a non-ANSI <sys/ioctl.h> -- either run fixincludes on it or use
+#		-traditional in CFLAGS
+# CC = gcc
+#
+#	For Bull DPX/2 systems at B.O.S. 2.0 or higher use the following:
+#
+# CC = gcc -ansi -D_BULL_SOURCE -D_XOPEN_SOURCE -D_POSIX_SOURCE
+#
+#	If you are using GCC 2.2.2 or higher on a DPX/2, just use:
+#
+# CC = gcc -ansi
+#
+#	For HP/UX 10.20 with GCC:
+# CC = gcc -D_POSIX_SOURCE
+#
+#	For cross-compiling, eg. with gcc on Linux (see also CXX further down):
+# CC = arm-linux-gcc
+#
+#
+# if you're debugging and want gcc to check as much as possible, use:
+# CC = gcc -W -Wimplicit -Wreturn-type -Wunused -Wformat -Wswitch -Wshadow -Wcast-qual -Wwrite-strings -DGCC_WARN
+
+# flags may have to be changed as required
+# flags for 286 Xenix:
+# CFLAGS = -Ml2t16 -O -LARGE -I../include
+# LFLAGS = -Ml -F 4000 -SEG 512
+
+# flags for 286 Microport SysV-AT
+# CFLAGS = -DDUMB -Ml -I../include
+# LFLAGS = -Ml
+
+# flags for Atari gcc (3.2.1)
+# CFLAGS = -O -I../include
+# LFLAGS = -s
+# flags for Atari gcc (3.3)
+# CFLAGS = -mshort -O2 -fomit-frame-pointer -I../include
+# LFLAGS = -mshort -s
+
+# flags for AIX 3.1 cc on IBM RS/6000 to define
+# a suitable subset of standard libraries
+# (note that there is more info regarding the "-qchars=signed"
+# switch in file Install.unx note 8)
+# CFLAGS = -D_NO_PROTO -D_XOPEN_SOURCE -O -I../include -qchars=signed
+#
+# Some of our subroutines are complex enough that this is required for full
+# optimization under AIX 3.2 (I don't know about 3.1).
+#
+# CFLAGS = -D_NO_PROTO -D_XOPEN_SOURCE -D_ALL_SOURCE -O -I../include -qchars=signed -qmaxmem=5000
+
+# flags for A/UX 2.01 using native cc or c89
+# gcc predefines AUX so that's not needed there
+# Remember to use -lcurses for WINLIB below !
+# CFLAGS = -ZS -D_POSIX_SOURCE -O -I../include -DAUX
+
+# flags for IRIX 4.0.x using native cc
+# The include files are __STDC__, but have bugs involving const
+# CFLAGS = -O -I../include -D__STDC__ -Dconst= -woff 100,293
+# LFLAGS = -s
+
+# flags for BSD/OS 2.0
+# CFLAGS = -O -I../include -I/usr/X11/include
+# LFLAGS = -L/usr/X11/lib
+
+# flags for Linux
+#   compile normally
+# CFLAGS = -O2 -fomit-frame-pointer -I../include
+# LFLAGS = -L/usr/X11R6/lib
+#   OR compile backwards compatible a.out format
+# CFLAGS = -O2 -b i486-linuxaout -fomit-frame-pointer -I../include
+# LFLAGS = -b i486-linuxaout -L/usr/X11R6/lib
+
+# flags for BeOS
+#   on a Mac/BeBox:
+#CC = mwcc
+#CFLAGS = -r -I../include
+#LINK = mwld
+#LFLAGS = -map nethack.xMAP
+#   on Intel:
+#CFLAGS = -O -I../include
+#LINK = gcc
+#LFLAGS = -Xlinker -soname=_APP_
+
+# Only used for the Gnome interface.
+# When including the Gnome interface, you need to include gnome specific
+# directories.  The ones given below is the usual spot for linux systems.
+# The paths are for glibconfig.h and gnomesupport.h respectively.
+#
+GNOMEINC=-I/usr/lib/glib/include -I/usr/lib/gnome-libs/include -I../win/gnome
+
+# flags for debugging:
+# CFLAGS = -g -I../include
+
+CFLAGS = -O -I../include
+LFLAGS = 
+
+# The Qt and Be window systems are written in C++, while the rest of
+# NetHack is standard C.  If using Qt, uncomment the LINK line here to get
+# the C++ libraries linked in.
+CXXFLAGS = $(CFLAGS) -I. -I$(QTDIR)/include
+CXX=g++
+#LINK=g++
+#	For cross-compiling, eg. with gcc on Linux (see also CC further up):
+#CXX=arm-linux-g++
+#LINK=arm-linux-gcc
+
+# Set the WINSRC, WINOBJ, and WINLIB lines to correspond to your desired
+# combination of windowing systems.  Also set windowing systems in config.h.
+# Note that if you are including multiple tiled window systems, you don't
+# want two copies of tile.o, so comment out all but the first.
+#
+# files for a straight tty port using no native windowing system
+WINTTYSRC = ../win/tty/getline.c ../win/tty/termcap.c ../win/tty/topl.c \
+	../win/tty/wintty.c
+WINTTYOBJ = getline.o termcap.o topl.o wintty.o
+#
+# files for an X11 port
+# (tile.c is a generated source file)
+WINX11SRC = ../win/X11/Window.c ../win/X11/dialogs.c ../win/X11/winX.c \
+	../win/X11/winmap.c  ../win/X11/winmenu.c ../win/X11/winmesg.c \
+	../win/X11/winmisc.c ../win/X11/winstat.c ../win/X11/wintext.c \
+	../win/X11/winval.c tile.c
+WINX11OBJ = Window.o dialogs.o winX.o winmap.o winmenu.o winmesg.o \
+	winmisc.o winstat.o wintext.o winval.o tile.o
+#
+# Files for a Qt port
+#
+WINQTSRC = ../win/Qt/qt_win.cpp ../win/Qt/qt_clust.cpp ../win/Qt/qttableview.cpp
+WINQTOBJ = qt_win.o qt_clust.o qttableview.o tile.o
+#
+# Files for a Gnome port
+#
+WINGNOMESRC = ../win/gnome/gnaskstr.c ../win/gnome/gnbind.c \
+	../win/gnome/gnglyph.c ../win/gnome/gnmain.c ../win/gnome/gnmap.c \
+	../win/gnome/gnmenu.c ../win/gnome/gnmesg.c ../win/gnome/gnopts.c \
+	../win/gnome/gnplayer.c ../win/gnome/gnsignal.c \
+	../win/gnome/gnstatus.c ../win/gnome/gntext.c ../win/gnome/gnyesno.c \
+	../win/gnome/gnworn.c
+WINGNOMEOBJ = gnaskstr.o gnbind.o gnglyph.o gnmain.o gnmap.o gnmenu.o \
+	gnmesg.o gnopts.o gnplayer.o gnsignal.o gnstatus.o gntext.o \
+	gnyesno.o gnworn.o tile.o
+#
+# Files for a Gem port
+WINGEMSRC = ../win/gem/wingem.c ../win/gem/wingem1.c ../win/gem/load_img.c \
+	../win/gem/gr_rect.c tile.c
+WINGEMOBJ = wingem.o wingem1.o load_img.o gr_rect.o tile.o
+#
+# Files for a BeOS InterfaceKit port -- not ready for prime time
+WINBESRC =
+WINBEOBJ =
+#WINBESRC = ../win/BeOS/winbe.cpp ../win/BeOS/NHWindow.cpp \
+#	../win/BeOS/NHMenuWindow.cpp ../win/BeOS/NHMapWindow.cpp tile.c
+#WINBEOBJ = winbe.o NHWindow.o NHMenuWindow.o NHMapWindow.o tile.o
+
+#
+#
+WINSRC = $(WINTTYSRC)
+WINOBJ = $(WINTTYOBJ)
+
+# on some systems the termcap library is in -ltermcap or -lcurses
+# on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
+# Sysatt uses shared library in lieu of this option
+# Systos needs -lcurses16 if you use -mshort
+# AIX 3.1 on RS/6000 likes -lcurses if TERMINFO defined in unixconf.h
+# and -ltermcap otherwise
+# Linux uses -lncurses (newer) or -ltermcap (older)
+# Be uses -ltermcap
+#
+# libraries for tty ports
+# WINTTYLIB = -ltermcap
+# WINTTYLIB = -lcurses
+# WINTTYLIB = -lcurses16
+WINTTYLIB = -lncurses
+# WINTTYLIB = -ltermlib
+#
+# libraries for X11
+# If USE_XPM is defined in config.h, you will also need -lXpm here.
+WINX11LIB = -lXaw -lXmu -lXext -lXt -lX11
+# WINX11LIB = -lXaw -lXmu -lXt -lX11
+# WINX11LIB = -lXaw -lXmu -lXext -lXt -lXpm -lX11 -lm
+# WINX11LIB = -lXaw -lXmu -lXpm -lXext -lXt -lX11 -lSM -lICE -lm # BSD/OS 2.0
+#
+# libraries for Qt
+WINQTLIB = -L$(QTDIR)/lib -lqt
+#
+# libraries for KDE (with Qt)
+WINKDELIB = -lkdecore -lkdeui -lXext
+#
+# libraries for Gnome
+WINGNOMELIB = -lgnomeui -lgnome -lart_lgpl -lgtk -lgdk -lpopt
+#
+# libraries for Gem port
+WINGEMLIB = -le_gem -lgem
+#
+# libraries for BeOS 
+WINBELIB = -lbe
+
+WINLIB = $(WINTTYLIB)
+
+# any other strange libraries your system needs (for Sysunix only -- the more
+# specialized targets should already be right)
+#
+# on HP-UX 8.x, the malloc(3x) routines in libmalloc.a seem to align things
+# better than the malloc(3) ones in libc.a
+# LIBS = -lmalloc
+#
+# DPX/2's also use the malloc(3x) routines.  In addition, if you are building
+# for X11, you must include libinet.a.
+# LIBS = -lmalloc -linet
+#
+# Linux NetHack uses some bsd style ioctl functions, thus it is necessary to
+# use the bsd libs.  (Only if still compiling as BSD in unixconf.h; recent
+# versions compile fine using SYSV without this.)
+# LIBS = -lbsd
+#
+# for CYGWIN32 aka cygwin 1.1.1
+# LIBS = -lcygwin
+#
+# Solaris 2.x seems to work with the following
+# LIBS = -lsocket -lnsl
+#
+# IRIX 4.0.x needs -lsun if NIS (YP) is being used for passwd file lookup
+# LIBS = -lsun
+#
+LIBS =
+
+# make NetHack
+GAME     = nethack
+# GAME     = nethack.prg
+
+# if you defined RANDOM in unixconf.h/tosconf.h since your system did not come
+# with a reasonable random number generator
+# RANDOBJ = random.o
+RANDOBJ =
+
+
+# used by `make depend' to reconstruct this Makefile; you shouldn't need this
+AWK	= nawk
+
+# ----------------------------------------
+#
+# Nothing below this line should have to be changed.
+#
+# Other things that have to be reconfigured are in config.h,
+# {unixconf.h, pcconf.h, tosconf.h}, and possibly system.h
+
+MAKEDEFS = ../util/makedefs
+
+# timestamp files to reduce `make' overhead and shorten .o dependency lists
+CONFIG_H = ../src/config.h-t
+HACK_H	= ../src/hack.h-t
+
+# all .c that are part of the main NetHack program and are not operating- or
+# windowing-system specific
+HACKCSRC = allmain.c alloc.c apply.c artifact.c attrib.c ball.c bones.c \
+	   botl.c cmd.c dbridge.c decl.c detect.c dig.c display.c dlb.c do.c \
+	   do_name.c do_wear.c dog.c dogmove.c dokick.c dothrow.c drawing.c \
+	   dungeon.c eat.c end.c engrave.c exper.c explode.c extralev.c \
+	   files.c fountain.c hack.c hacklib.c invent.c light.c lock.c \
+	   mail.c makemon.c mapglyph.c mcastu.c mhitm.c mhitu.c minion.c \
+	   mklev.c mkmap.c \
+	   mkmaze.c mkobj.c mkroom.c mon.c mondata.c monmove.c monst.c \
+	   mplayer.c mthrowu.c muse.c music.c o_init.c objects.c objnam.c \
+	   options.c pager.c pickup.c pline.c polyself.c potion.c pray.c \
+	   priest.c quest.c questpgr.c read.c rect.c region.c restore.c rip.c \
+	   rnd.c role.c rumors.c save.c shk.c shknam.c sit.c sounds.c sp_lev.c \
+	   spell.c steal.c steed.c teleport.c timeout.c topten.c track.c trap.c \
+	   u_init.c uhitm.c vault.c version.c vision.c weapon.c were.c wield.c \
+	   windows.c wizard.c worm.c worn.c write.c zap.c
+
+# all operating-system-dependent .c (for dependencies and such)
+SYSCSRC = ../sys/atari/tos.c ../sys/share/pcmain.c ../sys/share/pcsys.c \
+	../sys/share/pctty.c ../sys/share/pcunix.c ../sys/share/random.c \
+	../sys/share/ioctl.c ../sys/share/unixtty.c ../sys/unix/unixmain.c \
+	../sys/unix/unixunix.c ../sys/unix/unixres.c ../sys/be/bemain.c
+
+# generated source files (tile.c is handled separately via WINxxxSRC)
+GENCSRC = monstr.c vis_tab.c	#tile.c
+
+# all windowing-system-dependent .c (for dependencies and such)
+WINCSRC = $(WINTTYSRC) $(WINX11SRC) $(WINGNOMESRC) $(WINGEMSRC)
+# all windowing-system-dependent .cpp (for dependencies and such)
+WINCXXSRC = $(WINQTSRC) $(WINBESRC)
+
+# .c files for this version (for date.h)
+VERSOURCES = $(HACKCSRC) $(SYSSRC) $(WINSRC) $(GENCSRC)
+
+# .c files for all versions using this Makefile (for lint and tags)
+CSOURCES = $(HACKCSRC) $(SYSSRC) $(WINCSRC) $(GENCSRC)
+
+
+# all .h files except date.h, onames.h, pm.h, and vis_tab.h which would
+# cause dependency loops if run through "make depend"
+# and dgn_comp.h, dgn_file.h, lev_comp.h, special level & dungeon files.
+#
+HACKINCL = align.h amiconf.h artifact.h artilist.h attrib.h beconf.h color.h \
+	config.h config1.h coord.h decl.h def_os2.h display.h dlb.h dungeon.h \
+	edog.h emin.h engrave.h epri.h eshk.h extern.h flag.h func_tab.h \
+	global.h hack.h lev.h macconf.h mfndpos.h micro.h mkroom.h \
+	monattk.h mondata.h monflag.h monst.h monsym.h obj.h objclass.h \
+	os2conf.h patchlevel.h pcconf.h permonst.h prop.h rect.h region.h rm.h \
+	sp_lev.h spell.h system.h tcap.h timeout.h tosconf.h tradstdc.h \
+	trampoli.h trap.h unixconf.h vault.h vision.h vmsconf.h wintty.h \
+	winX.h winprocs.h wintype.h you.h youprop.h
+
+HSOURCES = $(HACKINCL) date.h onames.h pm.h vis_tab.h\
+		lev_comp.h dgn_comp.h dgn_file.h
+
+# the following .o's _must_ be made before any others (for makedefs)
+FIRSTOBJ = monst.o objects.o
+
+HOBJ = $(FIRSTOBJ) allmain.o alloc.o apply.o artifact.o attrib.o ball.o \
+	bones.o botl.o cmd.o dbridge.o decl.o detect.o dig.o display.o dlb.o \
+	do.o do_name.o do_wear.o dog.o dogmove.o dokick.o dothrow.o \
+	drawing.o dungeon.o eat.o end.o engrave.o exper.o explode.o \
+	extralev.o files.o fountain.o hack.o hacklib.o invent.o light.o \
+	lock.o mail.o makemon.o mapglyph.o mcastu.o mhitm.o mhitu.o \
+	minion.o mklev.o mkmap.o \
+	mkmaze.o mkobj.o mkroom.o mon.o mondata.o monmove.o monstr.o \
+	mplayer.o mthrowu.o muse.o music.o o_init.o objnam.o options.o \
+	pager.o pickup.o pline.o polyself.o potion.o pray.o priest.o \
+	quest.o questpgr.o read.o rect.o region.o restore.o rip.o rnd.o \
+	role.o rumors.o save.o shk.o shknam.o sit.o sounds.o sp_lev.o spell.o \
+	steal.o steed.o teleport.o timeout.o topten.o track.o trap.o u_init.o \
+	uhitm.o vault.o vision.o vis_tab.o weapon.o were.o wield.o windows.o \
+	wizard.o worm.o worn.o write.o zap.o \
+	$(RANDOBJ) $(SYSOBJ) $(WINOBJ) version.o
+# the .o files from the HACKCSRC, SYSSRC, and WINSRC lists
+
+$(GAME):	$(SYSTEM)
+	@echo "$(GAME) is up to date."
+
+Sysunix:	$(HOBJ) Makefile
+	@echo "Loading ..."
+	$(LINK) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB) $(LIBS)
+	@touch Sysunix
+
+Sys3B2:	$(HOBJ) Makefile
+	@echo "Loading ..."
+	@$(LINK) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB) -lmalloc
+	@touch Sys3B2
+
+Sysatt:	$(HOBJ) Makefile
+	@echo "Loading ..."
+	@$(LD) $(LFLAGS) /lib/crt0s.o /lib/shlib.ifile -o $(GAME) $(HOBJ)
+	@touch Sysatt
+
+Systos:	$(HOBJ) Makefile
+	@echo "Loading ..."
+	@$(LINK) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB)
+	@touch Systos
+
+SysV-AT:	DUMB.Setup $(HOBJ) Makefile
+	@echo "Loading ..."
+	@$(LINK) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB)
+	@touch SysV-AT
+
+SysBe: $(HOBJ) Makefile
+	@echo "Loading ..."
+	@$(LINK) $(LFLAGS) -o $(GAME) $(HOBJ) $(WINLIB) $(LIBS)
+	@xres -o $(GAME) ../win/BeOS/nethack.rsrc
+	@mimeset -f $(GAME)
+	@touch SysBe
+
+DUMB.Setup:	../include/extern.h
+	cp ../include/extern.h ../include/extern.h.BAK
+	cat ../include/extern.h | \
+		sed -e '/^E\ int\ /!b' \
+			-e '/[^;/ 	]$$/N' \
+			-e '/[(][*]occupation[)]/b' \
+			-e '/[(][*]afternmv[)]/b' \
+			-e '/float_down/b' \
+			-e '/done1/b' \
+			-e '/identify/b' \
+			-e '/Hear_again/b' \
+			-e '/hangup/b' \
+			-e 's/^\(.*\)$$/\/\* \1 \/\*\*\//' | \
+		sed -e '/^E\ void\ /!b' \
+			-e '/[^;/ 	]$$/N' \
+			-e 's/^\(.*\)$$/\/\* \1 \/\*\*\//' \
+				>../include/extern.DUMB
+	cp ../include/extern.DUMB ../include/extern.h
+	@touch DUMB.Setup
+
+all:	$(GAME)
+
+
+#	dependencies for makedefs and its outputs, which the util
+#	Makefile is responsible for keeping up to date
+#
+
+# special rules, to force update of makedefs, real dependencies should be
+# below in the 'make depend' output.
+monst.o:
+	$(CC) $(CFLAGS) -c monst.c
+	@rm -f $(MAKEDEFS)
+
+objects.o:
+	$(CC) $(CFLAGS) -c objects.c
+	@rm -f $(MAKEDEFS)
+
+# Qt windowport meta-object-compiler output
+qt_kde0.moc: ../include/qt_kde0.h
+	$(QTDIR)/bin/moc -o qt_kde0.moc ../include/qt_kde0.h
+
+qt_win.moc: ../include/qt_win.h
+	$(QTDIR)/bin/moc -o qt_win.moc ../include/qt_win.h
+
+qttableview.moc: ../include/qttableview.h
+	$(QTDIR)/bin/moc -o qttableview.moc ../include/qttableview.h
+
+$(MAKEDEFS): ../util/makedefs.c  $(CONFIG_H) ../include/permonst.h \
+		../include/objclass.h ../include/monsym.h \
+		../include/artilist.h ../include/dungeon.h ../include/obj.h \
+		../include/monst.h ../include/you.h ../include/flag.h \
+		../include/dlb.h ../include/patchlevel.h ../include/qtext.h
+	@( cd ../util ; $(MAKE) makedefs)
+
+../include/onames.h: $(MAKEDEFS)
+	@( cd ../util ; $(MAKE) ../include/onames.h )
+../include/pm.h: $(MAKEDEFS)
+	@( cd ../util ; $(MAKE) ../include/pm.h )
+monstr.c: $(MAKEDEFS)
+	@( cd ../util ; $(MAKE) ../src/monstr.c )
+../include/vis_tab.h: $(MAKEDEFS)
+	@( cd ../util ; $(MAKE) ../include/vis_tab.h )
+# makedefs -z makes both vis_tab.h and vis_tab.c, but writes the .h first
+vis_tab.c: ../include/vis_tab.h
+tile.c: ../win/share/tilemap.c $(HACK_H)
+	@( cd ../util ; $(MAKE) ../src/tile.c )
+
+../win/gnome/gn_rip.h: ../win/X11/rip.xpm
+	cp ../win/X11/rip.xpm ../win/gnome/gn_rip.h
+
+#	date.h should be remade any time any of the source or include code
+#	is modified.  Unfortunately, this would make the contents of this
+#	file far more complex.  Since "hack.h" depends on most of the include
+#	files, we kludge around this by making date.h dependent on hack.h,
+#	even though it doesn't include this file.
+#
+#	hack.h depends on makedefs' output, so we know makedefs will be
+#	up to date before being executed
+../include/date.h:	$(VERSOURCES) $(HACK_H)
+	../util/makedefs -v
+
+
+lint:
+# lint cannot have -p here because (i) capitals are meaningful:
+# [Ww]izard, (ii) identifiers may coincide in the first six places:
+# doweararm() versus dowearring().
+# _flsbuf comes from <stdio.h>, a bug in the system libraries.
+	@echo lint -axbh -DLINT ...
+	@lint -axbh -I../include -DLINT $(CSOURCES) | sed '/_flsbuf/d'
+
+
+tags: $(CSOURCES)
+	@echo ctags -tw ...
+	@ctags -tw $(CSOURCES)
+	@( cd ../include ; ctags -tw $(HSOURCES) )
+	@( cd ../util ; $(MAKE) tags )
+
+clean:
+	-rm -f *.o $(HACK_H) $(CONFIG_H)
+
+spotless: clean
+	-rm -f a.out core $(GAME) Sys*
+	-rm -f ../include/date.h ../include/onames.h ../include/pm.h
+	-rm -f monstr.c ../include/vis_tab.h vis_tab.c tile.c *.moc
+	-rm -f ../win/gnome/gn_rip.h
+
+
+depend: ../sys/unix/depend.awk \
+		$(SYSCSRC) $(WINCSRC) $(WINCXXSRC) $(GENCSRC) $(HACKCSRC)
+	$(AWK) -f ../sys/unix/depend.awk ../include/*.h \
+		$(SYSCSRC) $(WINCSRC) $(WINCXXSRC) $(GENCSRC) $(HACKCSRC) >makedep
+	@echo '/^# DO NOT DELETE THIS LINE OR CHANGE ANYTHING BEYOND IT/+2,$$d' >eddep
+	@echo '$$r makedep' >>eddep
+	@echo 'w' >>eddep
+	@cp Makefile Makefile.bak
+	ed - Makefile < eddep
+	@rm -f eddep makedep
+	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile
+	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile
+	@echo '# see make depend above' >> Makefile
+	- diff Makefile.bak Makefile
+	@rm -f Makefile.bak
+
+# DO NOT DELETE THIS LINE OR CHANGE ANYTHING BEYOND IT
+
+# config.h timestamp
+$(CONFIG_H): ../include/config.h ../include/config1.h ../include/tradstdc.h \
+		../include/global.h ../include/coord.h ../include/vmsconf.h \
+		../include/system.h ../include/unixconf.h ../include/os2conf.h \
+		../include/micro.h ../include/pcconf.h ../include/tosconf.h \
+		../include/amiconf.h ../include/macconf.h ../include/beconf.h \
+		../include/wceconf.h ../include/ntconf.h ../include/nhlan.h
+	touch $(CONFIG_H)
+# hack.h timestamp
+$(HACK_H): ../include/hack.h $(CONFIG_H) ../include/align.h \
+		../include/dungeon.h ../include/monsym.h ../include/mkroom.h \
+		../include/objclass.h ../include/youprop.h ../include/prop.h \
+		../include/permonst.h ../include/monattk.h \
+		../include/monflag.h ../include/mondata.h ../include/pm.h \
+		../include/wintype.h ../include/decl.h ../include/quest.h \
+		../include/spell.h ../include/color.h ../include/obj.h \
+		../include/you.h ../include/attrib.h ../include/monst.h \
+		../include/skills.h ../include/onames.h ../include/timeout.h \
+		../include/trap.h ../include/flag.h ../include/rm.h \
+		../include/vision.h ../include/display.h ../include/engrave.h \
+		../include/rect.h ../include/region.h ../include/winprocs.h \
+		../include/wintty.h ../include/trampoli.h
+	touch $(HACK_H)
+#
+tos.o: ../sys/atari/tos.c $(HACK_H) ../include/tcap.h
+	$(CC) $(CFLAGS) -c ../sys/atari/tos.c
+pcmain.o: ../sys/share/pcmain.c $(HACK_H) ../include/dlb.h \
+		#../include/win32api.h
+	$(CC) $(CFLAGS) -c ../sys/share/pcmain.c
+pcsys.o: ../sys/share/pcsys.c $(HACK_H)
+	$(CC) $(CFLAGS) -c ../sys/share/pcsys.c
+pctty.o: ../sys/share/pctty.c $(HACK_H)
+	$(CC) $(CFLAGS) -c ../sys/share/pctty.c
+pcunix.o: ../sys/share/pcunix.c $(HACK_H)
+	$(CC) $(CFLAGS) -c ../sys/share/pcunix.c
+random.o: ../sys/share/random.c $(HACK_H)
+	$(CC) $(CFLAGS) -c ../sys/share/random.c
+ioctl.o: ../sys/share/ioctl.c $(HACK_H) ../include/tcap.h
+	$(CC) $(CFLAGS) -c ../sys/share/ioctl.c
+unixtty.o: ../sys/share/unixtty.c $(HACK_H)
+	$(CC) $(CFLAGS) -c ../sys/share/unixtty.c
+unixmain.o: ../sys/unix/unixmain.c $(HACK_H) ../include/dlb.h
+	$(CC) $(CFLAGS) -c ../sys/unix/unixmain.c
+unixunix.o: ../sys/unix/unixunix.c $(HACK_H)
+	$(CC) $(CFLAGS) -c ../sys/unix/unixunix.c
+unixres.o: ../sys/unix/unixres.c $(CONFIG_H)
+	$(CC) $(CFLAGS) -c ../sys/unix/unixres.c
+bemain.o: ../sys/be/bemain.c $(HACK_H) ../include/dlb.h
+	$(CC) $(CFLAGS) -c ../sys/be/bemain.c
+getline.o: ../win/tty/getline.c $(HACK_H) ../include/func_tab.h
+	$(CC) $(CFLAGS) -c ../win/tty/getline.c
+termcap.o: ../win/tty/termcap.c $(HACK_H) ../include/tcap.h
+	$(CC) $(CFLAGS) -c ../win/tty/termcap.c
+topl.o: ../win/tty/topl.c $(HACK_H) ../include/tcap.h
+	$(CC) $(CFLAGS) -c ../win/tty/topl.c
+wintty.o: ../win/tty/wintty.c $(HACK_H) ../include/dlb.h \
+		../include/patchlevel.h ../include/tcap.h
+	$(CC) $(CFLAGS) -c ../win/tty/wintty.c
+Window.o: ../win/X11/Window.c ../include/xwindowp.h ../include/xwindow.h \
+		$(CONFIG_H)
+	$(CC) $(CFLAGS) -c ../win/X11/Window.c
+dialogs.o: ../win/X11/dialogs.c $(CONFIG_H)
+	$(CC) $(CFLAGS) -c ../win/X11/dialogs.c
+winX.o: ../win/X11/winX.c $(HACK_H) ../include/winX.h ../include/dlb.h \
+		../include/patchlevel.h ../win/X11/nh72icon \
+		../win/X11/nh56icon ../win/X11/nh32icon
+	$(CC) $(CFLAGS) -c ../win/X11/winX.c
+winmap.o: ../win/X11/winmap.c ../include/xwindow.h $(HACK_H) ../include/dlb.h \
+		../include/winX.h ../include/tile2x11.h
+	$(CC) $(CFLAGS) -c ../win/X11/winmap.c
+winmenu.o: ../win/X11/winmenu.c $(HACK_H) ../include/winX.h
+	$(CC) $(CFLAGS) -c ../win/X11/winmenu.c
+winmesg.o: ../win/X11/winmesg.c ../include/xwindow.h $(HACK_H) ../include/winX.h
+	$(CC) $(CFLAGS) -c ../win/X11/winmesg.c
+winmisc.o: ../win/X11/winmisc.c $(HACK_H) ../include/func_tab.h \
+		../include/winX.h
+	$(CC) $(CFLAGS) -c ../win/X11/winmisc.c
+winstat.o: ../win/X11/winstat.c $(HACK_H) ../include/winX.h
+	$(CC) $(CFLAGS) -c ../win/X11/winstat.c
+wintext.o: ../win/X11/wintext.c $(HACK_H) ../include/winX.h ../include/xwindow.h
+	$(CC) $(CFLAGS) -c ../win/X11/wintext.c
+winval.o: ../win/X11/winval.c $(HACK_H) ../include/winX.h
+	$(CC) $(CFLAGS) -c ../win/X11/winval.c
+tile.o: tile.c $(HACK_H)
+gnaskstr.o: ../win/gnome/gnaskstr.c ../win/gnome/gnaskstr.h \
+		../win/gnome/gnmain.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnaskstr.c
+gnbind.o: ../win/gnome/gnbind.c ../win/gnome/gnbind.h ../win/gnome/gnmain.h \
+		../win/gnome/gnmenu.h ../win/gnome/gnaskstr.h \
+		../win/gnome/gnyesno.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnbind.c
+gnglyph.o: ../win/gnome/gnglyph.c ../win/gnome/gnglyph.h ../include/tile2x11.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnglyph.c
+gnmain.o: ../win/gnome/gnmain.c ../win/gnome/gnmain.h ../win/gnome/gnsignal.h \
+		../win/gnome/gnbind.h ../win/gnome/gnopts.h $(HACK_H) \
+		../include/date.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnmain.c
+gnmap.o: ../win/gnome/gnmap.c ../win/gnome/gnmap.h ../win/gnome/gnglyph.h \
+		../win/gnome/gnsignal.h $(HACK_H)
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnmap.c
+gnmenu.o: ../win/gnome/gnmenu.c ../win/gnome/gnmenu.h ../win/gnome/gnmain.h \
+		../win/gnome/gnbind.h ../include/func_tab.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnmenu.c
+gnmesg.o: ../win/gnome/gnmesg.c ../win/gnome/gnmesg.h ../win/gnome/gnsignal.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnmesg.c
+gnopts.o: ../win/gnome/gnopts.c ../win/gnome/gnopts.h ../win/gnome/gnglyph.h \
+		../win/gnome/gnmain.h ../win/gnome/gnmap.h $(HACK_H)
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnopts.c
+gnplayer.o: ../win/gnome/gnplayer.c ../win/gnome/gnplayer.h \
+		../win/gnome/gnmain.h $(HACK_H)
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnplayer.c
+gnsignal.o: ../win/gnome/gnsignal.c ../win/gnome/gnsignal.h \
+		../win/gnome/gnmain.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnsignal.c
+gnstatus.o: ../win/gnome/gnstatus.c ../win/gnome/gnstatus.h \
+		../win/gnome/gnsignal.h ../win/gnome/gn_xpms.h \
+		../win/gnome/gnomeprv.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnstatus.c
+gntext.o: ../win/gnome/gntext.c ../win/gnome/gntext.h ../win/gnome/gnmain.h \
+		../win/gnome/gn_rip.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gntext.c
+gnyesno.o: ../win/gnome/gnyesno.c ../win/gnome/gnbind.h ../win/gnome/gnyesno.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnyesno.c
+gnworn.o: ../win/gnome/gnworn.c ../win/gnome/gnworn.h ../win/gnome/gnglyph.h \
+		../win/gnome/gnsignal.h ../win/gnome/gnomeprv.h
+	$(CC) $(CFLAGS) $(GNOMEINC) -c ../win/gnome/gnworn.c
+wingem.o: ../win/gem/wingem.c $(HACK_H) ../include/func_tab.h ../include/dlb.h \
+		../include/patchlevel.h ../include/wingem.h
+	$(CC) $(CFLAGS) -c ../win/gem/wingem.c
+wingem1.o: ../win/gem/wingem1.c ../include/gem_rsc.h ../include/load_img.h \
+		../include/gr_rect.h ../include/wintype.h ../include/wingem.h
+	$(CC) $(CFLAGS) -c ../win/gem/wingem1.c
+load_img.o: ../win/gem/load_img.c ../include/load_img.h
+	$(CC) $(CFLAGS) -c ../win/gem/load_img.c
+gr_rect.o: ../win/gem/gr_rect.c ../include/gr_rect.h
+	$(CC) $(CFLAGS) -c ../win/gem/gr_rect.c
+tile.o: tile.c $(HACK_H)
+qt_win.o: ../win/Qt/qt_win.cpp $(HACK_H) ../include/func_tab.h \
+		../include/dlb.h ../include/patchlevel.h ../include/tile2x11.h \
+		../include/qt_win.h ../include/qt_clust.h ../include/qt_kde0.h \
+		../include/qt_xpms.h qt_win.moc qt_kde0.moc qttableview.moc
+	$(CXX) $(CXXFLAGS) -c ../win/Qt/qt_win.cpp
+qt_clust.o: ../win/Qt/qt_clust.cpp ../include/qt_clust.h
+	$(CXX) $(CXXFLAGS) -c ../win/Qt/qt_clust.cpp
+qttableview.o: ../win/Qt/qttableview.cpp ../include/qttableview.h
+	$(CXX) $(CXXFLAGS) -c ../win/Qt/qttableview.cpp
+monstr.o: monstr.c $(CONFIG_H)
+vis_tab.o: vis_tab.c $(CONFIG_H) ../include/vis_tab.h
+allmain.o: allmain.c $(HACK_H)
+alloc.o: alloc.c $(CONFIG_H)
+apply.o: apply.c $(HACK_H) ../include/edog.h
+artifact.o: artifact.c $(HACK_H) ../include/artifact.h ../include/artilist.h
+attrib.o: attrib.c $(HACK_H)
+ball.o: ball.c $(HACK_H)
+bones.o: bones.c $(HACK_H) ../include/lev.h
+botl.o: botl.c $(HACK_H)
+cmd.o: cmd.c $(HACK_H) ../include/func_tab.h
+dbridge.o: dbridge.c $(HACK_H)
+decl.o: decl.c $(HACK_H)
+detect.o: detect.c $(HACK_H) ../include/artifact.h
+dig.o: dig.c $(HACK_H) ../include/edog.h
+display.o: display.c $(HACK_H)
+dlb.o: dlb.c $(CONFIG_H) ../include/dlb.h
+do.o: do.c $(HACK_H) ../include/lev.h
+do_name.o: do_name.c $(HACK_H)
+do_wear.o: do_wear.c $(HACK_H)
+dog.o: dog.c $(HACK_H) ../include/edog.h
+dogmove.o: dogmove.c $(HACK_H) ../include/mfndpos.h ../include/edog.h
+dokick.o: dokick.c $(HACK_H) ../include/eshk.h
+dothrow.o: dothrow.c $(HACK_H) ../include/edog.h
+drawing.o: drawing.c $(HACK_H) ../include/tcap.h
+dungeon.o: dungeon.c $(HACK_H) ../include/dgn_file.h ../include/dlb.h
+eat.o: eat.c $(HACK_H)
+end.o: end.c $(HACK_H) ../include/eshk.h ../include/dlb.h
+engrave.o: engrave.c $(HACK_H) ../include/lev.h
+exper.o: exper.c $(HACK_H)
+explode.o: explode.c $(HACK_H)
+extralev.o: extralev.c $(HACK_H)
+files.o: files.c $(HACK_H) ../include/dlb.h
+fountain.o: fountain.c $(HACK_H)
+hack.o: hack.c $(HACK_H)
+hacklib.o: hacklib.c $(HACK_H)
+invent.o: invent.c $(HACK_H)
+light.o: light.c $(HACK_H) ../include/lev.h
+lock.o: lock.c $(HACK_H)
+mail.o: mail.c $(HACK_H) ../include/mail.h
+makemon.o: makemon.c $(HACK_H) ../include/epri.h ../include/emin.h \
+		../include/edog.h
+mapglyph.o: mapglyph.c $(HACK_H)
+mcastu.o: mcastu.c $(HACK_H)
+mhitm.o: mhitm.c $(HACK_H) ../include/artifact.h ../include/edog.h
+mhitu.o: mhitu.c $(HACK_H) ../include/artifact.h ../include/edog.h
+minion.o: minion.c $(HACK_H) ../include/emin.h ../include/epri.h
+mklev.o: mklev.c $(HACK_H)
+mkmap.o: mkmap.c $(HACK_H) ../include/sp_lev.h
+mkmaze.o: mkmaze.c $(HACK_H) ../include/sp_lev.h ../include/lev.h
+mkobj.o: mkobj.c $(HACK_H)
+mkroom.o: mkroom.c $(HACK_H)
+mon.o: mon.c $(HACK_H) ../include/mfndpos.h ../include/edog.h
+mondata.o: mondata.c $(HACK_H) ../include/eshk.h ../include/epri.h
+monmove.o: monmove.c $(HACK_H) ../include/mfndpos.h ../include/artifact.h \
+		../include/epri.h
+monst.o: monst.c $(CONFIG_H) ../include/permonst.h ../include/align.h \
+		../include/monattk.h ../include/monflag.h ../include/monsym.h \
+		../include/dungeon.h ../include/eshk.h ../include/vault.h \
+		../include/epri.h ../include/color.h
+mplayer.o: mplayer.c $(HACK_H)
+mthrowu.o: mthrowu.c $(HACK_H)
+muse.o: muse.c $(HACK_H) ../include/edog.h
+music.o: music.c $(HACK_H) #interp.c
+o_init.o: o_init.c $(HACK_H) ../include/lev.h
+objects.o: objects.c $(CONFIG_H) ../include/obj.h ../include/objclass.h \
+		../include/prop.h ../include/skills.h ../include/color.h
+objnam.o: objnam.c $(HACK_H)
+options.o: options.c $(CONFIG_H) ../include/objclass.h ../include/flag.h \
+		$(HACK_H) ../include/tcap.h
+pager.o: pager.c $(HACK_H) ../include/dlb.h
+pickup.o: pickup.c $(HACK_H)
+pline.o: pline.c $(HACK_H) ../include/epri.h ../include/edog.h
+polyself.o: polyself.c $(HACK_H)
+potion.o: potion.c $(HACK_H)
+pray.o: pray.c $(HACK_H) ../include/epri.h
+priest.o: priest.c $(HACK_H) ../include/mfndpos.h ../include/eshk.h \
+		../include/epri.h ../include/emin.h
+quest.o: quest.c $(HACK_H) ../include/qtext.h
+questpgr.o: questpgr.c $(HACK_H) ../include/dlb.h ../include/qtext.h
+read.o: read.c $(HACK_H)
+rect.o: rect.c $(HACK_H)
+region.o: region.c $(HACK_H) ../include/lev.h
+restore.o: restore.c $(HACK_H) ../include/lev.h ../include/tcap.h
+rip.o: rip.c $(HACK_H)
+rnd.o: rnd.c $(HACK_H)
+role.o: role.c $(HACK_H)
+rumors.o: rumors.c $(HACK_H) ../include/lev.h ../include/dlb.h
+save.o: save.c $(HACK_H) ../include/lev.h
+shk.o: shk.c $(HACK_H) ../include/eshk.h
+shknam.o: shknam.c $(HACK_H) ../include/eshk.h
+sit.o: sit.c $(HACK_H) ../include/artifact.h
+sounds.o: sounds.c $(HACK_H) ../include/edog.h
+sp_lev.o: sp_lev.c $(HACK_H) ../include/dlb.h ../include/sp_lev.h
+spell.o: spell.c $(HACK_H)
+steal.o: steal.c $(HACK_H)
+steed.o: steed.c $(HACK_H)
+teleport.o: teleport.c $(HACK_H)
+timeout.o: timeout.c $(HACK_H) ../include/lev.h
+topten.o: topten.c $(HACK_H) ../include/dlb.h ../include/patchlevel.h
+track.o: track.c $(HACK_H)
+trap.o: trap.c $(HACK_H)
+u_init.o: u_init.c $(HACK_H)
+uhitm.o: uhitm.c $(HACK_H)
+vault.o: vault.c $(HACK_H) ../include/vault.h
+version.o: version.c $(HACK_H) ../include/date.h ../include/patchlevel.h
+vision.o: vision.c $(HACK_H) ../include/vis_tab.h
+weapon.o: weapon.c $(HACK_H)
+were.o: were.c $(HACK_H)
+wield.o: wield.c $(HACK_H)
+windows.o: windows.c $(HACK_H) ../include/wingem.h ../include/winGnome.h
+wizard.o: wizard.c $(HACK_H) ../include/qtext.h ../include/epri.h
+worm.o: worm.c $(HACK_H) ../include/lev.h
+worn.o: worn.c $(HACK_H)
+write.o: write.c $(HACK_H)
+zap.o: zap.c $(HACK_H)
+# DEPENDENCIES MUST END AT END OF FILE
+# IF YOU PUT STUFF HERE IT WILL GO AWAY
+# see make depend above
diff --git a/src/Sysunix b/src/Sysunix
new file mode 100644
index 0000000..e69de29
diff --git a/src/allmain.c b/src/allmain.c
index d624a2f..a66c446 100644
--- a/src/allmain.c
+++ b/src/allmain.c
@@ -245,7 +245,11 @@ moveloop()
 				if (occupation)
 				    stop_occupation();
 				else
-				    nomul(0);
+				    nomul(0
+#ifdef HELPLESS
+					  , 0
+#endif
+					  );
 				if (change == 1) polyself(FALSE);
 				else you_were();
 				change = 0;
@@ -438,7 +442,11 @@ stop_occupation()
 		sync_hunger();
 */
 #ifdef REDO
-		nomul(0);
+		nomul(0
+#ifdef HELPLESS
+		      , 0
+#endif
+		      );
 		pushch(0);
 #endif
 	}
diff --git a/src/apply.c b/src/apply.c
index f45e196..864c6b1 100644
--- a/src/apply.c
+++ b/src/apply.c
@@ -80,7 +80,7 @@ use_camera(obj)
 	} else if ((mtmp = bhit(u.dx, u.dy, COLNO, FLASHED_LIGHT,
 				(int FDECL((*),(MONST_P,OBJ_P)))0,
 				(int FDECL((*),(OBJ_P,OBJ_P)))0,
-				obj)) != 0) {
+				obj, NULL)) != 0) {
 		obj->ox = u.ux,  obj->oy = u.uy;
 		(void) flash_hits_mon(mtmp, obj);
 	}
@@ -624,7 +624,11 @@ struct obj *obj;
 			pline(Hallucination ?
 			      "Yow!  The mirror stares back!" :
 			      "Yikes!  You've frozen yourself!");
-			nomul(-rnd((MAXULEV+6) - u.ulevel));
+			nomul(-rnd((MAXULEV+6) - u.ulevel)
+#ifdef HELPLESS
+			      , "gazing into a mirror"
+#endif
+			      );
 			} else You("stiffen momentarily under your gaze.");
 		    } else if (youmonst.data->mlet == S_VAMPIRE)
 			You("don't have a reflection.");
@@ -670,7 +674,7 @@ struct obj *obj;
 	mtmp = bhit(u.dx, u.dy, COLNO, INVIS_BEAM,
 		    (int FDECL((*),(MONST_P,OBJ_P)))0,
 		    (int FDECL((*),(OBJ_P,OBJ_P)))0,
-		    obj);
+		    obj, NULL);
 	if (!mtmp || !haseyes(mtmp->data))
 		return 1;
 
@@ -788,7 +792,11 @@ struct obj **optr;
 				break;
 			case 2: /* no explanation; it just happens... */
 				nomovemsg = "";
-				nomul(-rnd(2));
+				nomul(-rnd(2)
+#ifdef HELPLESS
+				      , 0
+#endif
+				      );
 				break;
 		}
 	    }
@@ -1358,7 +1366,11 @@ int magic; /* 0=Physical, otherwise skill level */
 		change_luck(-1);
 
 	    teleds(cc.x, cc.y, TRUE);
-	    nomul(-1);
+	    nomul(-1
+#ifdef HELPLESS
+		  , "jumping around"
+#endif
+		  );
 	    nomovemsg = "";
 	    morehungry(rnd(25));
 	    return 1;
@@ -2750,7 +2762,11 @@ do_break_wand(obj)
     current_wand = 0;
     if (obj)
 	delobj(obj);
-    nomul(0);
+    nomul(0
+#ifdef HELPLESS
+	  , 0
+#endif
+	  );
     return 1;
 }
 
@@ -3012,11 +3028,19 @@ doapply()
 		}
 		pline("Sorry, I don't know how to use that.");
 	xit:
-		nomul(0);
+		nomul(0
+#ifdef HELPLESS
+		      , 0
+#endif
+		      );
 		return 0;
 	}
 	if (res && obj && obj->oartifact) arti_speak(obj);
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	return res;
 }
 
diff --git a/src/artifact.c b/src/artifact.c
index ef27bd5..a955795 100644
--- a/src/artifact.c
+++ b/src/artifact.c
@@ -856,7 +856,11 @@ char *hittee;			/* target's name: "you" or mon_nam(mdef) */
 	    if (Antimagic) {
 		resisted = TRUE;
 	    } else {
-		nomul(-3);
+		nomul(-3
+#ifdef HELPLESS
+		      , "being scared stiff"
+#endif
+		      );
 		nomovemsg = "";
 		if (magr && magr == u.ustuck && sticks(youmonst.data)) {
 		    u.ustuck = (struct monst *)0;
diff --git a/src/ball.c b/src/ball.c
index b2a05e0..8dd9596 100644
--- a/src/ball.c
+++ b/src/ball.c
@@ -557,7 +557,11 @@ drag:
 	if (near_capacity() > SLT_ENCUMBER && dist2(x, y, u.ux, u.uy) <= 2) {
 	    You("cannot %sdrag the heavy iron ball.",
 			    invent ? "carry all that and also " : "");
-	    nomul(0);
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );
 	    return FALSE;
 	}
 
@@ -595,7 +599,11 @@ drag:
 		    u.uy = uchain->oy;
 		    newsym(u.ux0, u.uy0);
 		}
-		nomul(0);
+		nomul(0
+#ifdef HELPLESS
+		      , 0
+#endif
+		      );
 
 		*bc_control = BC_BALL;
 		move_bc(1, *bc_control, *ballx, *bally, *chainx, *chainy);
diff --git a/src/botl.c b/src/botl.c
index 6534ad7..9d50858 100644
--- a/src/botl.c
+++ b/src/botl.c
@@ -3,6 +3,11 @@
 /* NetHack may be freely redistributed.  See license for details. */
 
 #include "hack.h"
+#if defined(HPMON) && defined(TEXTCOLOR)
+# ifndef WINTTY_H
+#  include "wintty.h"
+# endif
+#endif
 
 #ifdef OVL0
 extern const char *hu_stat[];	/* defined in eat.c */
@@ -165,10 +170,16 @@ botl_score()
 }
 #endif
 
+#ifdef DUMP_LOG
+void bot1str(char *newbot1)
+#else
 STATIC_OVL void
 bot1()
+#endif
 {
+#ifndef DUMP_LOG
 	char newbot1[MAXCO];
+#endif
 	register char *nb;
 	register int i,j;
 
@@ -215,6 +226,15 @@ bot1()
 	if (flags.showscore)
 	    Sprintf(nb = eos(nb), " S:%ld", botl_score());
 #endif
+#ifdef DUMP_LOG
+}
+STATIC_OVL void
+bot1()
+{
+	char newbot1[MAXCO];
+
+	bot1str(newbot1);
+#endif
 	curs(WIN_STATUS, 1, 0);
 	putstr(WIN_STATUS, 0, newbot1);
 }
@@ -242,12 +262,22 @@ char *buf;
 	return ret;
 }
 
+#ifdef DUMP_LOG
+void bot2str(newbot2)
+char* newbot2;
+#else
 STATIC_OVL void
 bot2()
+#endif
 {
+#ifndef DUMP_LOG
 	char  newbot2[MAXCO];
+#endif
 	register char *nb;
 	int hp, hpmax;
+#ifdef HPMON
+	int hpcolor, hpattr;
+#endif
 	int cap = near_capacity();
 
 	hp = Upolyd ? u.mh : u.uhp;
@@ -256,6 +286,15 @@ bot2()
 	if(hp < 0) hp = 0;
 	(void) describe_level(newbot2);
 	Sprintf(nb = eos(newbot2),
+#ifdef HPMON
+		"%c:%-2ld HP:", oc_syms[COIN_CLASS],
+#ifndef GOLDOBJ
+		u.ugold
+#else
+		money_cnt(invent)
+#endif
+		);
+#else /* HPMON */
 		"%c:%-2ld HP:%d(%d) Pw:%d(%d) AC:%-2d", oc_syms[COIN_CLASS],
 #ifndef GOLDOBJ
 		u.ugold,
@@ -263,6 +302,39 @@ bot2()
 		money_cnt(invent),
 #endif
 		hp, hpmax, u.uen, u.uenmax, u.uac);
+#endif /* HPMON */
+#ifdef HPMON
+	curs(WIN_STATUS, 1, 1);
+	putstr(WIN_STATUS, 0, newbot2);
+
+	Sprintf(nb = eos(newbot2), "%d(%d)", hp, hpmax);
+#ifdef TEXTCOLOR
+	if (iflags.use_color) {
+	  curs(WIN_STATUS, 1, 1);
+	  hpattr = ATR_NONE;
+	  if(hp == hpmax){
+	    hpcolor = NO_COLOR;
+	  } else if(hp > (hpmax*2/3)) {
+	    hpcolor = CLR_GREEN;
+	  } else if(hp <= (hpmax/3)) {
+	    hpcolor = CLR_RED;
+	    if(hp<=(hpmax/10)) 
+	      hpattr = ATR_BLINK;
+	  } else {
+	    hpcolor = CLR_YELLOW;
+	  }
+	  if (hpcolor != NO_COLOR)
+	    term_start_color(hpcolor);
+	  if(hpattr!=ATR_NONE)term_start_attr(hpattr);
+	  putstr(WIN_STATUS, hpattr, newbot2);
+	  if(hpattr!=ATR_NONE)term_end_attr(hpattr);
+	  if (hpcolor != NO_COLOR)
+	    term_end_color();
+	}
+#endif /* TEXTCOLOR */
+	Sprintf(nb = eos(newbot2), " Pw:%d(%d) AC:%-2d",
+		u.uen, u.uenmax, u.uac);
+#endif /* HPMON */
 
 	if (Upolyd)
 		Sprintf(nb = eos(nb), " HD:%d", mons[u.umonnum].mlevel);
@@ -292,10 +364,37 @@ bot2()
 	if(Slimed)         Sprintf(nb = eos(nb), " Slime");
 	if(cap > UNENCUMBERED)
 		Sprintf(nb = eos(nb), " %s", enc_stat[cap]);
+#ifdef DUMP_LOG
+}
+STATIC_OVL void
+bot2()
+{
+	char newbot2[MAXCO];
+	bot2str(newbot2);
+#endif
 	curs(WIN_STATUS, 1, 1);
 	putstr(WIN_STATUS, 0, newbot2);
 }
 
+#ifdef ENL_STATS
+const char *
+encstat()
+{
+  int cap = near_capacity();
+  if(cap > UNENCUMBERED)
+    return enc_stat[cap];
+  else return "";
+}
+
+const char *
+hunstat()
+{
+  if (strcmp(hu_stat[u.uhs], "        "))
+    return hu_stat[u.uhs];
+  else return "";
+}
+#endif
+
 void
 bot()
 {
diff --git a/src/cmd.c b/src/cmd.c
index b12c0e5..f44d805 100644
--- a/src/cmd.c
+++ b/src/cmd.c
@@ -123,6 +123,10 @@ STATIC_PTR int NDECL(wiz_show_seenv);
 STATIC_PTR int NDECL(wiz_show_vision);
 STATIC_PTR int NDECL(wiz_mon_polycontrol);
 STATIC_PTR int NDECL(wiz_show_wmodes);
+STATIC_PTR int NDECL(wiz_showkills);	/* showborn patch */
+#ifdef SHOW_BORN
+extern void FDECL(list_vanquished, (int, BOOLEAN_P)); /* showborn patch */
+#endif /* SHOW_BORN */
 #if defined(__BORLANDC__) && !defined(_WIN32)
 extern void FDECL(show_borlandc_stats, (winid));
 #endif
@@ -139,7 +143,7 @@ STATIC_PTR int NDECL(wiz_show_stats);
 STATIC_DCL int NDECL(wiz_port_debug);
 #  endif
 # endif
-STATIC_PTR int NDECL(enter_explore_mode);
+int NDECL(enter_explore_mode);	/* deathexplore patch */
 STATIC_PTR int NDECL(doattributes);
 STATIC_PTR int NDECL(doconduct); /**/
 STATIC_PTR boolean NDECL(minimal_enlightenment);
@@ -475,12 +479,29 @@ domonability()
 	return 0;
 }
 
-STATIC_PTR int
+int	/* deathexplore patch */
 enter_explore_mode()
 {
+#ifdef PARANOID
+	char buf[BUFSZ];
+	int really_xplor = FALSE;
+#endif
 	if(!discover && !wizard) {
 		pline("Beware!  From explore mode there will be no return to normal game.");
+#ifdef PARANOID
+		if (iflags.paranoid_quit) {
+		  getlin ("Do you want to enter explore mode? [yes/no]?",buf);
+		  (void) lcase (buf);
+		  if (!(strcmp (buf, "yes"))) really_xplor = TRUE;
+		} else {
 		if (yn("Do you want to enter explore mode?") == 'y') {
+		    really_xplor = TRUE;
+		  }
+		}
+		if (really_xplor) {
+#else
+		if (yn("Do you want to enter explore mode?") == 'y') {
+#endif
 			clear_nhwindow(WIN_MESSAGE);
 			You("are now in non-scoring explore mode.");
 			discover = TRUE;
@@ -756,6 +777,13 @@ wiz_show_wmodes()
 	return 0;
 }
 
+/* #showkills command */
+STATIC_PTR int wiz_showkills()		/* showborn patch */
+{
+	list_vanquished('y', FALSE);
+	return 0;
+}
+
 #endif /* WIZARD */
 
 
@@ -1126,6 +1154,304 @@ int final;	/* 0 => still in progress; 1 => over, survived; 2 => dead */
 	return;
 }
 
+#ifdef DUMP_LOG
+void
+dump_enlightenment(final)
+int final;
+{
+	int ltmp;
+	char buf[BUFSZ];
+	char buf2[BUFSZ];
+	const char *enc_stat[] = { /* copied from botl.c */
+	     "",
+	     "burdened",
+	     "stressed",
+	     "strained",
+	     "overtaxed",
+	     "overloaded"
+	};
+	char *youwere = "  You were ";
+	char *youhave = "  You have ";
+	char *youhad  = "  You had ";
+	char *youcould = "  You could ";
+
+	dump("", "Final attributes");
+
+#ifdef ELBERETH
+	if (u.uevent.uhand_of_elbereth) {
+	    static const char * const hofe_titles[3] = {
+				"the Hand of Elbereth",
+				"the Envoy of Balance",
+				"the Glory of Arioch"
+	    };
+	    dump(youwere,
+		(char *)hofe_titles[u.uevent.uhand_of_elbereth - 1]);
+	}
+#endif
+
+	if (u.ualign.record >= 20)
+		dump(youwere, "piously aligned");
+	else if (u.ualign.record > 13)
+	    dump(youwere, "devoutly aligned");
+	else if (u.ualign.record > 8)
+	    dump(youwere, "fervently aligned");
+	else if (u.ualign.record > 3)
+	    dump(youwere, "stridently aligned");
+	else if (u.ualign.record == 3)
+	    dump(youwere, "aligned");
+	else if (u.ualign.record > 0)
+	    dump(youwere, "haltingly aligned");
+	else if (u.ualign.record == 0)
+	    dump(youwere, "nominally aligned");
+	else if (u.ualign.record >= -3)	dump(youhave, "strayed");
+	else if (u.ualign.record >= -8)	dump(youhave, "sinned");
+	else dump("  You have ", "transgressed");
+	Sprintf(buf, " %d", u.ualign.record);
+	dump("  Your alignment was ", buf);
+
+	/*** Resistances to troubles ***/
+	if (Fire_resistance) dump(youwere, "fire resistant");
+	if (Cold_resistance) dump(youwere, "cold resistant");
+	if (Sleep_resistance) dump(youwere, "sleep resistant");
+	if (Disint_resistance) dump(youwere, "disintegration-resistant");
+	if (Shock_resistance) dump(youwere, "shock resistant");
+	if (Poison_resistance) dump(youwere, "poison resistant");
+	if (Drain_resistance) dump(youwere, "level-drain resistant");
+	if (Sick_resistance) dump(youwere, "immune to sickness");
+	if (Antimagic) dump(youwere, "magic-protected");
+	if (Acid_resistance) dump(youwere, "acid resistant");
+	if (Stone_resistance) dump(youwere, "petrification resistant");
+	if (Invulnerable) dump(youwere, "invulnerable");
+	if (u.uedibility) dump(youcould, "recognize detrimental food");
+
+	/*** Troubles ***/
+	if (Halluc_resistance) 	dump("  ", "You resisted hallucinations");
+	if (Hallucination) dump(youwere, "hallucinating");
+	if (Stunned) dump(youwere, "stunned");
+	if (Confusion) dump(youwere, "confused");
+	if (Blinded) dump(youwere, "blinded");
+	if (Sick) {
+		if (u.usick_type & SICK_VOMITABLE)
+			dump(youwere, "sick from food poisoning");
+		if (u.usick_type & SICK_NONVOMITABLE)
+			dump(youwere, "sick from illness");
+	}
+	if (Stoned) dump(youwere, "turning to stone");
+	if (Slimed) dump(youwere, "turning into slime");
+	if (Strangled)
+		dump(youwere, (u.uburied) ? "buried" : "being strangled");
+	if (Glib) {
+		Sprintf(buf, "slippery %s", makeplural(body_part(FINGER)));
+		dump(youhad, buf);
+	}
+	if (Fumbling) dump("  ", "You fumbled");
+	if (Wounded_legs
+#ifdef STEED
+	    && !u.usteed
+#endif
+			  ) {
+		Sprintf(buf, "wounded %s", makeplural(body_part(LEG)));
+		dump(youhad, buf);
+	}
+#ifdef STEED
+	if (Wounded_legs && u.usteed) {
+	    Strcpy(buf, x_monnam(u.usteed, ARTICLE_YOUR, (char *)0, 
+		    SUPPRESS_SADDLE | SUPPRESS_HALLUCINATION, FALSE));
+	    *buf = highc(*buf);
+	    Strcat(buf, " had wounded legs");
+	    dump("  ", buf);
+	}
+#endif
+	if (Sleeping) dump("  ", "You fell asleep");
+	if (Hunger) dump("  ", "You hungered rapidly");
+
+	/*** Vision and senses ***/
+	if (See_invisible) dump("  ", "You saw invisible");
+	if (Blind_telepat) dump(youwere, "telepathic");
+	if (Warning) dump(youwere, "warned");
+	if (Warn_of_mon && flags.warntype) {
+		Sprintf(buf, "aware of the presence of %s",
+			(flags.warntype & M2_ORC) ? "orcs" :
+			(flags.warntype & M2_DEMON) ? "demons" :
+			something); 
+		dump(youwere, buf);
+	}
+	if (Undead_warning) dump(youwere, "warned of undead");
+	if (Searching) dump(youhad, "automatic searching");
+	if (Clairvoyant) dump(youwere, "clairvoyant");
+	if (Infravision) dump(youhad, "infravision");
+	if (Detect_monsters)
+	  dump(youwere, "sensing the presence of monsters");
+	if (u.umconf) dump(youwere, "going to confuse monsters");
+
+	/*** Appearance and behavior ***/
+	if (Adornment) {
+	    int adorn = 0;
+	    if(uleft && uleft->otyp == RIN_ADORNMENT) adorn += uleft->spe;
+	    if(uright && uright->otyp == RIN_ADORNMENT) adorn += uright->spe;
+	    if (adorn < 0)
+		dump(youwere, "poorly adorned");
+	    else
+		dump(youwere, "adorned");
+	}
+	if (Invisible) dump(youwere, "invisible");
+	else if (Invis) dump(youwere, "invisible to others");
+	/* ordinarily "visible" is redundant; this is a special case for
+	   the situation when invisibility would be an expected attribute */
+	else if ((HInvis || EInvis || pm_invisible(youmonst.data)) && BInvis)
+	    dump(youwere, "visible");
+	if (Displaced) dump(youwere, "displaced");
+	if (Stealth) dump(youwere, "stealthy");
+	if (Aggravate_monster) dump("  ", "You aggravated monsters");
+	if (Conflict) dump("  ", "You caused conflict");
+
+	/*** Transportation ***/
+	if (Jumping) dump(youcould, "jump");
+	if (Teleportation) dump(youcould, "teleport");
+	if (Teleport_control) dump(youhad, "teleport control");
+	if (Lev_at_will) dump(youwere, "levitating, at will");
+	else if (Levitation)
+	  dump(youwere, "levitating");	/* without control */
+	else if (Flying) dump(youcould, "fly");
+	if (Wwalking) dump(youcould, "walk on water");
+	if (Swimming) dump(youcould, "swim");
+	if (Breathless) dump(youcould, "survive without air");
+	else if (Amphibious) dump(youcould, "breathe water");
+	if (Passes_walls) dump(youcould, "walk through walls");
+#ifdef STEED
+	if (u.usteed && (final < 2 || strcmp(killer, "riding accident"))) {
+	    Sprintf(buf, "riding %s", y_monnam(u.usteed));
+	    dump(youwere, buf);
+	}
+#endif
+	if (u.uswallow) {
+	    Sprintf(buf, "swallowed by %s", a_monnam(u.ustuck));
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%u)", u.uswldtim);
+#endif
+	    dump(youwere, buf);
+	} else if (u.ustuck) {
+	    Sprintf(buf, "%s %s",
+		    (Upolyd && sticks(youmonst.data)) ? "holding" : "held by",
+		    a_monnam(u.ustuck));
+	    dump(youwere, buf);
+	}
+
+	/*** Physical attributes ***/
+	if (u.uhitinc)
+	    dump(youhad,
+		enlght_combatinc("to hit", u.uhitinc, final, buf));
+	if (u.udaminc)
+	    dump(youhad,
+		enlght_combatinc("damage", u.udaminc, final, buf));
+	if (Slow_digestion) dump(youhad, "slower digestion");
+	if (Regeneration) dump("  ", "You regenerated");
+	if (u.uspellprot || Protection) {
+	    int prot = 0;
+
+	    if(uleft && uleft->otyp == RIN_PROTECTION) prot += uleft->spe;
+	    if(uright && uright->otyp == RIN_PROTECTION) prot += uright->spe;
+	    if (HProtection & INTRINSIC) prot += u.ublessed;
+	    prot += u.uspellprot;
+	    
+	    if (prot < 0)
+		dump(youwere, "ineffectively protected");
+	    else
+		dump(youwere, "protected");
+	}
+	if (Protection_from_shape_changers)
+		dump(youwere, "protected from shape changers");
+	if (Polymorph) dump(youwere, "polymorphing");
+	if (Polymorph_control) dump(youhad, "polymorph control");
+	if (u.ulycn >= LOW_PM) {
+		Strcpy(buf, an(mons[u.ulycn].mname));
+		dump(youwere, buf);
+	}
+	if (Upolyd) {
+	    if (u.umonnum == u.ulycn) Strcpy(buf, "in beast form");
+	    else Sprintf(buf, "polymorphed into %s",
+			 an(youmonst.data->mname));
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%d)", u.mtimedone);
+#endif
+	    dump(youwere, buf);
+	}
+	if (Unchanging)
+	  dump(youcould, "not change from your current form");
+	if (Fast) dump(youwere, Very_fast ? "very fast" : "fast");
+	if (Reflecting) dump(youhad, "reflection");
+	if (Free_action) dump(youhad, "free action");
+	if (Fixed_abil) dump(youhad, "fixed abilities");
+	if (Lifesaved)
+		dump("  ", "Your life would have been saved");
+	if (u.twoweap) dump(youwere, "wielding two weapons at once");
+
+	/*** Miscellany ***/
+	if (Luck) {
+	    ltmp = abs((int)Luck);
+	    Sprintf(buf, "%s%slucky (%d)",
+		    ltmp >= 10 ? "extremely " : ltmp >= 5 ? "very " : "",
+		    Luck < 0 ? "un" : "", Luck);
+	    dump(youwere, buf);
+	}
+#ifdef WIZARD
+	 else if (wizard) dump("  ", "Your luck was zero");
+#endif
+	if (u.moreluck > 0) dump(youhad, "extra luck");
+	else if (u.moreluck < 0) dump(youhad, "reduced luck");
+	if (carrying(LUCKSTONE) || stone_luck(TRUE)) {
+	    ltmp = stone_luck(FALSE);
+	    if (ltmp <= 0)
+		dump("  ", "Bad luck did not time out for you");
+	    if (ltmp >= 0)
+		dump("  ", "Good luck did not time out for you");
+	}
+
+	if (u.ugangr) {
+	    Sprintf(buf, " %sangry with you",
+		u.ugangr > 6 ? "extremely " : u.ugangr > 3 ? "very " : "");
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%d)", u.ugangr);
+#endif
+	    Sprintf(buf2, "%s was %s", u_gname(), buf);
+	    dump("  ", buf2);
+	}
+
+    {
+	const char *p;
+
+	buf[0] = '\0';
+	if (final < 2) {    /* quit/escaped/ascended */
+	    p = "survived after being killed ";
+	    switch (u.umortality) {
+	    case 0:  p = "survived";  break;
+	    case 1:  Strcpy(buf, "once");  break;
+	    case 2:  Strcpy(buf, "twice");  break;
+	    case 3:  Strcpy(buf, "thrice");  break;
+	    default: Sprintf(buf, "%d times", u.umortality);
+		     break;
+	    }
+	} else {		/* game ended in character's death */
+	    p = "are dead";
+	    switch (u.umortality) {
+	    case 0:  impossible("dead without dying?");
+	    case 1:  break;			/* just "are dead" */
+	    default: Sprintf(buf, " (%d%s time!)", u.umortality,
+			     ordin(u.umortality));
+		     break;
+	    }
+	}
+	if (p) {
+	  Sprintf(buf2, "You %s %s", p, buf);
+	  dump("  ", buf2);
+	}
+    }
+	dump("", "");
+	return;
+
+} /* dump_enlightenment */
+#endif
+
 /*
  * Courtesy function for non-debug, non-explorer mode players
  * to help refresh them about who/what they are.
@@ -1145,6 +1471,9 @@ minimal_enlightenment()
 	static const char tabbed_deity_fmtstr[] = "%s\t%s";
 	static const char *fmtstr;
 	static const char *deity_fmtstr;
+#ifdef ENL_STATS
+	boolean stats = FALSE;
+#endif
 
 	fmtstr = iflags.menu_tab_sep ? tabbed_fmtstr : untabbed_fmtstr;
 	deity_fmtstr = iflags.menu_tab_sep ?
@@ -1224,6 +1553,48 @@ minimal_enlightenment()
 	Sprintf(buf, fmtstr, "Lawful", buf2);
 	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, FALSE);
 
+#ifdef ENL_STATS
+	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", FALSE);
+	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings, "Status", FALSE);
+	if (strcmp(hunstat(), "")) {
+	  add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, hunstat(), FALSE);
+	  stats = TRUE;
+	}
+	if (near_capacity() > UNENCUMBERED) {
+	  add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, encstat(), FALSE);
+	  stats = TRUE;
+	}
+	if (Confusion) { 
+	  add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "Confused", FALSE); stats = TRUE; 
+	}
+	if (Sick) {
+	  if (u.usick_type & SICK_VOMITABLE) {
+	    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "Dying from food poisoning", FALSE);
+	    stats = TRUE;
+	  }
+	  if (u.usick_type & SICK_NONVOMITABLE) {
+	    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "Dying from illness", FALSE);
+	    stats = TRUE;
+	  }
+	}
+	if (Blind) { 
+	  add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "Blind", FALSE); 
+	  stats = TRUE; 
+	}
+	if (Stunned) { 
+	  add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "Stunned", FALSE); stats = TRUE;
+	}
+	if (Hallucination) {
+	  add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "Hallucinating", FALSE);
+	  stats = TRUE;
+	}
+	if (Slimed) {
+	  add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "Slimed", FALSE);
+	  stats = TRUE;
+	}
+	if (!stats) add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "None", FALSE);
+#endif
+
 	end_menu(tmpwin, "Base Attributes");
 	n = select_menu(tmpwin, PICK_NONE, &selected);
 	destroy_nhwindow(tmpwin);
@@ -1341,6 +1712,99 @@ int final;
 	destroy_nhwindow(en_win);
 }
 
+#ifdef DUMP_LOG
+void
+dump_conduct(final)
+int final;
+{
+	char buf[BUFSZ];
+	int ngenocided;
+
+	dump("", "Voluntary challenges");
+
+	if (!u.uconduct.food)
+	    dump("", "  You went without food");
+	    /* But beverages are okay */
+	else if (!u.uconduct.unvegan)
+	    dump("", "  You followed a strict vegan diet");
+	else if (!u.uconduct.unvegetarian)
+	    dump("", "  You were a vegetarian");
+	else if (Role_if(PM_MONK) && u.uconduct.unvegetarian < 10) {
+	    sprintf(buf, "  You ate non-vegetarian food %ld time%s.", 
+		u.uconduct.unvegetarian, plur(u.uconduct.unvegetarian));
+	    dump("", buf);
+	}
+
+	if (!u.uconduct.gnostic)
+	    dump("", "  You were an atheist");
+
+	if (!u.uconduct.weaphit)
+	    dump("", "  You never hit with a wielded weapon");
+	else if (Role_if(PM_MONK) && u.uconduct.weaphit < 10) {
+	    Sprintf(buf, "  You hit with a wielded weapon %ld time%s",
+		    u.uconduct.weaphit, plur(u.uconduct.weaphit));
+	    dump("", buf);
+	}
+#ifdef WIZARD
+	else if (wizard) {
+	    Sprintf(buf, "hit with a wielded weapon %ld time%s",
+		    u.uconduct.weaphit, plur(u.uconduct.weaphit));
+	    dump("  You ", buf);
+	}
+#endif
+	if (!u.uconduct.killer)
+	    dump("", "  You were a pacifist");
+
+	if (!u.uconduct.literate)
+	    dump("", "  You were illiterate");
+#ifdef WIZARD
+	else if (wizard) {
+	    Sprintf(buf, "read items or engraved %ld time%s",
+		    u.uconduct.literate, plur(u.uconduct.literate));
+	    dump("  You ", buf);
+	}
+#endif
+
+	ngenocided = num_genocides();
+	if (ngenocided == 0) {
+	    dump("", "  You never genocided any monsters");
+	} else {
+	    Sprintf(buf, "genocided %d type%s of monster%s",
+		    ngenocided, plur(ngenocided), plur(ngenocided));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.polypiles)
+	    dump("", "  You never polymorphed an object");
+	else {
+	    Sprintf(buf, "polymorphed %ld item%s",
+		    u.uconduct.polypiles, plur(u.uconduct.polypiles));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.polyselfs)
+	    dump("", "  You never changed form");
+	else {
+	    Sprintf(buf, "changed form %ld time%s",
+		    u.uconduct.polyselfs, plur(u.uconduct.polyselfs));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.wishes)
+	    dump("", "  You used no wishes");
+	else {
+	    Sprintf(buf, "used %ld wish%s",
+		    u.uconduct.wishes, (u.uconduct.wishes > 1L) ? "es" : "");
+	    dump("  You ", buf);
+
+	    if (!u.uconduct.wisharti)
+		dump("", "  You did not wish for any artifacts");
+	}
+
+	dump("", "");
+}
+#endif /* DUMP_LOG */
+
 #endif /* OVLB */
 #ifdef OVL1
 
@@ -1519,6 +1983,7 @@ struct ext_func_tab extcmdlist[] = {
 	{(char *)0, (char *)0, donull, TRUE},
 #endif
 	{(char *)0, (char *)0, donull, TRUE},
+	{(char *)0, (char *)0, donull, TRUE}, /* showkills (showborn patch) */
         {(char *)0, (char *)0, donull, TRUE},
 	{(char *)0, (char *)0, donull, TRUE},
 	{(char *)0, (char *)0, donull, TRUE},
@@ -1544,6 +2009,7 @@ static const struct ext_func_tab debug_extcmdlist[] = {
 	{"portdebug", "wizard port debug command", wiz_port_debug, TRUE},
 #endif
 	{"seenv", "show seen vectors", wiz_show_seenv, TRUE},
+	{"showkills", "show list of monsters killed", wiz_showkills, TRUE},
 	{"stats", "show memory statistics", wiz_show_stats, TRUE},
 	{"timeout", "look at timeout queue", wiz_timeout_queue, TRUE},
 	{"vision", "show vision array", wiz_show_vision, TRUE},
diff --git a/src/decl.c b/src/decl.c
index 4dd460e..58cfb25 100644
--- a/src/decl.c
+++ b/src/decl.c
@@ -20,6 +20,9 @@ char *catmore = 0;		/* default pager */
 NEARDATA int bases[MAXOCLASSES] = DUMMY;
 
 NEARDATA int multi = 0;
+#ifdef HELPLESS
+char multi_txt[BUFSZ] = DUMMY;
+#endif
 #if 0
 NEARDATA int warnlevel = 0;		/* used by movemon and dochugw */
 #endif
@@ -209,6 +212,15 @@ NEARDATA struct monst *migrating_mons = (struct monst *)0;
 
 NEARDATA struct mvitals mvitals[NUMMONS];
 
+/* originally from end.c */
+#ifdef DUMP_LOG
+#ifdef DUMP_FN
+char dump_fn[] = DUMP_FN;
+#else
+char dump_fn[PL_PSIZ] = DUMMY;
+#endif
+#endif /* DUMP_LOG */
+
 NEARDATA struct c_color_names c_color_names = {
 	"black", "amber", "golden",
 	"light blue", "red", "green",
@@ -235,6 +247,10 @@ const char *c_obj_colors[] = {
 	"white",		/* CLR_WHITE */
 };
 
+#ifdef MENU_COLOR
+struct menucoloring *menu_colorings = 0;
+#endif
+
 struct c_common_strings c_common_strings = {
 	"Nothing happens.",		"That's enough tries!",
 	"That is a silly thing to %s.",	"shudder for a moment.",
diff --git a/src/detect.c b/src/detect.c
index 5da025f..b0f873c 100644
--- a/src/detect.c
+++ b/src/detect.c
@@ -861,7 +861,11 @@ struct obj *obj;
 	return;
     }
     You("peer into %s...", the(xname(obj)));
-    nomul(-rnd(10));
+    nomul(-rnd(10)
+#ifdef HELPLESS
+	  , "gazing into a crystal ball"
+#endif
+	  );
     nomovemsg = "";
     if (obj->spe <= 0)
 	pline_The("vision is unclear.");
@@ -1191,7 +1195,11 @@ register int aflag;
 			if(rnl(7-fund)) continue;
 			cvt_sdoor_to_door(&levl[x][y]);	/* .typ = DOOR */
 			exercise(A_WIS, TRUE);
-			nomul(0);
+			nomul(0
+#ifdef HELPLESS
+			      , 0
+#endif
+			      );
 			if (Blind && !aflag)
 			    feel_location(x,y);	/* make sure it shows up */
 			else
@@ -1201,7 +1209,11 @@ register int aflag;
 			levl[x][y].typ = CORR;
 			unblock_point(x,y);	/* vision */
 			exercise(A_WIS, TRUE);
-			nomul(0);
+			nomul(0
+#ifdef HELPLESS
+			      , 0
+#endif
+			      );
 			newsym(x,y);
 		    } else {
 		/* Be careful not to find anything in an SCORR or SDOOR */
@@ -1246,7 +1258,11 @@ register int aflag;
 			}
 
 			if ((trap = t_at(x,y)) && !trap->tseen && !rnl(8)) {
-			    nomul(0);
+			    nomul(0
+#ifdef HELPLESS
+				  , 0
+#endif
+				  );
 
 			    if (trap->ttyp == STATUE_TRAP) {
 				if (activate_statue_trap(trap, x, y, FALSE))
diff --git a/src/dig.c b/src/dig.c
index 4c40a59..d5f765e 100644
--- a/src/dig.c
+++ b/src/dig.c
@@ -916,7 +916,11 @@ struct obj *obj;
 				aobjnam(obj, "become"));
 			    /* you ought to be able to let go; tough luck */
 			    /* (maybe `move_into_trap()' would be better) */
-			    nomul(-d(2,2));
+			    nomul(-d(2,2)
+#ifdef HELPLESS
+				  , "stuck in a spider web"
+#endif
+				  );
 			    nomovemsg = "You pull free.";
 			} else if (lev->typ == IRONBARS) {
 			    pline("Clang!");
diff --git a/src/display.c b/src/display.c
index 2c9e9ae..0582b5d 100644
--- a/src/display.c
+++ b/src/display.c
@@ -1370,6 +1370,106 @@ flush_screen(cursor_on_u)
 
 /* ========================================================================= */
 
+#ifdef DUMP_LOG
+/* D: Added to dump screen to output file */
+STATIC_PTR uchar get_glyph_char(glyph)
+int glyph;
+{
+    uchar   ch;
+    register int offset;
+
+    if (glyph >= NO_GLYPH)
+        return ' ';
+
+    /*
+     *  Map the glyph back to a character.
+     *
+     *  Warning:  For speed, this makes an assumption on the order of
+     *		  offsets.  The order is set in display.h.
+     */
+    if ((offset = (glyph - GLYPH_WARNING_OFF)) >= 0) {	/* a warning flash */
+	ch = def_warnsyms[offset].sym;
+    } else if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {	/* swallow */
+	/* see swallow_to_glyph() in display.c */
+	ch = (uchar) defsyms[S_sw_tl + (offset & 0x7)].sym;
+    } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {	/* zap beam */
+	/* see zapdir_to_glyph() in display.c */
+	ch = defsyms[S_vbeam + (offset & 0x3)].sym;
+    } else if ((offset = (glyph - GLYPH_CMAP_OFF)) >= 0) {	/* cmap */
+	ch = defsyms[offset].sym;
+    } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
+	ch = def_oc_syms[(int)objects[offset].oc_class];
+    } else if ((offset = (glyph - GLYPH_RIDDEN_OFF)) >= 0) { /* mon ridden */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
+	ch = def_oc_syms[(int)objects[CORPSE].oc_class];
+    } else if ((offset = (glyph - GLYPH_DETECT_OFF)) >= 0) { /* mon detect */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else if ((offset = (glyph - GLYPH_INVIS_OFF)) >= 0) {  /* invisible */
+	ch = DEF_INVISIBLE;
+    } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else {						    /* a monster */
+	ch = monsyms[(int)mons[glyph].mlet];
+    }
+    return ch;
+}
+
+#ifdef TTY_GRAPHICS
+extern const char * FDECL(compress_str, (const char *));
+#else
+const char*
+compress_str(str) /* copied from win/tty/wintty.c */
+const char *str;
+{
+	static char cbuf[BUFSZ];
+	/* compress in case line too long */
+	if((int)strlen(str) >= 80) {
+		register const char *bp0 = str;
+		register char *bp1 = cbuf;
+
+		do {
+			if(*bp0 != ' ' || bp0[1] != ' ')
+				*bp1++ = *bp0;
+		} while(*bp0++);
+	} else
+	    return str;
+	return cbuf;
+}
+#endif /* TTY_GRAPHICS */
+
+/* Take a screen dump */
+void dump_screen()
+{
+    register int x,y;
+    int lastc;
+    /* D: botl.c has a closer approximation to the size, but we'll go with
+     *    this */
+    char buf[300], *ptr;
+    
+    for (y = 0; y < ROWNO; y++) {
+	lastc = 0;
+	ptr = buf;
+	for (x = 1; x < COLNO; x++) {
+	    uchar c = get_glyph_char(gbuf[y][x].glyph);
+	    *ptr++ = c;
+	    if (c != ' ')
+		lastc = x;
+	}
+	buf[lastc] = '\0';
+	dump("", buf);
+    }
+    dump("", "");
+    bot1str(buf);
+    ptr = (char *) compress_str((const char *) buf);
+    dump("", ptr);
+    bot2str(buf);
+    dump("", buf);
+    dump("", "");
+    dump("", "");
+}
+#endif /* DUMP_LOG */
+
 /*
  * back_to_glyph()
  *
diff --git a/src/do.c b/src/do.c
index 858777f..5ee4141 100644
--- a/src/do.c
+++ b/src/do.c
@@ -208,7 +208,7 @@ const char *verb;
 		    map_background(x, y, 0);
 		    newsym(x, y);
 		}
-		water_damage(obj, FALSE, FALSE);
+		return water_damage(obj, FALSE, FALSE);
 	} else if (u.ux == x && u.uy == y &&
 		(!u.utrap || u.utraptype != TT_PIT) &&
 		(t = t_at(x,y)) != 0 && t->tseen &&
@@ -667,8 +667,14 @@ int retry;
 	all_categories = FALSE;
 	n = query_category("Drop what type of items?",
 			invent,
-			UNPAID_TYPES | ALL_TYPES | CHOOSE_ALL |
-			BUC_BLESSED | BUC_CURSED | BUC_UNCURSED | BUC_UNKNOWN,
+			UNPAID_TYPES | ALL_TYPES | CHOOSE_ALL
+#ifdef ITEMCAT_JP
+                        | JUSTPICKED
+#endif
+#ifdef ITEMCAT
+                        | UNIDENTIFIED | RUSTPRONE
+#endif
+			| BUC_BLESSED | BUC_CURSED | BUC_UNCURSED | BUC_UNKNOWN,
 			&pick_list, PICK_ANY);
 	if (!n) goto drop_done;
 	for (i = 0; i < n; i++) {
diff --git a/src/do_wear.c b/src/do_wear.c
index c197c1b..dc4c7ba 100644
--- a/src/do_wear.c
+++ b/src/do_wear.c
@@ -1078,7 +1078,11 @@ dotakeoff()
 			  "  Use 'R' command to remove accessories." : "");
 		return 0;
 	}
-	if (armorpieces > 1)
+	if (armorpieces > 1
+#ifdef PARANOID
+	    || iflags.paranoid_remove
+#endif
+	    )
 		otmp = getobj(clothes, "take off");
 	if (otmp == 0) return(0);
 	if (!(otmp->owornmask & W_ARMOR)) {
@@ -1128,7 +1132,11 @@ doremring()
 		      "  Use 'T' command to take off armor." : "");
 		return(0);
 	}
-	if (Accessories != 1) otmp = getobj(accessories, "remove");
+	if (Accessories != 1
+#ifdef PARANOID
+	    || iflags.paranoid_remove
+#endif
+	    ) otmp = getobj(accessories, "remove");
 	if(!otmp) return(0);
 	if(!(otmp->owornmask & (W_RING | W_AMUL | W_TOOL))) {
 		You("are not wearing that.");
@@ -1184,7 +1192,11 @@ register struct obj *otmp;
 
 	if(cursed(otmp)) return(0);
 	if(delay) {
-		nomul(delay);
+		nomul(delay
+#ifdef HELPLESS
+		      , "disrobing"
+#endif
+		      );
 		if (is_helmet(otmp)) {
 			nomovemsg = "You finish taking off your helmet.";
 			afternmv = Helmet_off;
@@ -1441,7 +1453,11 @@ dowear()
 	setworn(otmp, mask);
 	delay = -objects[otmp->otyp].oc_delay;
 	if(delay){
-		nomul(delay);
+		nomul(delay
+#ifdef HELPLESS
+		      , "dressing up"
+#endif
+		      );
 		if(is_boots(otmp)) afternmv = Boots_on;
 		if(is_helmet(otmp)) afternmv = Helmet_on;
 		if(is_gloves(otmp)) afternmv = Gloves_on;
diff --git a/src/dokick.c b/src/dokick.c
index f390414..8c7871c 100644
--- a/src/dokick.c
+++ b/src/dokick.c
@@ -553,7 +553,7 @@ xchar x, y;
 	mon = bhit(u.dx, u.dy, range, KICKED_WEAPON,
 		   (int FDECL((*),(MONST_P,OBJ_P)))0,
 		   (int FDECL((*),(OBJ_P,OBJ_P)))0,
-		   kickobj);
+		   kickobj, NULL);
 
 	if(mon) {
 	    if (mon->isshk &&
diff --git a/src/dothrow.c b/src/dothrow.c
index 2c4389a..5c39186 100644
--- a/src/dothrow.c
+++ b/src/dothrow.c
@@ -300,8 +300,16 @@ dofire()
 		if (!flags.autoquiver) {
 			/* Don't automatically fill the quiver */
 			You("have no ammunition readied!");
+#ifdef QUIVER_FIRED
+			if (iflags.quiver_fired)
+			  dowieldquiver(); /* quiver_fired */
+			if (!uquiver)
+#endif
 			return(dothrow());
 		}
+#ifdef QUIVER_FIRED
+		else { /* quiver_fired */
+#endif
 		autoquiver();
 		if (!uquiver) {
 			You("have nothing appropriate for your quiver!");
@@ -310,6 +318,9 @@ dofire()
 			You("fill your quiver:");
 			prinv((char *)0, uquiver, 0L);
 		}
+#ifdef QUIVER_FIRED
+		} /* quiver_fired */
+#endif
 	}
 
 	/*
@@ -608,13 +619,21 @@ hurtle(dx, dy, range, verbose)
      */
     if(Punished && !carried(uball)) {
 	You_feel("a tug from the iron ball.");
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	return;
     } else if (u.utrap) {
 	You("are anchored by the %s.",
 	    u.utraptype == TT_WEB ? "web" : u.utraptype == TT_LAVA ? "lava" :
 		u.utraptype == TT_INFLOOR ? surface(u.ux,u.uy) : "trap");
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	return;
     }
 
@@ -624,7 +643,11 @@ hurtle(dx, dy, range, verbose)
 
     if(!range || (!dx && !dy) || u.ustuck) return; /* paranoia */
 
-    nomul(-range);
+    nomul(-range
+#ifdef HELPLESS
+	  , "moving through the air"
+#endif
+	  );
     if (verbose)
 	You("%s in the opposite direction.", range > 1 ? "hurtle" : "float");
     /* if we're in the midst of shooting multiple projectiles, stop */
@@ -980,14 +1003,17 @@ boolean twoweap; /* used to restore twoweapon mode if wielded weapon returns */
 
 		if (Underwater) range = 1;
 
+		boolean obj_destroyed = FALSE;
 		mon = bhit(u.dx, u.dy, range, THROWN_WEAPON,
 			   (int FDECL((*),(MONST_P,OBJ_P)))0,
 			   (int FDECL((*),(OBJ_P,OBJ_P)))0,
-			   obj);
+			   obj, &obj_destroyed);
 
 		/* have to do this after bhit() so u.ux & u.uy are correct */
 		if(Is_airlevel(&u.uz) || Levitation)
 		    hurtle(-u.dx, -u.dy, urange, TRUE);
+
+		if (obj_destroyed) return; /* fixes C343-100 */
 	}
 
 	if (mon) {
@@ -1748,7 +1774,7 @@ struct obj *obj;
 			mon = bhit(u.dx, u.dy, range, THROWN_WEAPON,
 				   (int FDECL((*),(MONST_P,OBJ_P)))0,
 				   (int FDECL((*),(OBJ_P,OBJ_P)))0,
-				   obj);
+				   obj, NULL);
 			if(mon) {
 			    if (ghitm(mon, obj))	/* was it caught? */
 				return 1;
diff --git a/src/eat.c b/src/eat.c
index 12e8d9b..f8a64fa 100644
--- a/src/eat.c
+++ b/src/eat.c
@@ -862,7 +862,11 @@ register int pm;
                     /* A pile of gold can't ride. */
 		    if (u.usteed) dismount_steed(DISMOUNT_FELL);
 #endif
-		    nomul(-tmp);
+		    nomul(-tmp
+#ifdef HELPLESS
+			  , "pretending to be a pile of gold"
+#endif
+			  );
 		    Sprintf(buf, Hallucination ?
 			"You suddenly dread being peeled and mimic %s again!" :
 			"You now prefer mimicking %s again.",
@@ -1224,7 +1228,11 @@ struct obj *obj;
 			   surface(u.ux,u.uy);
 		pline_The("world spins and %s %s.", what, where);
 		flags.soundok = 0;
-		nomul(-rnd(10));
+		nomul(-rnd(10)
+#ifdef HELPLESS
+		      , "unconscious from rotten food"
+#endif
+		      );
 		nomovemsg = "You are conscious again.";
 		afternmv = Hear_again;
 		return(1);
@@ -2244,7 +2252,11 @@ is_fainted()
 void
 reset_faint()	/* call when a faint must be prematurely terminated */
 {
-	if(is_fainted()) nomul(0);
+	if(is_fainted()) nomul(0
+#ifdef HELPLESS
+			       , 0
+#endif
+			       );
 }
 
 #if 0
@@ -2255,7 +2267,11 @@ sync_hunger()
 	if(is_fainted()) {
 
 		flags.soundok = 0;
-		nomul(-10+(u.uhunger/10));
+		nomul(-10+(u.uhunger/10)
+#ifdef HELPLESS
+		      , "fainted from lack of food"
+#endif
+		      );
 		nomovemsg = "You regain consciousness.";
 		afternmv = unfaint;
 	}
@@ -2320,7 +2336,11 @@ boolean incr;
 				stop_occupation();
 				You("faint from lack of food.");
 				flags.soundok = 0;
-				nomul(-10+(u.uhunger/10));
+				nomul(-10+(u.uhunger/10)
+#ifdef HELPLESS
+				      , "fainted from lack of food"
+#endif
+				      );
 				nomovemsg = "You regain consciousness.";
 				afternmv = unfaint;
 				newhs = FAINTED;
@@ -2489,7 +2509,11 @@ void
 vomit()		/* A good idea from David Neves */
 {
 	make_sick(0L, (char *) 0, TRUE, SICK_VOMITABLE);
-	nomul(-2);
+	nomul(-2
+#ifdef HELPLESS
+	      , "vomiting"
+#endif
+	      );
 }
 
 int
diff --git a/src/end.c b/src/end.c
index 58d47e0..1a171df 100644
--- a/src/end.c
+++ b/src/end.c
@@ -10,6 +10,9 @@
 #include <signal.h>
 #endif
 #include "dlb.h"
+#ifdef DEATH_EXPLORE
+extern int NDECL(enter_explore_mode);
+#endif
 
 	/* these probably ought to be generated by makedefs, like LAST_GEM */
 #define FIRST_GEM    DILITHIUM_CRYSTAL
@@ -39,8 +42,16 @@ STATIC_DCL void FDECL(get_valuables, (struct obj *));
 STATIC_DCL void FDECL(sort_valuables, (struct valuable_data *,int));
 STATIC_DCL void FDECL(artifact_score, (struct obj *,BOOLEAN_P,winid));
 STATIC_DCL void FDECL(savelife, (int));
-STATIC_DCL void FDECL(list_vanquished, (CHAR_P,BOOLEAN_P));
+void FDECL(list_vanquished, (CHAR_P,BOOLEAN_P));
+#ifdef DUMP_LOG
+extern char msgs[][BUFSZ];
+extern int lastmsg;
+extern void NDECL(dump_spells);
+void FDECL(do_vanquished, (int, BOOLEAN_P, BOOLEAN_P));
+STATIC_DCL void FDECL(list_genocided, (int, BOOLEAN_P, BOOLEAN_P));
+#else
 STATIC_DCL void FDECL(list_genocided, (CHAR_P,BOOLEAN_P));
+#endif /* DUMP_LOG */
 STATIC_DCL boolean FDECL(should_query_disclose_option, (int,char *));
 
 #if defined(__BEOS__) || defined(MICRO) || defined(WIN32) || defined(OS2)
@@ -86,6 +97,62 @@ static NEARDATA const char *ends[] = {		/* "when you..." */
 
 extern const char * const killed_by_prefix[];	/* from topten.c */
 
+#ifdef DUMP_LOG
+FILE *dump_fp = (FILE *)0;  /* file pointer for dumps */
+/* functions dump_init, dump_exit and dump are from the dump patch */
+
+void
+dump_init ()
+{
+  if (dump_fn[0]) {
+    char *p = (char *) strstr(dump_fn, "%n");
+    if (p) {
+      int new_dump_fn_len = strlen(dump_fn)+strlen(plname)-2; /* %n */
+      char *new_dump_fn = (char *) alloc((unsigned)(new_dump_fn_len+1));
+      char *q = new_dump_fn;
+      strncpy(q, dump_fn, p-dump_fn);
+      q += p-dump_fn;
+      strncpy(q, plname, strlen(plname) + 1);
+      regularize(q);
+      q[strlen(plname)] = '\0';
+      q += strlen(q);
+      p += 2;	/* skip "%n" */
+      strncpy(q, p, strlen(p));
+      new_dump_fn[new_dump_fn_len] = '\0';
+
+      dump_fp = fopen(new_dump_fn, "w");
+      if (!dump_fp) {
+	pline("Can't open %s for output.", new_dump_fn);
+	pline("Dump file not created.");
+      }
+      free(new_dump_fn);
+      
+    } else {
+      dump_fp = fopen (dump_fn, "w");
+
+      if (!dump_fp) {
+	pline("Can't open %s for output.", dump_fn);
+	pline("Dump file not created.");
+      }
+    }
+  }
+}
+
+void
+dump_exit ()
+{
+  if (dump_fp)
+    fclose (dump_fp);
+}
+
+void dump (pre, str)
+     char *pre, *str;
+{
+  if (dump_fp)
+    fprintf (dump_fp, "%s%s\n", pre, str);
+}
+#endif  /* DUMP_LOG */
+
 /*ARGSUSED*/
 void
 done1(sig_unused)   /* called as signal() handler, so sent at least one arg */
@@ -101,7 +168,11 @@ int sig_unused;
 		clear_nhwindow(WIN_MESSAGE);
 		curs_on_u();
 		wait_synch();
-		if(multi > 0) nomul(0);
+		if(multi > 0) nomul(0
+#ifdef HELPLESS
+				    , 0
+#endif
+				    );
 	} else {
 		(void)done2();
 	}
@@ -112,14 +183,32 @@ int sig_unused;
 int
 done2()
 {
+#ifdef PARANOID
+	char buf[BUFSZ];
+	int really_quit = FALSE;
+
+	if (iflags.paranoid_quit) {
+	  getlin ("Really quit [yes/no]?",buf);
+	  (void) lcase (buf);
+	  if (!(strcmp (buf, "yes"))) really_quit = TRUE;
+	} else {
+	  if(yn("Really quit?") == 'y') really_quit = TRUE;
+	}
+	if (!really_quit) {
+#else /* PARANOID */
 	if(yn("Really quit?") == 'n') {
+#endif /* PARANOID */
 #ifndef NO_SIGNAL
 		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
 #endif
 		clear_nhwindow(WIN_MESSAGE);
 		curs_on_u();
 		wait_synch();
-		if(multi > 0) nomul(0);
+		if(multi > 0) nomul(0
+#ifdef HELPLESS
+				    , 0
+#endif
+				    );
 		if(multi == 0) {
 		    u.uinvulnerable = FALSE;	/* avoid ctrl-C bug -dlc */
 		    u.usleep = 0;
@@ -224,7 +313,14 @@ register struct monst *mtmp;
 		    Sprintf(eos(buf), " called %s", NAME(mtmp));
 	}
 
-	if (multi) Strcat(buf, ", while helpless");
+	if (multi) {
+#ifdef HELPLESS
+	  if (strlen(multi_txt) > 0)
+	    Sprintf(eos(buf), ", while %s", multi_txt);
+	  else
+#endif
+	    Strcat(buf, ", while helpless");
+	}
 	killer = buf;
 	if (mtmp->data->mlet == S_WRAITH)
 		u.ugrave_arise = PM_WRAITH;
@@ -366,18 +462,30 @@ boolean taken;
 	    ask = should_query_disclose_option('i', &defquery);
 	    if (!done_stopprint) {
 		c = ask ? yn_function(qbuf, ynqchars, defquery) : defquery;
-		if (c == 'y') {
+	    } else {
+		c = 'n';
+	    }
+		{
+#ifdef DUMP_LOG
+			boolean want_disp = (c == 'y')? TRUE: FALSE;
+#endif
 			struct obj *obj;
 
 			for (obj = invent; obj; obj = obj->nobj) {
 			    makeknown(obj->otyp);
 			    obj->known = obj->bknown = obj->dknown = obj->rknown = 1;
 			}
+#ifdef DUMP_LOG
+			(void) dump_inventory((char *)0, TRUE, want_disp);
+			do_containerconts(invent, TRUE, TRUE, TRUE, want_disp);
+#else
+			if (c == 'y') {
 			(void) display_inventory((char *)0, TRUE);
 			container_contents(invent, TRUE, TRUE);
 		}
-		if (c == 'q')  done_stopprint++;
+#endif /* DUMP_LOG */
 	    }
+		if (c == 'q')  done_stopprint++;
 	}
 
 	ask = should_query_disclose_option('a', &defquery);
@@ -388,14 +496,28 @@ boolean taken;
 		enlightenment(how >= PANICKED ? 1 : 2); /* final */
 	    if (c == 'q') done_stopprint++;
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) {
+	  dump_enlightenment((int) (how >= PANICKED ? 1 : 2));
+	  dump_spells();
+	}
+#endif
 
 	ask = should_query_disclose_option('v', &defquery);
+#ifdef DUMP_LOG
+	do_vanquished(defquery, ask, TRUE);
+#else
 	if (!done_stopprint)
 	    list_vanquished(defquery, ask);
+#endif
 
 	ask = should_query_disclose_option('g', &defquery);
 	if (!done_stopprint)
+#ifdef DUMP_LOG
+	    list_genocided(defquery, ask,TRUE);
+#else
 	    list_genocided(defquery, ask);
+#endif
 
 	ask = should_query_disclose_option('c', &defquery);
 	if (!done_stopprint) {
@@ -405,6 +527,12 @@ boolean taken;
 		show_conduct(how >= PANICKED ? 1 : 2);
 	    if (c == 'q') done_stopprint++;
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) {
+	    dump_conduct(how >= PANICKED ? 1 : 2);
+	    dump_weapon_skill();
+	}
+#endif
 }
 
 /* try to get the player back in a viable state after being killed */
@@ -523,6 +651,11 @@ winid endwin;
 			otmp->oartifact ? artifact_name(xname(otmp), &dummy) :
 				OBJ_NAME(objects[otmp->otyp]),
 			value, currency(value), points);
+#ifdef DUMP_LOG
+		if (dump_fp)
+		  dump("", pbuf);
+		if (endwin != WIN_ERR)
+#endif
 		putstr(endwin, 0, pbuf);
 	    }
 	}
@@ -536,12 +669,23 @@ void
 done(how)
 int how;
 {
+#if defined(WIZARD) && defined(PARANOID)
+	char paranoid_buf[BUFSZ];
+	int really_bon = TRUE;
+#endif
 	boolean taken;
+#ifdef DEATH_EXPLORE
+	boolean goexplore = FALSE;
+#endif
 	char kilbuf[BUFSZ], pbuf[BUFSZ];
 	winid endwin = WIN_ERR;
 	boolean bones_ok, have_windows = iflags.window_inited;
+#ifdef PROMPT_LOGEXP
+	boolean update_log;
+#endif
 	struct obj *corpse = (struct obj *)0;
 	long umoney;
+	int i;
 
 	if (how == TRICKED) {
 	    if (killer) {
@@ -591,6 +735,7 @@ int how;
 			return;
 		}
 	}
+	bones_ok = (how < GENOCIDED) && can_make_bones(); /* dthexpl patch */
 	if ((
 #ifdef WIZARD
 			wizard ||
@@ -605,15 +750,63 @@ int how;
 		killer_format = 0;
 		return;
 	}
+#ifdef DEATH_EXPLORE
+	else if (iflags.death_expl && how <= GENOCIDED && !bones_ok &&
+#ifdef WIZARD
+		 !wizard &&
+#endif
+		 !discover) {
+	  if(yn("Continue in explore mode?") == 'y') {
+	    enter_explore_mode();
+	    if (discover) goexplore = TRUE;
+	  }
+	}
+#endif /* DEATH_EXPLORE */
 
     /*
      *	The game is now over...
      */
 
 die:
+#ifdef DEATH_EXPLORE
+	if (!goexplore) {
+#endif
 	program_state.gameover = 1;
 	/* in case of a subsequent panic(), there's no point trying to save */
 	program_state.something_worth_saving = 0;
+#ifdef DUMP_LOG
+	/* D: Grab screen dump right here */
+	if (dump_fn[0]) {
+	  dump_init();
+	  Sprintf(pbuf, "%s, %s %s %s %s", plname,
+		  aligns[1 - u.ualign.type].adj,
+		  genders[flags.female].adj,
+		  urace.adj,
+		  (flags.female && urole.name.f)?
+		   urole.name.f : urole.name.m);
+	  dump("", pbuf);
+#  ifdef DUMPMSGS
+		if (lastmsg >= 0) {
+		  dump ("","");
+		  dump ("", "Latest messages");
+		  for (i = lastmsg + 1; i < DUMPMSGS; i++) {
+		    if (msgs[i] && strcmp(msgs[i], "") )
+		      dump ("  ", msgs[i]);
+		  } 
+		  for (i = 0; i <= lastmsg; i++) {
+		    if (msgs[i] && strcmp(msgs[i], "") )
+		      dump ("  ", msgs[i]);
+		  } 
+		}
+#  endif /* DUMPMSGS */
+	  /* D: Add a line for clearance from the screen dump */
+	  dump("", "");
+	  dump_screen();
+	}
+#endif /* DUMP_LOG */
+#ifdef DEATH_EXPLORE
+	}
+#endif
 	/* render vision subsystem inoperative */
 	iflags.vision_inited = 0;
 	/* might have been killed while using a disposable item, so make sure
@@ -628,6 +821,9 @@ die:
 	    pline("Do not pass go.  Do not collect 200 %s.", currency(200L));
 
 	if (have_windows) wait_synch();	/* flush screen output */
+#ifdef DEATH_EXPLORE
+	if (!goexplore) {
+#endif
 #ifndef NO_SIGNAL
 	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
 # if defined(UNIX) || defined(VMS) || defined (__EMX__)
@@ -636,7 +832,7 @@ die:
 # endif
 #endif /* NO_SIGNAL */
 
-	bones_ok = (how < GENOCIDED) && can_make_bones();
+	/* bones_ok = (how < GENOCIDED) && can_make_bones(); moved up */
 
 	if (how == TURNED_SLIME)
 	    u.ugrave_arise = PM_GREEN_SLIME;
@@ -668,6 +864,9 @@ die:
 		make_grave(u.ux, u.uy, pbuf);
 	    }
 	}
+#ifdef DEATH_EXPLORE
+	} /* if (!goexplore) */
+#endif
 
 	if (how == QUIT) {
 		killer_format = NO_KILLER_PREFIX;
@@ -688,14 +887,21 @@ die:
 	    clearpriests();
 	} else	taken = FALSE;	/* lint; assert( !bones_ok ); */
 
+#ifdef DEATH_EXPLORE
+	if (!goexplore) {
+#endif
 	clearlocks();
 
 	if (have_windows) display_nhwindow(WIN_MESSAGE, FALSE);
 
-	if (strcmp(flags.end_disclose, "none") && how != PANICKED)
+	if (strcmp(flags.end_disclose, "none") && how != PANICKED) {
 		disclose(how, taken);
+	}
 	/* finish_paybill should be called after disclosure but before bones */
 	if (bones_ok && taken) finish_paybill();
+#ifdef DEATH_EXPLORE
+	}
+#endif
 
 	/* calculate score, before creating bones [container gold] */
 	{
@@ -721,18 +927,53 @@ die:
 	    if (deepest > 20)
 		u.urexp += 1000L * (long)((deepest > 30) ? 10 : deepest - 20);
 	    if (how == ASCENDED) u.urexp *= 2L;
+#ifdef DEATH_EXPLORE
+	    if (goexplore) {
+	      discover = FALSE; /* a kludge to fool the topten function.. */
+	      topten(how);
+	      /* undo some things that were done for score calculation */
+	      /* this branch is not entered when you ascend, escape or quit */
+	      discover = TRUE;
+	      umoney -= hidden_gold();
+	      u.urexp -= tmp;
+	      u.urexp -= 50L * (long)(deepest - 1);
+	      /* now do what is done when you refuse to die in explore mode */
+	      if (u.uhpmax <= 0) u.uhpmax = u.ulevel * 8;
+	      savelife(how);
+	      killer = 0;
+	      killer_format = 0;
+	      vision_reset();
+	      return;
+	    }
+#endif
 	}
 
 	if (bones_ok) {
 #ifdef WIZARD
+# ifdef PARANOID
+	    if(wizard) {
+		getlin("Save WIZARD MODE bones? [no/yes]", paranoid_buf);
+		(void) lcase (paranoid_buf);
+		if (strcmp (paranoid_buf, "yes"))
+		  really_bon = FALSE;
+	    }
+	    if(really_bon)
+# else
 	    if (!wizard || yn("Save bones?") == 'y')
-#endif
+# endif /* PARANOID */
+#endif /* WIZARD */
 		savebones(corpse);
 	    /* corpse may be invalid pointer now so
 		ensure that it isn't used again */
 	    corpse = (struct obj *)0;
 	}
-
+#ifdef PROMPT_LOGEXP
+	if (wizard || discover) {
+	  update_log = (yn("Update logfile?") == 'y');
+	} else {
+	  update_log = TRUE;
+	}
+#endif
 	/* update gold for the rip output, which can't use hidden_gold()
 	   (containers will be gone by then if bones just got saved...) */
 #ifndef GOLDOBJ
@@ -770,15 +1011,18 @@ die:
 		/* don't bother counting to see whether it should be plural */
 	}
 
-	if (!done_stopprint) {
 	    Sprintf(pbuf, "%s %s the %s...", Goodbye(), plname,
 		   how != ASCENDED ?
 		      (const char *) ((flags.female && urole.name.f) ?
 		         urole.name.f : urole.name.m) :
 		      (const char *) (flags.female ? "Demigoddess" : "Demigod"));
+	if (!done_stopprint) {
 	    putstr(endwin, 0, pbuf);
 	    putstr(endwin, 0, "");
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) dump("", pbuf);
+#endif
 
 	if (how == ESCAPED || how == ASCENDED) {
 	    register struct monst *mtmp;
@@ -805,31 +1049,39 @@ die:
 	    keepdogs(TRUE);
 	    viz_array[0][0] |= IN_SIGHT; /* need visibility for naming */
 	    mtmp = mydogs;
-	    if (!done_stopprint) Strcpy(pbuf, "You");
+	    Strcpy(pbuf, "You");
 	    if (mtmp) {
 		while (mtmp) {
-		    if (!done_stopprint)
 			Sprintf(eos(pbuf), " and %s", mon_nam(mtmp));
 		    if (mtmp->mtame)
 			u.urexp += mtmp->mhp;
 		    mtmp = mtmp->nmon;
 		}
 		if (!done_stopprint) putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+		if (dump_fp) dump("", pbuf);
+#endif
 		pbuf[0] = '\0';
 	    } else {
 		if (!done_stopprint) Strcat(pbuf, " ");
 	    }
-	    if (!done_stopprint) {
 		Sprintf(eos(pbuf), "%s with %ld point%s,",
 			how==ASCENDED ? "went to your reward" :
 					"escaped from the dungeon",
 			u.urexp, plur(u.urexp));
+#ifdef DUMP_LOG
+	    if (dump_fp) dump("", pbuf);
+#endif
+	    if (!done_stopprint) {
 		putstr(endwin, 0, pbuf);
 	    }
 
 	    if (!done_stopprint)
 		artifact_score(invent, FALSE, endwin);	/* list artifacts */
-
+#ifdef DUMP_LOG
+	    else if (dump_fp)
+		artifact_score(invent, FALSE, WIN_ERR); /* only to dumpfile */
+#endif
 	    /* list valuables here */
 	    for (val = valuables; val->list; val++) {
 		sort_valuables(val->list, val->size);
@@ -855,10 +1107,13 @@ die:
 				count, plur(count));
 		    }
 		    putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+		    if (dump_fp) dump("", pbuf);
+#endif
 		}
 	    }
 
-	} else if (!done_stopprint) {
+	} else {
 	    /* did not escape or ascend */
 	    if (u.uz.dnum == 0 && u.uz.dlevel <= 0) {
 		/* level teleported out of the dungeon; `how' is DIED,
@@ -878,21 +1133,32 @@ die:
 
 	    Sprintf(eos(pbuf), " with %ld point%s,",
 		    u.urexp, plur(u.urexp));
-	    putstr(endwin, 0, pbuf);
+	    if (!done_stopprint) putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+	    if (dump_fp) dump("", pbuf);
+#endif
 	}
 
-	if (!done_stopprint) {
 	    Sprintf(pbuf, "and %ld piece%s of gold, after %ld move%s.",
 		    umoney, plur(umoney), moves, plur(moves));
-	    putstr(endwin, 0, pbuf);
+	if (!done_stopprint)  putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+	if (dump_fp) {
+	  dump("", pbuf);
+	  Sprintf(pbuf, "Killer: %s", killer);
+	  dump("", pbuf);
 	}
-	if (!done_stopprint) {
+#endif
 	    Sprintf(pbuf,
 	     "You were level %d with a maximum of %d hit point%s when you %s.",
 		    u.ulevel, u.uhpmax, plur(u.uhpmax), ends[how]);
+	if (!done_stopprint) {
 	    putstr(endwin, 0, pbuf);
 	    putstr(endwin, 0, "");
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) dump("", pbuf);
+#endif
 	if (!done_stopprint)
 	    display_nhwindow(endwin, TRUE);
 	if (endwin != WIN_ERR)
@@ -901,14 +1167,23 @@ die:
 	/* "So when I die, the first thing I will see in Heaven is a
 	 * score list?" */
 	if (flags.toptenwin) {
+#ifdef PROMPT_LOGEXP
+	    if (update_log)
+#endif
 	    topten(how);
 	    if (have_windows)
 		exit_nhwindows((char *)0);
 	} else {
 	    if (have_windows)
 		exit_nhwindows((char *)0);
+#ifdef PROMPT_LOGEXP
+	    if (update_log)
+#endif
 	    topten(how);
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) dump_exit();
+#endif
 
 	if(done_stopprint) { raw_print(""); raw_print(""); }
 	terminate(EXIT_SUCCESS);
@@ -919,8 +1194,23 @@ void
 container_contents(list, identified, all_containers)
 struct obj *list;
 boolean identified, all_containers;
+#ifdef DUMP_LOG
+{
+	do_containerconts(list, identified, all_containers, FALSE, TRUE);
+}
+
+void do_containerconts(list, identified, all_containers, want_dump, want_disp)
+struct obj *list;
+boolean identified, all_containers, want_dump, want_disp;
+#endif
+/* The original container_contents function */
 {
 	register struct obj *box, *obj;
+#ifdef SORTLOOT
+	struct obj **oarray;
+	int i,j,n;
+	char *invlet;
+#endif /* SORTLOOT */
 	char buf[BUFSZ];
 
 	for (box = list; box; box = box->nobj) {
@@ -928,25 +1218,101 @@ boolean identified, all_containers;
 		if (box->otyp == BAG_OF_TRICKS) {
 		    continue;	/* wrong type of container */
 		} else if (box->cobj) {
-		    winid tmpwin = create_nhwindow(NHW_MENU);
+		    winid tmpwin;
+#ifdef DUMP_LOG
+		    if (want_disp)
+#endif
+		    tmpwin = create_nhwindow(NHW_MENU);
+#ifdef SORTLOOT
+		    /* count the number of items */
+		    for (n = 0, obj = box->cobj; obj; obj = obj->nobj) n++;
+		    /* Make a temporary array to store the objects sorted */
+		    oarray = (struct obj **) alloc(n*sizeof(struct obj*));
+
+		    /* Add objects to the array */
+		    i = 0;
+		    invlet = flags.inv_order;
+		nextclass:
+		    for (obj = box->cobj; obj; obj = obj->nobj) {
+                      if (!flags.sortpack || obj->oclass == *invlet) {
+			if (iflags.sortloot == 'f'
+			    || iflags.sortloot == 'l') {
+			  /* Insert object at correct index */
+			  for (j = i; j; j--) {
+			    if (strcmpi(cxname2(obj), cxname2(oarray[j-1]))>0
+			    || (flags.sortpack &&
+				oarray[j-1]->oclass != obj->oclass))
+			      break;
+			    oarray[j] = oarray[j-1];
+			  }
+			  oarray[j] = obj;
+			  i++;
+			} else {
+			  /* Just add it to the array */
+			  oarray[i++] = obj;
+			}
+		      }
+		    } /* for loop */
+		    if (flags.sortpack) {
+		      if (*++invlet) goto nextclass;
+		    }
+#endif /* SORTLOOT */
 		    Sprintf(buf, "Contents of %s:", the(xname(box)));
+#ifdef DUMP_LOG
+		    if (want_disp) {
+#endif
 		    putstr(tmpwin, 0, buf);
 		    putstr(tmpwin, 0, "");
+#ifdef DUMP_LOG
+		    }
+		    if (dump_fp) dump("", buf);
+#endif
+#ifdef SORTLOOT
+		    for (i = 0; i < n; i++) {
+			obj = oarray[i];
+#else
 		    for (obj = box->cobj; obj; obj = obj->nobj) {
+#endif
 			if (identified) {
 			    makeknown(obj->otyp);
 			    obj->known = obj->bknown =
 			    obj->dknown = obj->rknown = 1;
 			}
+#ifdef DUMP_LOG
+			if (want_dump)  dump("  ", doname(obj));
+			if (want_disp)
+#endif
 			putstr(tmpwin, 0, doname(obj));
 		    }
+#ifdef DUMP_LOG
+		    if (want_dump)  dump("","");
+		    if (want_disp) {
+#endif
 		    display_nhwindow(tmpwin, TRUE);
 		    destroy_nhwindow(tmpwin);
-		    if (all_containers)
+#ifdef DUMP_LOG
+		    }
+		    if (all_containers) {
+			do_containerconts(box->cobj, identified, TRUE,
+					  want_dump, want_disp);
+#else
+		    if (all_containers) {
 			container_contents(box->cobj, identified, TRUE);
+#endif /* DUMP_LOG */
+		    }
 		} else {
+#ifdef DUMP_LOG
+		    if (want_disp) {
+#endif
 		    pline("%s empty.", Tobjnam(box, "are"));
 		    display_nhwindow(WIN_MESSAGE, FALSE);
+#ifdef DUMP_LOG
+		    }
+		    if (want_dump) {
+		      dump(The(xname(box)), " is empty.");
+		      dump("", "");
+		    }
+#endif
 		}
 	    }
 	    if (!all_containers)
@@ -973,10 +1339,21 @@ int status;
 	nethack_exit(status);
 }
 
-STATIC_OVL void
+void		/* showborn patch */
 list_vanquished(defquery, ask)
 char defquery;
 boolean ask;
+#ifdef DUMP_LOG
+{
+  do_vanquished(defquery, ask, FALSE);
+}
+
+void
+do_vanquished(defquery, ask, want_dump)
+int defquery;
+boolean ask;
+boolean want_dump;
+#endif
 {
     register int i, lev;
     int ntypes = 0, max_lev = 0, nkilled;
@@ -996,13 +1373,22 @@ boolean ask;
      * includes all dead monsters, not just those killed by the player
      */
     if (ntypes != 0) {
-	c = ask ? yn_function("Do you want an account of creatures vanquished?",
+#ifdef DUMP_LOG
+	c = done_stopprint ? 'n': ask ?
+#else
+	c = ask ?
+#endif
+	  yn_function("Do you want an account of creatures vanquished?",
 			      ynqchars, defquery) : defquery;
 	if (c == 'q') done_stopprint++;
 	if (c == 'y') {
 	    klwin = create_nhwindow(NHW_MENU);
 	    putstr(klwin, 0, "Vanquished creatures:");
 	    putstr(klwin, 0, "");
+#ifdef DUMP_LOG
+	} /* the original end of block removed by the patch */
+	    if (want_dump)  dump("", "Vanquished creatures");
+#endif
 
 	    /* countdown by monster "toughness" */
 	    for (lev = max_lev; lev >= 0; lev--)
@@ -1029,21 +1415,38 @@ boolean ask;
 			else
 			    Sprintf(buf, "%d %s",
 				    nkilled, makeplural(mons[i].mname));
+#ifdef SHOW_BORN
+			if (iflags.show_born && nkilled != mvitals[i].born)
+			    Sprintf(buf + strlen(buf), " (%d created)",
+				    (int) mvitals[i].born);
+#endif
 		    }
-		    putstr(klwin, 0, buf);
+		    if (c == 'y') putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		    if (want_dump)  dump("  ", buf);
+#endif
 		}
 	    /*
 	     * if (Hallucination)
 	     *     putstr(klwin, 0, "and a partridge in a pear tree");
 	     */
 	    if (ntypes > 1) {
-		putstr(klwin, 0, "");
+		if (c == 'y') putstr(klwin, 0, "");
 		Sprintf(buf, "%ld creatures vanquished.", total_killed);
-		putstr(klwin, 0, buf);
+		if (c == 'y') putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		if (want_dump)  dump("  ", buf);
+#endif
 	    }
+	    if (c == 'y') {
 	    display_nhwindow(klwin, TRUE);
 	    destroy_nhwindow(klwin);
 	}
+#ifdef DUMP_LOG
+	    if (want_dump)  dump("", "");
+#else
+	} /* the original end of if (c == 'y') */
+#endif
     }
 }
 
@@ -1059,43 +1462,112 @@ num_genocides()
     return n;
 }
 
+#ifdef DUMP_LOG
+STATIC_OVL void
+list_genocided(defquery, ask, want_dump)
+int defquery;
+boolean ask;
+boolean want_dump;
+#else
 STATIC_OVL void
 list_genocided(defquery, ask)
 char defquery;
 boolean ask;
+#endif
 {
     register int i;
-    int ngenocided;
+    int ngenocided=0;
+#ifdef SHOW_EXTINCT
+    int nextincted=0;
+#endif
     char c;
     winid klwin;
     char buf[BUFSZ];
 
+    /* get totals first */
+#ifdef SHOW_EXTINCT
+    for (i = LOW_PM; i < NUMMONS; i++) {
+	if (mvitals[i].mvflags & G_GENOD)
+	    ngenocided++;
+	else if ( (mvitals[i].mvflags & G_GONE) && !(mons[i].geno & G_UNIQ) )
+	    nextincted++;
+    }
     ngenocided = num_genocides();
+#endif
 
     /* genocided species list */
-    if (ngenocided != 0) {
+    if (ngenocided != 0
+#ifdef SHOW_EXTINCT
+      || nextincted != 0
+#endif
+    ) {
+#ifdef SHOW_EXTINCT
+	if (nextincted != 0)
+	  c = ask ?
+	  yn_function("Do you want a list of species genocided or extincted?",
+		      ynqchars, defquery) : defquery;
+       else
+#endif
 	c = ask ? yn_function("Do you want a list of species genocided?",
 			      ynqchars, defquery) : defquery;
 	if (c == 'q') done_stopprint++;
 	if (c == 'y') {
 	    klwin = create_nhwindow(NHW_MENU);
-	    putstr(klwin, 0, "Genocided species:");
+#ifdef SHOW_EXTINCT
+	    Sprintf(buf, "Genocided or extinct species:");
+#else
+	    Sprintf(buf, "Genocided species:");
+#endif
+	    putstr(klwin, 0, buf);
 	    putstr(klwin, 0, "");
+#ifdef DUMP_LOG
+	    if (want_dump)  dump("", buf);
+#endif
 
 	    for (i = LOW_PM; i < NUMMONS; i++)
+#ifdef SHOW_EXTINCT
+	      if (mvitals[i].mvflags & G_GONE && !(mons[i].geno & G_UNIQ) ){
+#else
 		if (mvitals[i].mvflags & G_GENOD) {
+#endif
 		    if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST)
 			Sprintf(buf, "%s%s",
 				!type_is_pname(&mons[i]) ? "" : "the ",
 				mons[i].mname);
 		    else
 			Strcpy(buf, makeplural(mons[i].mname));
+#ifdef SHOW_EXTINCT
+		    if( !(mvitals[i].mvflags & G_GENOD) )
+			Strcat(buf, " (extinct)");
+#endif
 		    putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		    if (want_dump)  dump("  ", buf);
+#endif
 		}
 
 	    putstr(klwin, 0, "");
+#ifdef SHOW_EXTINCT
+	    if (ngenocided>0)  {
+#endif
 	    Sprintf(buf, "%d species genocided.", ngenocided);
 	    putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+	    if (want_dump)  dump("  ", buf);
+#endif
+#ifdef SHOW_EXTINCT
+	    }
+	    if (nextincted>0) {
+		Sprintf(buf, "%d species extinct.", nextincted);
+		putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		if (want_dump) dump("  ", buf);
+#endif
+	    }
+#endif /* SHOW_EXTINCT */
+#ifdef DUMP_LOG
+	    if (want_dump)  dump("", "");
+#endif
 
 	    display_nhwindow(klwin, TRUE);
 	    destroy_nhwindow(klwin);
diff --git a/src/engrave.c b/src/engrave.c
index fe09b4f..c05f327 100644
--- a/src/engrave.c
+++ b/src/engrave.c
@@ -343,7 +343,11 @@ register int x,y;
 			et = ep->engr_txt;
 		You("%s: \"%s\".",
 		      (Blind) ? "feel the words" : "read",  et);
-		if(flags.run > 1) nomul(0);
+		if(flags.run > 1) nomul(0
+#ifdef HELPLESS
+					, 0
+#endif
+					);
 	    }
 	}
 }
diff --git a/src/explode.c b/src/explode.c
index 8671a2c..6b02c24 100644
--- a/src/explode.c
+++ b/src/explode.c
@@ -513,7 +513,11 @@ struct obj *obj;			/* only scatter this obj        */
 				if (scflags & MAY_HITYOU) {
 				    int hitvalu, hitu;
 
-				    if (multi) nomul(0);
+				    if (multi) nomul(0
+#ifdef HELPLESS
+						     , 0
+#endif
+						     );
 				    hitvalu = 8 + stmp->obj->spe;
 				    if (bigmonst(youmonst.data)) hitvalu++;
 				    hitu = thitu(hitvalu,
diff --git a/src/files.c b/src/files.c
index 023546b..bf30ff1 100644
--- a/src/files.c
+++ b/src/files.c
@@ -57,7 +57,7 @@ static char fqn_filename_buffer[FQN_NUMBUF][FQN_MAX_FILENAME];
 #endif
 
 #if !defined(MFLOPPY) && !defined(VMS) && !defined(WIN32)
-char bones[] = "bonesnn.xxx";
+char bones[] = "bones/bonesnn.xxx";
 char lock[PL_NSIZ+14] = "1lock"; /* long enough for uid+name+.99 */
 #else
 # if defined(MFLOPPY)
@@ -614,8 +614,13 @@ d_level *lev;
 	s_level *sptr;
 	char *dptr;
 
+#ifdef UNIX
+	Sprintf(file, "bones/bon%c%s", dungeons[lev->dnum].boneid,
+			In_quest(lev) ? urole.filecode : "0");
+#else
 	Sprintf(file, "bon%c%s", dungeons[lev->dnum].boneid,
 			In_quest(lev) ? urole.filecode : "0");
+#endif
 	dptr = eos(file);
 	if ((sptr = Is_special(lev)) != 0)
 	    Sprintf(dptr, ".%c", sptr->boneid);
@@ -1794,6 +1799,10 @@ char		*tmp_levels;
 	} else if (match_varname(buf, "BOULDER", 3)) {
 	    (void) get_uchars(fp, buf, bufp, &iflags.bouldersym, TRUE,
 			      1, "BOULDER");
+	} else if (match_varname(buf, "MENUCOLOR", 9)) {
+#ifdef MENU_COLOR
+	    (void) add_menu_coloring(bufp);
+#endif
 	} else if (match_varname(buf, "GRAPHICS", 4)) {
 	    len = get_uchars(fp, buf, bufp, translate, FALSE,
 			     MAXPCHARS, "GRAPHICS");
diff --git a/src/hack.c b/src/hack.c
index 0e89c3b..4c3aabb 100644
--- a/src/hack.c
+++ b/src/hack.c
@@ -72,7 +72,11 @@ moverock()
 
 	rx = u.ux + 2 * u.dx;	/* boulder destination position */
 	ry = u.uy + 2 * u.dy;
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	if (Levitation || Is_airlevel(&u.uz)) {
 	    if (Blind) feel_location(sx, sy);
 	    You("don't have enough leverage to push %s.", the(xname(otmp)));
@@ -323,7 +327,11 @@ still_chewing(x,y)
     if (!boulder && IS_ROCK(lev->typ) && !may_dig(x,y)) {
 	You("hurt your teeth on the %s.",
 	    IS_TREE(lev->typ) ? "tree" : "hard stone");
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	return 1;
     } else if (digging.pos.x != x || digging.pos.y != y ||
 		!on_level(&digging.level, &u.uz)) {
@@ -719,7 +727,11 @@ boolean guess;
 	if (test_move(u.ux, u.uy, u.tx-u.ux, u.ty-u.uy, TEST_MOVE)) {
 	    u.dx = u.tx-u.ux;
 	    u.dy = u.ty-u.uy;
-	    nomul(0);
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );
 	    iflags.travelcc.x = iflags.travelcc.y = -1;
 	    return TRUE;
 	}
@@ -785,7 +797,11 @@ boolean guess;
 				u.dx = x-ux;
 				u.dy = y-uy;
 				if (x == u.tx && y == u.ty) {
-				    nomul(0);
+				    nomul(0
+#ifdef HELPLESS
+					  , 0
+#endif
+					  );
 				    /* reset run so domove run checks work */
 				    flags.run = 8;
 				    iflags.travelcc.x = iflags.travelcc.y = -1;
@@ -855,7 +871,11 @@ boolean guess;
 found:
     u.dx = 0;
     u.dy = 0;
-    nomul(0);
+    nomul(0
+#ifdef HELPLESS
+	  , 0
+#endif
+	  );
     return FALSE;
 }
 
@@ -891,7 +911,11 @@ domove()
 		exercise(A_CON, FALSE);
 	    } else
 		You("collapse under your load.");
-	    nomul(0);
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );
 	    return;
 	}
 	if(u.uswallow) {
@@ -943,7 +967,11 @@ domove()
 
 			do {
 				if(tries++ > 50) {
-					nomul(0);
+					nomul(0
+#ifdef HELPLESS
+					      , 0
+#endif
+					      );
 					return;
 				}
 				confdir();
@@ -955,14 +983,22 @@ domove()
 		if (u.uinwater) {
 			water_friction();
 			if (!u.dx && !u.dy) {
-				nomul(0);
+				nomul(0
+#ifdef HELPLESS
+				      , 0
+#endif
+				      );
 				return;
 			}
 			x = u.ux + u.dx;
 			y = u.uy + u.dy;
 		}
 		if(!isok(x, y)) {
-			nomul(0);
+			nomul(0
+#ifdef HELPLESS
+			      , 0
+#endif
+			      );
 			return;
 		}
 		if (((trap = t_at(x, y)) && trap->tseen) ||
@@ -970,11 +1006,19 @@ domove()
 		     !is_clinger(youmonst.data) &&
 		     (is_pool(x, y) || is_lava(x, y)) && levl[x][y].seenv)) {
 			if(flags.run >= 2) {
-				nomul(0);
+				nomul(0
+#ifdef HELPLESS
+				      , 0
+#endif
+				      );
 				flags.move = 0;
 				return;
 			} else
-				nomul(0);
+				nomul(0
+#ifdef HELPLESS
+				      , 0
+#endif
+				      );
 		}
 
 		if (u.ustuck && (x != u.ustuck->mx || y != u.ustuck->my)) {
@@ -1015,7 +1059,11 @@ domove()
 				!Conflict && !u.ustuck->mconf)
 				goto pull_free;
 			    You("cannot escape from %s!", mon_nam(u.ustuck));
-			    nomul(0);
+			    nomul(0
+#ifdef HELPLESS
+				  , 0
+#endif
+				  );
 			    return;
 			}
 		    }
@@ -1031,7 +1079,11 @@ domove()
 				mtmp->m_ap_type != M_AP_OBJECT) ||
 			       Protection_from_shape_changers)) ||
 			     sensemon(mtmp))) {
-				nomul(0);
+				nomul(0
+#ifdef HELPLESS
+				      , 0
+#endif
+				      );
 				flags.move = 0;
 				return;
 			}
@@ -1046,7 +1098,11 @@ domove()
 
 	/* attack monster */
 	if(mtmp) {
-	    nomul(0);
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );
 	    /* only attack if we know it's there */
 	    /* or if we used the 'F' command to fight blindly */
 	    /* or if it hides_under, in which case we call attack() to print
@@ -1108,7 +1164,11 @@ domove()
 		    is_pool(x,y) ? "empty water" : buf);
 		unmap_object(x, y); /* known empty -- remove 'I' if present */
 		newsym(x, y);
-		nomul(0);
+		nomul(0
+#ifdef HELPLESS
+		      , 0
+#endif
+		      );
 		if (expl) {
 		    u.mh = -1;		/* dead in the current form */
 		    rehumanize();
@@ -1123,7 +1183,11 @@ domove()
 #ifdef STEED
 	if (u.usteed && !u.usteed->mcanmove && (u.dx || u.dy)) {
 		pline("%s won't move!", upstart(y_monnam(u.usteed)));
-		nomul(0);
+		nomul(0
+#ifdef HELPLESS
+		      , 0
+#endif
+		      );
 		return;
 	} else
 #endif
@@ -1131,7 +1195,11 @@ domove()
 		You("are rooted %s.",
 		    Levitation || Is_airlevel(&u.uz) || Is_waterlevel(&u.uz) ?
 		    "in place" : "to the ground");
-		nomul(0);
+		nomul(0
+#ifdef HELPLESS
+		      , 0
+#endif
+		      );
 		return;
 	}
 	if(u.utrap) {
@@ -1254,7 +1322,11 @@ domove()
 
 	if (!test_move(u.ux, u.uy, x-u.ux, y-u.uy, DO_MOVE)) {
 	    flags.move = 0;
-	    nomul(0);
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );
 	    return;
 	}
 
@@ -1370,7 +1442,11 @@ domove()
 	    if ( flags.run < 8 )
 		if (IS_DOOR(tmpr->typ) || IS_ROCK(tmpr->typ) ||
 			IS_FURNITURE(tmpr->typ))
-		    nomul(0);
+		    nomul(0
+#ifdef HELPLESS
+			  , 0
+#endif
+			  );
 	}
 
 	if (hides_under(youmonst.data))
@@ -1408,7 +1484,11 @@ domove()
 	/* delay next move because of ball dragging */
 	/* must come after we finished picking up, in spoteffects() */
 	if (cause_delay) {
-	    nomul(-2);
+	    nomul(-2
+#ifdef HELPLESS
+		  , "dragging an iron ball"
+#endif
+		  );
 	    nomovemsg = "";
 	}
 
@@ -1436,7 +1516,11 @@ invocation_message()
 	    char buf[BUFSZ];
 	    struct obj *otmp = carrying(CANDELABRUM_OF_INVOCATION);
 
-	    nomul(0);		/* stop running or travelling */
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );		/* stop running or travelling */
 #ifdef STEED
 	    if (u.usteed) Sprintf(buf, "beneath %s", y_monnam(u.usteed));
 	    else
@@ -1924,7 +2008,11 @@ lookaround()
     /* Grid bugs stop if trying to move diagonal, even if blind.  Maybe */
     /* they polymorphed while in the middle of a long move. */
     if (u.umonnum == PM_GRID_BUG && u.dx && u.dy) {
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	return;
     }
 
@@ -2001,7 +2089,11 @@ bcorr:
 	       continue;
 	}
 stop:
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	return;
     } /* end for loops */
 
@@ -2063,14 +2155,27 @@ monster_nearby()
 	return(0);
 }
 
+#ifdef HELPLESS
+void
+nomul(nval, txt)
+     register int nval;
+     const char *txt;
+#else
 void
 nomul(nval)
 	register int nval;
+#endif
 {
 	if(multi < nval) return;	/* This is a bug fix by ab@unido */
 	u.uinvulnerable = FALSE;	/* Kludge to avoid ctrl-C bug -dlc */
 	u.usleep = 0;
 	multi = nval;
+#ifdef HELPLESS
+	if (txt && txt[0])
+	  (void) strncpy(multi_txt, txt, BUFSZ);
+	else
+	  (void) memset(multi_txt, 0, BUFSZ);
+#endif
 	flags.travel = iflags.travel1 = flags.mv = flags.run = 0;
 }
 
@@ -2080,6 +2185,9 @@ unmul(msg_override)
 const char *msg_override;
 {
 	multi = 0;	/* caller will usually have done this already */
+#ifdef HELPLESS
+	(void) memset(multi_txt, 0, BUFSZ);
+#endif
 	if (msg_override) nomovemsg = msg_override;
 	else if (!nomovemsg) nomovemsg = You_can_move_again;
 	if (*nomovemsg) pline(nomovemsg);
diff --git a/src/invent.c b/src/invent.c
index b9a3683..5d4de17 100644
--- a/src/invent.c
+++ b/src/invent.c
@@ -19,7 +19,12 @@ STATIC_DCL boolean FDECL(taking_off, (const char *));
 STATIC_DCL boolean FDECL(putting_on, (const char *));
 STATIC_PTR int FDECL(ckunpaid,(struct obj *));
 STATIC_PTR int FDECL(ckvalidcat,(struct obj *));
+#ifdef DUMP_LOG
+static char FDECL(display_pickinv,
+		 (const char *,BOOLEAN_P, long *, BOOLEAN_P, BOOLEAN_P));
+#else
 static char FDECL(display_pickinv, (const char *,BOOLEAN_P, long *));
+#endif /* DUMP_LOG */
 #ifdef OVLB
 STATIC_DCL boolean FDECL(this_type_only, (struct obj *));
 STATIC_DCL void NDECL(dounpaid);
@@ -532,6 +537,11 @@ void
 freeinv(obj)
 register struct obj *obj;
 {
+#ifdef ITEMCAT_JP
+/* this is a very uncritical thing so we do it here. if the jpicklist was
+ * persistent, this should have been in extract_nobj() itself */
+        jpick_free(obj);
+#endif /* ITEMCAT_JP */
 	extract_nobj(obj, &invent);
 	freeinv_core(obj);
 	update_inventory();
@@ -1017,7 +1027,11 @@ register const char *let,*word;
 		    if (ilet == '?' && !*lets && *altlets)
 			allowed_choices = altlets;
 		    ilet = display_pickinv(allowed_choices, TRUE,
-					   allowcnt ? &ctmp : (long *)0);
+					   allowcnt ? &ctmp : (long *)0
+#ifdef DUMP_LOG
+					   , FALSE, TRUE
+#endif
+					   );
 		    if(!ilet) continue;
 		    if (allowcnt && ctmp >= 0) {
 			cnt = ctmp;
@@ -1689,13 +1703,27 @@ find_unpaid(list, last_found)
  * inventory and return a count as well as a letter. If out_cnt is not null,
  * any count returned from the menu selection is placed here.
  */
+#ifdef DUMP_LOG
+static char
+display_pickinv(lets, want_reply, out_cnt, want_dump, want_disp)
+register const char *lets;
+boolean want_reply;
+long* out_cnt;
+boolean want_dump;
+boolean want_disp;
+#else
 static char
 display_pickinv(lets, want_reply, out_cnt)
 register const char *lets;
 boolean want_reply;
 long* out_cnt;
+#endif
 {
 	struct obj *otmp;
+#ifdef SORTLOOT
+	struct obj **oarray;
+	int i, j;
+#endif
 	char ilet, ret;
 	char *invlet = flags.inv_order;
 	int n, classcount;
@@ -1704,6 +1732,9 @@ long* out_cnt;
 	anything any;
 	menu_item *selected;
 
+#ifdef DUMP_LOG
+	if (want_disp) {
+#endif
 	/* overriden by global flag */
 	if (flags.perm_invent) {
 	    win = (lets && *lets) ? local_win : WIN_INVEN;
@@ -1713,6 +1744,11 @@ long* out_cnt;
 	} else
 	    win = WIN_INVEN;
 
+#ifdef DUMP_LOG
+	}
+	if (want_dump)   dump("", "Your inventory");
+#endif
+
 	/*
 	Exit early if no inventory -- but keep going if we are doing
 	a permanent inventory update.  We need to keep going so the
@@ -1725,11 +1761,24 @@ long* out_cnt;
 	to here is short circuited away.
 	*/
 	if (!invent && !(flags.perm_invent && !lets && !want_reply)) {
+#ifdef DUMP_LOG
+	  if (want_disp) {
+#endif
 #ifndef GOLDOBJ
 	    pline("Not carrying anything%s.", u.ugold ? " except gold" : "");
 #else
 	    pline("Not carrying anything.");
 #endif
+#ifdef DUMP_LOG
+	  }
+	  if (want_dump) {
+#ifdef GOLDOBJ
+	    dump("  ", "Not carrying anything");
+#else
+	    dump("  Not carrying anything", u.ugold ? " except gold." : ".");
+#endif
+	  }
+#endif
 	    return 0;
 	}
 
@@ -1743,37 +1792,124 @@ long* out_cnt;
 	    ret = '\0';
 	    for (otmp = invent; otmp; otmp = otmp->nobj) {
 		if (otmp->invlet == lets[0]) {
+#ifdef DUMP_LOG
+		  if (want_disp) {
+#endif
 		    ret = message_menu(lets[0],
 			  want_reply ? PICK_ONE : PICK_NONE,
 			  xprname(otmp, (char *)0, lets[0], TRUE, 0L, 0L));
 		    if (out_cnt) *out_cnt = -1L;	/* select all */
+#ifdef DUMP_LOG
+		  }
+		  if (want_dump) {
+		    char letbuf[7];
+		    sprintf(letbuf, "  %c - ", lets[0]);
+		    dump(letbuf,
+			 xprname(otmp, (char *)0, lets[0], TRUE, 0L, 0L));
+		  }
+#endif
 		    break;
 		}
 	    }
 	    return ret;
 	}
 
+#ifdef SORTLOOT
+	/* count the number of items */
+	for (n = 0, otmp = invent; otmp; otmp = otmp->nobj)
+	  if(!lets || !*lets || index(lets, otmp->invlet)) n++;
+
+	/* Make a temporary array to store the objects sorted */
+	oarray = (struct obj **)alloc(n*sizeof(struct obj*));
+
+	/* Add objects to the array */
+	i = 0;
+	for(otmp = invent; otmp; otmp = otmp->nobj)
+	  if(!lets || !*lets || index(lets, otmp->invlet)) {
+	    if (iflags.sortloot == 'f') {
+	      /* Insert object at correct index */
+	      for (j = i; j; j--) {
+		if (strcmpi(cxname2(otmp), cxname2(oarray[j-1]))>0) break;
+		oarray[j] = oarray[j-1];
+	      }
+	      oarray[j] = otmp;
+	      i++;
+	    } else {
+	      /* Just add it to the array */
+	      oarray[i++] = otmp;
+	    }
+	  }
+#endif /* SORTLOOT */
+
+#ifdef DUMP_LOG
+	if (want_disp)
+#endif
 	start_menu(win);
 nextclass:
 	classcount = 0;
 	any.a_void = 0;		/* set all bits to zero */
+#ifdef SORTLOOT
+	for(i = 0; i < n; i++) {
+	  otmp = oarray[i];
+	  ilet = otmp->invlet;
+	  if (!flags.sortpack || otmp->oclass == *invlet) {
+	    if (flags.sortpack && !classcount) {
+	      any.a_void = 0;             /* zero */
+#ifdef DUMP_LOG
+	      if (want_dump)
+		dump("  ", let_to_name(*invlet, FALSE));
+	      if (want_disp)
+#endif
+	      add_menu(win, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
+		       let_to_name(*invlet, FALSE), MENU_UNSELECTED);
+	      classcount++;
+	    }
+	    any.a_char = ilet;
+#ifdef DUMP_LOG
+	    if (want_dump) {
+	      char letbuf[7];
+	      sprintf(letbuf, "  %c - ", ilet);
+	      dump(letbuf, doname(otmp));
+	    }
+	    if (want_disp)
+#endif
+	    add_menu(win, obj_to_glyph(otmp),
+		     &any, ilet, 0, ATR_NONE, doname(otmp),
+		     MENU_UNSELECTED);
+	  }
+	}
+#else /* SORTLOOT */
 	for(otmp = invent; otmp; otmp = otmp->nobj) {
 		ilet = otmp->invlet;
 		if(!lets || !*lets || index(lets, ilet)) {
 			if (!flags.sortpack || otmp->oclass == *invlet) {
 			    if (flags.sortpack && !classcount) {
 				any.a_void = 0;		/* zero */
+#ifdef DUMP_LOG
+				if (want_dump)
+				    dump("  ", let_to_name(*invlet, FALSE));
+				if (want_disp)
+#endif
 				add_menu(win, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
 				    let_to_name(*invlet, FALSE), MENU_UNSELECTED);
 				classcount++;
 			    }
 			    any.a_char = ilet;
+#ifdef DUMP_LOG
+			    if (want_dump) {
+			      char letbuf[7];
+			      sprintf(letbuf, "  %c - ", ilet);
+			      dump(letbuf, doname(otmp));
+			    }
+			    if (want_disp)
+#endif
 			    add_menu(win, obj_to_glyph(otmp),
 					&any, ilet, 0, ATR_NONE, doname(otmp),
 					MENU_UNSELECTED);
 			}
 		}
 	}
+#endif /* SORTLOOT */
 	if (flags.sortpack) {
 		if (*++invlet) goto nextclass;
 #ifdef WIZARD
@@ -1783,6 +1919,12 @@ nextclass:
 		}
 #endif
 	}
+#ifdef SORTLOOT
+	free(oarray);
+#endif
+#ifdef DUMP_LOG
+	if (want_disp) {
+#endif
 	end_menu(win, (char *) 0);
 
 	n = select_menu(win, want_reply ? PICK_ONE : PICK_NONE, &selected);
@@ -1792,6 +1934,10 @@ nextclass:
 	    free((genericptr_t)selected);
 	} else
 	    ret = !n ? '\0' : '\033';	/* cancelled */
+#ifdef DUMP_LOG
+	} /* want_disp */
+	if (want_dump)  dump("", "");
+#endif
 
 	return ret;
 }
@@ -1808,9 +1954,24 @@ display_inventory(lets, want_reply)
 register const char *lets;
 boolean want_reply;
 {
-	return display_pickinv(lets, want_reply, (long *)0);
+	return display_pickinv(lets, want_reply, (long *)0
+#ifdef DUMP_LOG
+			       , FALSE , TRUE
+#endif
+	);
 }
 
+#ifdef DUMP_LOG
+/* See display_inventory. This is the same thing WITH dumpfile creation */
+char
+dump_inventory(lets, want_reply, want_disp)
+register const char *lets;
+boolean want_reply, want_disp;
+{
+  return display_pickinv(lets, want_reply, (long *)0, TRUE, want_disp);
+}
+#endif
+
 /*
  * Returns the number of unpaid items within the given list.  This includes
  * contained objects.
@@ -1861,6 +2022,16 @@ count_buc(list, type)
 		if (list->oclass != COIN_CLASS && !list->bknown)
 		    count++;
 		break;
+#ifdef ITEMCAT
+            case UNIDENTIFIED:
+                if (NOT_FULLY_IDENTIFIED(list))
+                    count++;
+                break;
+            case RUSTPRONE:
+                if (list->oclass != COIN_CLASS && is_known_rustprone(list))
+                    count++;
+                break;
+#endif /* ITEMCAT */
 	    default:
 		impossible("need count of curse status %d?", type);
 		return 0;
@@ -2650,13 +2821,23 @@ doorganize()	/* inventory organizer by Del Lamb */
 	register char let;
 	char alphabet[52+1], buf[52+1];
 	char qbuf[QBUFSZ];
+#ifdef ADJSPLIT
+	char allowallcnt[3];
+#else
 	char allowall[2];
+#endif
 	const char *adj_type;
 
 	if (!flags.invlet_constant) reassign();
 	/* get a pointer to the object the user wants to organize */
+#ifdef ADJSPLIT
+	allowallcnt[0] = ALLOW_COUNT; allowallcnt[1] = ALL_CLASSES;
+	allowallcnt[2] = '\0';
+	if (!(obj = getobj(allowallcnt,"adjust"))) return(0);
+#else
 	allowall[0] = ALL_CLASSES; allowall[1] = '\0';
 	if (!(obj = getobj(allowall,"adjust"))) return(0);
+#endif
 
 	/* initialize the list with all upper and lower case letters */
 	for (let = 'a', ix = 0;  let <= 'z';) alphabet[ix++] = let++;
@@ -2685,7 +2866,11 @@ doorganize()	/* inventory organizer by Del Lamb */
 		let = yn_function(qbuf, (char *)0, '\0');
 		if(index(quitchars,let)) {
 			pline(Never_mind);
+#ifdef ADJSPLIT
+			goto cleansplit;
+#else
 			return(0);
+#endif
 		}
 		if (let == '@' || !letter(let))
 			pline("Select an inventory slot letter.");
@@ -2694,7 +2879,9 @@ doorganize()	/* inventory organizer by Del Lamb */
 	}
 
 	/* change the inventory and print the resulting item */
+#ifndef ADJSPLIT
 	adj_type = "Moving:";
+#endif
 
 	/*
 	 * don't use freeinv/addinv to avoid double-touching artifacts,
@@ -2702,19 +2889,56 @@ doorganize()	/* inventory organizer by Del Lamb */
 	 */
 	extract_nobj(obj, &invent);
 
+#ifdef ADJSPLIT
+	for (otmp = invent; otmp && otmp->invlet != let;)
+		otmp = otmp->nobj;
+	if (!otmp)
+		adj_type = "Moving:";
+	else if (merged(&otmp,&obj)) {
+#else
 	for (otmp = invent; otmp;)
 		if (merged(&otmp,&obj)) {
+#endif
 			adj_type = "Merging:";
 			obj = otmp;
+#ifndef ADJSPLIT
 			otmp = otmp->nobj;
+#endif
 			extract_nobj(obj, &invent);
 		} else {
+#ifdef ADJSPLIT
+		  struct obj *otmp2;
+		  for (otmp2 = invent; otmp2
+			 && otmp2->invlet != obj->invlet;)
+			otmp2 = otmp2->nobj;
+
+		  if (otmp2) {
+			char oldlet = obj->invlet;
+
+			adj_type = "Displacing:";
+
+			/* Here be a nasty hack; solutions that don't
+			 * require duplication of assigninvlet's code
+			 * here are welcome.
+			 */
+			assigninvlet(obj);
+
+			if (obj->invlet == NOINVSYM) {
+				pline("There's nowhere to put that.");
+				obj->invlet = oldlet;
+				goto cleansplit;
+			}
+		  } else
+#else
 			if (otmp->invlet == let) {
+#endif
 				adj_type = "Swapping:";
 				otmp->invlet = obj->invlet;
 			}
+#ifndef ADJSPLIT
 			otmp = otmp->nobj;
 		}
+#endif
 
 	/* inline addinv (assuming flags.invlet_constant and !merged) */
 	obj->invlet = let;
@@ -2726,6 +2950,14 @@ doorganize()	/* inventory organizer by Del Lamb */
 	prinv(adj_type, obj, 0L);
 	update_inventory();
 	return(0);
+#ifdef ADJSPLIT
+cleansplit:
+	for (otmp = invent; otmp; otmp = otmp->nobj)
+                if (otmp != obj && otmp->invlet == obj->invlet)
+                        merged( &otmp, &obj );
+
+	return 0;
+#endif
 }
 
 /* common to display_minventory and display_cinventory */
diff --git a/src/mcastu.c b/src/mcastu.c
index 93d3b8d..2dc0555 100644
--- a/src/mcastu.c
+++ b/src/mcastu.c
@@ -228,7 +228,11 @@ castmu(mtmp, mattk, thinks_it_foundyou, foundyou)
 	    return(0);
 	}
 
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	if(rn2(ml*10) < (mtmp->mconf ? 100 : 20)) {	/* fumbled attack */
 	    if (canseemon(mtmp) && flags.soundok)
 		pline_The("air crackles around %s.", mon_nam(mtmp));
@@ -600,13 +604,21 @@ int spellnum;
 	    shieldeff(u.ux, u.uy);
 	    if (multi >= 0)
 		You("stiffen briefly.");
-	    nomul(-1);
+	    nomul(-1
+#ifdef HELPLESS
+		  , "paralyzed by a monster"
+#endif
+		  );
 	} else {
 	    if (multi >= 0)
 		You("are frozen in place!");
 	    dmg = 4 + (int)mtmp->m_lev;
 	    if (Half_spell_damage) dmg = (dmg + 1) / 2;
-	    nomul(-dmg);
+	    nomul(-dmg
+#ifdef HELPLESS
+		  , "paralyzed by a monster"
+#endif
+		  );
 	}
 	dmg = 0;
 	break;
@@ -771,7 +783,11 @@ buzzmu(mtmp, mattk)		/* monster uses spell (ranged) */
 	    return(0);
 	}
 	if(lined_up(mtmp) && rn2(3)) {
-	    nomul(0);
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );
 	    if(mattk->adtyp && (mattk->adtyp < 11)) { /* no cf unsigned >0 */
 		if(canseemon(mtmp))
 		    pline("%s zaps you with a %s!", Monnam(mtmp),
diff --git a/src/mhitu.c b/src/mhitu.c
index c0711fc..4772470 100644
--- a/src/mhitu.c
+++ b/src/mhitu.c
@@ -317,7 +317,11 @@ mattacku(mtmp)
 		 * invisible, or you might be blind....
 		 */
 	
-	if(!ranged) nomul(0);
+	if(!ranged) nomul(0
+#ifdef HELPLESS
+			  , 0
+#endif
+			  );
 	if(mtmp->mhp <= 0 || (Underwater && !is_swimmer(mtmp->data)))
 	    return(0);
 
@@ -1122,7 +1126,11 @@ dopois:
 			if (Blind) You("are frozen!");
 			else You("are frozen by %s!", mon_nam(mtmp));
 			nomovemsg = 0;	/* default: "you can move again" */
-			nomul(-rnd(10));
+			nomul(-rnd(10)
+#ifdef HELPLESS
+			      , "paralyzed by a monster"
+#endif
+			      );
 			exercise(A_DEX, FALSE);
 		    }
 		}
diff --git a/src/monstr.c b/src/monstr.c
new file mode 100644
index 0000000..edf9b42
--- /dev/null
+++ b/src/monstr.c
@@ -0,0 +1,39 @@
+/* This source file is generated by 'makedefs'.  Do not edit. */
+#include "config.h"
+
+const int monstr[] = {
+ 4,  5,  6,  6,  6, 12,  2,  6,  8,  7,  8,  8,  1,  1,  2,  4,
+ 3,  5,  7,  5,  6,  7,  8,  7,  9,  9, 14,  2,  3,  8,  8,  8,
+ 3,  5,  6,  7,  7,  7,  8,  8,  8, 11,  2,  4,  5,  6,  8, 13,
+19,  3,  3,  4,  5,  7,  7,  5,  6,  8,  1,  2,  3,  4,  4,  8,
+ 9, 11,  5,  5,  5,  1,  3,  3,  4,  5,  5,  5,  7,  4,  6,  9,
+ 4,  7,  8,  9, 13, 15, 22,  1,  2,  4,  4,  4,  4,  3,  4,  7,
+ 8, 12, 14,  6,  6,  6,  4,  7,  9,  4,  6,  7,  9,  9, 10,  9,
+ 9,  9, 17,  1,  9,  5,  7, 11, 11, 12, 19, 21, 26,  2,  3,  6,
+ 7,  6,  8,  9, 13, 13, 13, 13, 13, 13, 13, 13, 13, 20, 20, 20,
+20, 20, 20, 20, 20, 20,  9, 10, 10, 10, 10,  1,  2,  2,  2,  2,
+ 2,  5,  3,  4,  5,  6,  8,  8, 10, 11, 13, 19, 13, 20, 17, 18,
+ 3,  4,  5,  6, 14, 18, 21, 29,  4,  5,  6,  6,  7,  7,  8, 10,
+ 4,  4,  4,  4,  8, 10, 13, 16,  7,  9, 11,  4,  6, 12,  8,  9,
+ 8, 14,  3,  6,  7,  9,  8, 10,  9, 12, 12, 13, 16, 12, 12, 14,
+18,  7,  8, 17, 11,  4,  6,  7,  7,  8,  9,  1,  2,  3,  3,  4,
+ 5,  7,  9,  5, 14,  4,  4,  6,  6,  7,  8, 10, 12, 15, 18, 22,
+ 2,  3,  3,  6, 12,  6,  7,  8, 11, 11, 11, 13, 15, 14, 14, 13,
+15, 30,  8, 10, 12, 14,  8, 12, 25, 34, 22, 12, 14, 11,  9,  8,
+ 8, 10, 10, 11, 11, 12, 13, 14, 15, 16, 20, 26, 31, 36, 36, 40,
+45, 53, 57, 34, 34, 34, 26,  8, 15,  5,  6,  9,  7, 10, 22,  1,
+ 2,  3,  4,  6,  7,  7, 12,  1, 12, 12, 12, 12, 12, 12, 11, 12,
+12, 12, 12, 12, 12, 12, 12, 22, 22, 22, 22, 23, 30, 30, 22, 24,
+23, 22, 23, 23, 23, 22, 23, 23, 22, 31, 23, 17, 20, 19, 19, 20,
+ 7,  7,  7,  7,  7,  8,  8,  7,  7,  7,  7,  8,  7,  8, 
+};
+
+void NDECL(monstr_init);
+
+void
+monstr_init()
+{
+    return;
+}
+
+/*monstr.c*/
diff --git a/src/mthrowu.c b/src/mthrowu.c
index 3038ced..a22a55c 100644
--- a/src/mthrowu.c
+++ b/src/mthrowu.c
@@ -324,7 +324,11 @@ m_throw(mon, x, y, dx, dy, range, obj)
 		    if (ohitmon(mtmp, singleobj, range, TRUE))
 			break;
 		} else if (bhitpos.x == u.ux && bhitpos.y == u.uy) {
-		    if (multi) nomul(0);
+		    if (multi) nomul(0
+#ifdef HELPLESS
+				     , 0
+#endif
+				     );
 
 		    if (singleobj->oclass == GEM_CLASS &&
 			    singleobj->otyp <= LAST_GEM+9 /* 9 glass colors */
@@ -608,7 +612,11 @@ struct monst *mtmp;
 	m_shot.o = STRANGE_OBJECT;
 	m_shot.s = FALSE;
 
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 }
 
 #endif /* OVL1 */
@@ -646,7 +654,11 @@ register struct attack *mattk;
 			pline("%s spits venom!", Monnam(mtmp));
 		    m_throw(mtmp, mtmp->mx, mtmp->my, sgn(tbx), sgn(tby),
 			distmin(mtmp->mx,mtmp->my,mtmp->mux,mtmp->muy), otmp);
-		    nomul(0);
+		    nomul(0
+#ifdef HELPLESS
+			  , 0
+#endif
+			  );
 		    return 0;
 		}
 	}
@@ -684,7 +696,11 @@ breamu(mtmp, mattk)			/* monster breathes at you (ranged) */
 			      breathwep[typ-1]);
 		    buzz((int) (-20 - (typ-1)), (int)mattk->damn,
 			 mtmp->mx, mtmp->my, sgn(tbx), sgn(tby));
-		    nomul(0);
+		    nomul(0
+#ifdef HELPLESS
+			  , 0
+#endif
+			  );
 		    /* breath runs out sometimes. Also, give monster some
 		     * cunning; don't breath if the player fell asleep.
 		     */
diff --git a/src/muse.c b/src/muse.c
index 86044e5..7cf1db4 100644
--- a/src/muse.c
+++ b/src/muse.c
@@ -1121,7 +1121,11 @@ register struct obj *otmp;
 			    losehp(tmp, "wand", KILLED_BY_AN);
 			} else pline_The("wand misses you.");
 			stop_occupation();
-			nomul(0);
+			nomul(0
+#ifdef HELPLESS
+			      , 0
+#endif
+			      );
 		} else if (resists_magm(mtmp)) {
 			shieldeff(mtmp->mx, mtmp->my);
 			pline("Boing!");
diff --git a/src/objnam.c b/src/objnam.c
index 2130432..94b5040 100644
--- a/src/objnam.c
+++ b/src/objnam.c
@@ -15,6 +15,9 @@ static boolean FDECL(wishymatch, (const char *,const char *,BOOLEAN_P));
 #endif
 static char *NDECL(nextobuf);
 static void FDECL(add_erosion_words, (struct obj *, char *));
+#ifdef SORTLOOT
+char * FDECL(xname2, (struct obj *, boolean));
+#endif
 
 struct Jitem {
 	int item;
@@ -233,6 +236,15 @@ boolean juice;	/* whether or not to append " juice" to the name */
 char *
 xname(obj)
 register struct obj *obj;
+#ifdef SORTLOOT
+{
+	return xname2(obj, FALSE);
+}
+char *
+xname2(obj, ignore_oquan)
+register struct obj *obj;
+boolean ignore_oquan;
+#endif
 {
 	register char *buf;
 	register int typ = obj->otyp;
@@ -469,6 +481,9 @@ register struct obj *obj;
 	default:
 		Sprintf(buf,"glorkum %d %d %d", obj->oclass, typ, obj->spe);
 	}
+#ifdef SORTLOOT
+	if (!ignore_oquan)
+#endif
 	if (obj->quan != 1L) Strcpy(buf, makeplural(buf));
 
 	if (obj->onamelth && obj->dknown) {
@@ -853,6 +868,16 @@ struct obj *obj;
 	    return corpse_xname(obj, FALSE);
 	return xname(obj);
 }
+#ifdef SORTLOOT
+char *
+cxname2(obj)
+struct obj *obj;
+{
+	if (obj->otyp == CORPSE)
+	    return corpse_xname(obj, TRUE);
+	return xname2(obj, TRUE);
+}
+#endif /* SORTLOOT */
 
 /* treat an object as fully ID'd when it might be used as reason for death */
 char *
diff --git a/src/options.c b/src/options.c
index dfb8006..9da3ea1 100644
--- a/src/options.c
+++ b/src/options.c
@@ -75,6 +75,9 @@ static struct Bool_Opt
 	{"color",         &iflags.wc_color, FALSE, SET_IN_GAME},	/*WC*/
 # endif
 	{"confirm",&flags.confirm, TRUE, SET_IN_GAME},
+#ifdef DEATH_EXPLORE
+	{"death_explore", &iflags.death_expl, FALSE, SET_IN_GAME},
+#endif
 #if defined(TERMLIB) && !defined(MAC_GRAPHICS_ENV)
 	{"DECgraphics", &iflags.DECgraphics, FALSE, SET_IN_GAME},
 #else
@@ -113,6 +116,9 @@ static struct Bool_Opt
 #endif
 	{"large_font", &iflags.obsolete, FALSE, SET_IN_FILE},	/* OBSOLETE */
 	{"legacy", &flags.legacy, TRUE, DISP_IN_GAME},
+#ifdef ITEMCAT
+	{"like_swimming", &iflags.like_swimming, FALSE, SET_IN_GAME},
+#endif /* ITEMCAT */
 	{"lit_corridor", &flags.lit_corridor, FALSE, SET_IN_GAME},
 	{"lootabc", &iflags.lootabc, FALSE, SET_IN_GAME},
 #ifdef MAC_GRAPHICS_ENV
@@ -125,6 +131,15 @@ static struct Bool_Opt
 #else
 	{"mail", (boolean *)0, TRUE, SET_IN_FILE},
 #endif
+#ifdef MENU_COLOR
+# ifdef MICRO
+	{"menucolors", &iflags.use_menu_color, TRUE,  SET_IN_GAME},
+# else
+	{"menucolors", &iflags.use_menu_color, FALSE, SET_IN_GAME},
+# endif
+#else
+	{"menucolors", (boolean *)0, FALSE, SET_IN_GAME},
+#endif
 #ifdef WIZARD
 	/* for menu debugging only*/
 	{"menu_tab_sep", &iflags.menu_tab_sep, FALSE, SET_IN_GAME},
@@ -143,11 +158,19 @@ static struct Bool_Opt
 #else
 	{"page_wait", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+#ifdef PARANOID
+	{"paranoid_hit", &iflags.paranoid_hit, FALSE, SET_IN_GAME},
+	{"paranoid_quit", &iflags.paranoid_quit, FALSE, SET_IN_GAME},
+	{"paranoid_remove", &iflags.paranoid_remove, FALSE, SET_IN_GAME},
+#endif
 	{"perm_invent", &flags.perm_invent, FALSE, SET_IN_GAME},
 	{"popup_dialog",  &iflags.wc_popup_dialog, FALSE, SET_IN_GAME},	/*WC*/
 	{"prayconfirm", &flags.prayconfirm, TRUE, SET_IN_GAME},
 	{"preload_tiles", &iflags.wc_preload_tiles, TRUE, DISP_IN_GAME},	/*WC*/
 	{"pushweapon", &flags.pushweapon, FALSE, SET_IN_GAME},
+#ifdef QUIVER_FIRED
+	{"quiver_fired", &iflags.quiver_fired, FALSE, SET_IN_GAME},
+#endif
 #if defined(MICRO) && !defined(AMIGA)
 	{"rawio", &iflags.rawio, FALSE, DISP_IN_GAME},
 #else
@@ -160,6 +183,9 @@ static struct Bool_Opt
 #else
 	{"sanity_check", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+#ifdef SHOW_BORN
+	{"showborn", &iflags.show_born, FALSE, SET_IN_GAME},
+#endif
 #ifdef EXP_ON_BOTL
 	{"showexp", &flags.showexp, FALSE, SET_IN_GAME},
 #else
@@ -193,6 +219,11 @@ static struct Bool_Opt
 #else
 	{"use_inverse",   &iflags.wc_inverse, FALSE, SET_IN_GAME},		/*WC*/
 #endif
+#ifdef WIN_EDGE
+	{"win_edge", &iflags.win_edge, FALSE, SET_IN_GAME},
+#else
+	{"win_edge", (boolean *)0, TRUE, SET_IN_FILE},
+#endif
 	{"verbose", &flags.verbose, TRUE, SET_IN_GAME},
 	{"wraptext", &iflags.wc2_wraptext, FALSE, SET_IN_GAME},
 	{(char *)0, (boolean *)0, FALSE, 0}
@@ -224,6 +255,14 @@ static struct Comp_Opt
 						SET_IN_GAME },
 	{ "dogname",  "the name of your (first) dog (e.g., dogname:Fang)",
 						PL_PSIZ, DISP_IN_GAME },
+#ifdef DUMP_LOG
+	{ "dumpfile", "where to dump data (e.g., dumpfile:/tmp/dump.nh)",
+#ifdef DUMP_FN
+						PL_PSIZ, DISP_IN_GAME },
+#else
+						PL_PSIZ, SET_IN_GAME },
+#endif
+#endif
 	{ "dungeon",  "the symbols to use in drawing the dungeon map",
 						MAXDCHARS+1, SET_IN_FILE },
 	{ "effects",  "the symbols to use in drawing special effects",
@@ -246,6 +285,9 @@ static struct Comp_Opt
 	{ "horsename", "the name of your (first) horse (e.g., horsename:Silver)",
 						PL_PSIZ, DISP_IN_GAME },
 	{ "map_mode", "map display mode under Windows", 20, DISP_IN_GAME },	/*WC*/
+#ifdef MENU_COLOR
+	{ "menucolor", "set menu colors", PL_PSIZ, SET_IN_FILE },
+#endif
 	{ "menustyle", "user interface for object selection",
 						MENUTYPELEN, SET_IN_GAME },
 	{ "menu_deselect_all", "deselect all items in a menu", 4, SET_IN_FILE },
@@ -306,6 +348,9 @@ static struct Comp_Opt
 	{ "scroll_amount", "amount to scroll map when scroll_margin is reached",
 						20, DISP_IN_GAME }, /*WC*/
 	{ "scroll_margin", "scroll map when this far from the edge", 20, DISP_IN_GAME }, /*WC*/
+#ifdef SORTLOOT
+	{ "sortloot", "sort object selection lists by description", 4, SET_IN_GAME },
+#endif
 #ifdef MSDOS
 	{ "soundcard", "type of sound card to use", 20, SET_IN_FILE },
 #endif
@@ -532,6 +577,10 @@ initoptions()
 	flags.warnlevel = 1;
 	flags.warntype = 0L;
 
+#ifdef SORTLOOT
+	iflags.sortloot = 'n';
+#endif
+
      /* assert( sizeof flags.inv_order == sizeof def_inv_order ); */
 	(void)memcpy((genericptr_t)flags.inv_order,
 		     (genericptr_t)def_inv_order, sizeof flags.inv_order);
@@ -964,6 +1013,120 @@ int bool_or_comp;	/* 0 == boolean option, 1 == compound */
 	}
 }
 
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+
+static const struct {
+   const char *name;
+   const int color;
+} colornames[] = {
+   {"black", CLR_BLACK},
+   {"red", CLR_RED},
+   {"green", CLR_GREEN},
+   {"brown", CLR_BROWN},
+   {"blue", CLR_BLUE},
+   {"magenta", CLR_MAGENTA},
+   {"cyan", CLR_CYAN},
+   {"gray", CLR_GRAY},
+   {"orange", CLR_ORANGE},
+   {"lightgreen", CLR_BRIGHT_GREEN},
+   {"yellow", CLR_YELLOW},
+   {"lightblue", CLR_BRIGHT_BLUE},
+   {"lightmagenta", CLR_BRIGHT_MAGENTA},
+   {"lightcyan", CLR_BRIGHT_CYAN},
+   {"white", CLR_WHITE}
+};
+
+static const struct {
+   const char *name;
+   const int attr;
+} attrnames[] = {
+     {"none", ATR_NONE},
+     {"bold", ATR_BOLD},
+     {"dim", ATR_DIM},
+     {"underline", ATR_ULINE},
+     {"blink", ATR_BLINK},
+     {"inverse", ATR_INVERSE}
+
+};
+
+/* parse '"regex_string"=color&attr' and add it to menucoloring */
+boolean
+add_menu_coloring(str)
+char *str;
+{
+    int i, c = NO_COLOR, a = ATR_NONE;
+    struct menucoloring *tmp;
+    char *tmps, *cs = strchr(str, '=');
+    const char *err = (char *)0;
+
+    if (!cs || !str) return FALSE;
+
+    tmps = cs;
+    tmps++;
+    while (*tmps && isspace(*tmps)) tmps++;
+
+    for (i = 0; i < SIZE(colornames); i++)
+	if (strstri(tmps, colornames[i].name) == tmps) {
+	    c = colornames[i].color;
+	    break;
+	}
+    if ((i == SIZE(colornames)) && (*tmps >= '0' && *tmps <='9'))
+	c = atoi(tmps);
+
+    if (c > 15) return FALSE;
+
+    tmps = strchr(str, '&');
+    if (tmps) {
+	tmps++;
+	while (*tmps && isspace(*tmps)) tmps++;
+	for (i = 0; i < SIZE(attrnames); i++)
+	    if (strstri(tmps, attrnames[i].name) == tmps) {
+		a = attrnames[i].attr;
+		break;
+	    }
+	if ((i == SIZE(attrnames)) && (*tmps >= '0' && *tmps <='9'))
+	    a = atoi(tmps);
+    }
+
+    *cs = '\0';
+    tmps = str;
+    if ((*tmps == '"') || (*tmps == '\'')) {
+	cs--;
+	while (isspace(*cs)) cs--;
+	if (*cs == *tmps) {
+	    *cs = '\0';
+	    tmps++;
+	}
+    }
+
+    tmp = (struct menucoloring *)alloc(sizeof(struct menucoloring));
+#ifdef MENU_COLOR_REGEX
+    tmp->match.translate = 0;
+    tmp->match.fastmap = 0;
+    tmp->match.buffer = 0;
+    tmp->match.allocated = 0;
+    tmp->match.regs_allocated = REGS_FIXED;
+    err = re_compile_pattern(tmps, strlen(tmps), &tmp->match);
+#else
+    tmp->match = (char *)alloc(strlen(tmps)+1);
+    (void) memcpy((genericptr_t)tmp->match, (genericptr_t)tmps, strlen(tmps)+1);
+#endif
+    if (err) {
+	raw_printf("\nMenucolor regex error: %s\n", err);
+	wait_synch();
+	free(tmp);
+	return FALSE;
+    } else {
+	tmp->next = menu_colorings;
+	tmp->color = c;
+	tmp->attr = a;
+	menu_colorings = tmp;
+	return TRUE;
+    }
+}
+#endif /* MENU_COLOR */
+
 void
 parseoptions(opts, tinitial, tfrom_file)
 register char *opts;
@@ -1077,6 +1240,19 @@ boolean tinitial, tfrom_file;
 		return;
 	}
 
+#ifdef DUMP_LOG
+	fullname = "dumpfile";
+	if (match_optname(opts, fullname, 3, TRUE)) {
+#ifndef DUMP_FN
+		if (negated) bad_negation(fullname, FALSE);
+		else if ((op = string_for_opt(opts, !tfrom_file)) != 0
+			&& strlen(op) > 1)
+			nmcpy(dump_fn, op, PL_PSIZ);
+#endif
+		return;
+       }
+#endif
+
 	fullname = "horsename";
 	if (match_optname(opts, fullname, 5, TRUE)) {
 		if (negated) bad_negation(fullname, FALSE);
@@ -1133,6 +1309,18 @@ boolean tinitial, tfrom_file;
 		return;
 	}
 
+	/* menucolor:"regex_string"=color */
+	fullname = "menucolor";
+	if (match_optname(opts, fullname, 9, TRUE)) {
+#ifdef MENU_COLOR
+	    if (negated) bad_negation(fullname, FALSE);
+	    else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
+		if (!add_menu_coloring(op))
+		    badoption(opts);
+#endif
+	    return;
+	}
+
 	fullname = "msghistory";
 	if (match_optname(opts, fullname, 3, TRUE)) {
 		op = string_for_env_opt(fullname, opts, negated);
@@ -1839,6 +2027,24 @@ goodfruit:
 	    return;
 	}
 
+#ifdef SORTLOOT
+	fullname = "sortloot";
+	if (match_optname(opts, fullname, 4, TRUE)) {
+		op = string_for_env_opt(fullname, opts, FALSE);
+		if (op) {
+			switch (tolower(*op)) {
+                        case 'n':
+                        case 'l':
+                        case 'f': iflags.sortloot = tolower(*op);
+				break;
+                        default:  badoption(opts);
+				return;
+			}
+		}
+		return;
+	}
+#endif /* SORTLOOT */
+
 	fullname = "suppress_alert";
 	if (match_optname(opts, fullname, 4, TRUE)) {
 		op = string_for_opt(opts, negated);
@@ -2263,6 +2469,12 @@ static NEARDATA const char *runmodes[] = {
 	"teleport", "run", "walk", "crawl"
 };
 
+#ifdef SORTLOOT
+static NEARDATA const char *sortltype[] = {
+	"none", "loot", "full"
+};
+#endif
+
 /*
  * Convert the given string of object classes to a string of default object
  * symbols.
@@ -2540,7 +2752,7 @@ boolean setinitial,setfromfile;
     boolean retval = FALSE;
     
     /* Special handling of menustyle, pickup_burden, pickup_types,
-     * disclose, runmode, msg_window, menu_headings, and number_pad options.
+     * disclose, runmode, msg_window, menu_headings, number_pad and sortloot
 #ifdef AUTOPICKUP_EXCEPTIONS
      * Also takes care of interactive autopickup_exception_handling changes.
 #endif
@@ -2761,6 +2973,26 @@ boolean setinitial,setfromfile;
         }
 	destroy_nhwindow(tmpwin);
         retval = TRUE;
+#ifdef SORTLOOT
+    } else if (!strcmp("sortloot", optname)) {
+	const char *sortl_name;
+	menu_item *sortl_pick = (menu_item *)0;
+	tmpwin = create_nhwindow(NHW_MENU);
+	start_menu(tmpwin);
+	for (i = 0; i < SIZE(sortltype); i++) {
+	    sortl_name = sortltype[i];
+	    any.a_char = *sortl_name;
+	    add_menu(tmpwin, NO_GLYPH, &any, *sortl_name, 0,
+		     ATR_NONE, sortl_name, MENU_UNSELECTED);
+	}
+	end_menu(tmpwin, "Select loot sorting type:");
+	if (select_menu(tmpwin, PICK_ONE, &sortl_pick) > 0) {
+	    iflags.sortloot = sortl_pick->item.a_char;
+	    free((genericptr_t)sortl_pick);
+	}
+	destroy_nhwindow(tmpwin);
+	retval = TRUE;
+#endif /* SORTLOOT */
     } else if (!strcmp("menu_headings", optname)) {
 	static const char *mhchoices[3] = {"bold", "inverse", "underline"};
 	const char *npletters = "biu";
@@ -2933,6 +3165,10 @@ char *buf;
 	}
 	else if (!strcmp(optname, "dogname")) 
 		Sprintf(buf, "%s", dogname[0] ? dogname : none );
+#ifdef DUMP_LOG
+	else if (!strcmp(optname, "dumpfile"))
+		Sprintf(buf, "%s", dump_fn[0] ? dump_fn: none );
+#endif
 	else if (!strcmp(optname, "dungeon"))
 		Sprintf(buf, "%s", to_be_done);
 	else if (!strcmp(optname, "effects"))
@@ -3072,6 +3308,17 @@ char *buf;
 		if (iflags.wc_scroll_margin) Sprintf(buf, "%d",iflags.wc_scroll_margin);
 		else Strcpy(buf, defopt);
 	}
+#ifdef SORTLOOT
+	else if (!strcmp(optname, "sortloot")) {
+		char *sortname = (char *)NULL;
+		for (i=0; i < SIZE(sortltype) && sortname==(char *)NULL; i++) {
+		   if (iflags.sortloot == sortltype[i][0])
+		     sortname = (char *)sortltype[i];
+		}
+		if (sortname != (char *)NULL)
+		   Sprintf(buf, "%s", sortname);
+	}
+#endif /* SORTLOOT */
 	else if (!strcmp(optname, "player_selection"))
 		Sprintf(buf, "%s", iflags.wc_player_selection ? "prompts" : "dialog");
 #ifdef MSDOS
diff --git a/src/pickup.c b/src/pickup.c
index 07be607..aa312d2 100644
--- a/src/pickup.c
+++ b/src/pickup.c
@@ -39,6 +39,14 @@ STATIC_DCL int FDECL(container_at, (int, int, BOOLEAN_P));
 STATIC_DCL boolean FDECL(able_to_loot, (int, int));
 STATIC_DCL boolean FDECL(mon_beside, (int, int));
 
+#ifdef ITEMCAT_JP
+char *ctg_justpicked="Items just Picked up";
+char *ctg_justremoved="Items just taken out";
+char **jpick_ctg=&ctg_justpicked;
+STATIC_PTR int FDECL(is_justpicked,(struct obj *));
+#define DESTROY_JPICK(j) while(*(j)) { struct jpick *next=(*(j))->next_pick; free((genericptr_t) *(j)); *(j)=next; }
+#endif
+
 /* define for query_objlist() and autopickup() */
 #define FOLLOW(curr, flags) \
     (((flags) & BY_NEXTHERE) ? (curr)->nexthere : (curr)->nobj)
@@ -87,6 +95,44 @@ boolean here;		/* flag for type of obj list linkage */
 	}
 }
 
+#ifdef ITEMCAT_JP
+/* just picked items llist */
+struct jpick {
+        struct obj *o;
+        struct jpick *next_pick;
+};
+static NEARDATA struct jpick *jpick_head=(struct jpick *)0;
+STATIC_PTR int
+is_justpicked(obj)
+register struct obj *obj;
+{
+        struct jpick *list=jpick_head;
+        while(list) {
+                if(obj==list->o)
+                        return 1;
+                list=list->next_pick;
+        }
+        return 0;
+}
+void
+jpick_free(obj)
+register struct obj *obj;
+{
+        struct jpick **p=&jpick_head;
+        struct jpick *next;
+
+        while(*p) {
+                next=(*p)->next_pick;
+                if(obj==(*p)->o) {
+                        free((genericptr_t) *p);
+                        *p=next;
+                        break;
+                }
+                p=&(*p)->next_pick;
+        }
+}
+#endif /* ITEMCAT_JP */
+
 #ifndef GOLDOBJ
 int
 collect_obj_classes(ilets, otmp, here, incl_gold, filter, itemcount)
@@ -267,7 +313,13 @@ boolean picked_some;
 
 	/* If there are objects here, take a look. */
 	if (ct) {
-	    if (flags.run) nomul(0);
+	    if (flags.run) {
+	      nomul(0
+#ifdef HELPLESS
+		    , 0
+#endif
+		    );
+	    }
 	    flush_screen(1);
 	    (void) look_here(ct, picked_some);
 	} else {
@@ -340,6 +392,19 @@ struct obj *obj;
     else if (((index(valid_menu_classes,'X') != (char *)0) &&
 	(obj->oclass != COIN_CLASS && !obj->bknown)))
 	return TRUE;
+#ifdef ITEMCAT
+    else if (((index(valid_menu_classes,'I') != (char *)0) &&
+        NOT_FULLY_IDENTIFIED(obj)))
+        return TRUE;
+    else if (((index(valid_menu_classes,'r') != (char *)0) &&
+        (obj->oclass != COIN_CLASS && is_known_rustprone(obj))))
+        return TRUE;
+#endif /* ITEMCAT */
+#ifdef ITEMCAT_JP
+    else if (((index(valid_menu_classes,'P') != (char *)0) &&
+        (is_justpicked(obj))))
+        return TRUE;
+#endif
     else
 	return FALSE;
 }
@@ -390,6 +455,9 @@ int what;		/* should be a long */
 	boolean autopickup = what > 0;
 	struct obj *objchain;
 	int traverse_how;
+#ifdef ITEMCAT_JP
+        struct jpick *jtmp=jpick_head;
+#endif
 
 	if (what < 0)		/* pick N of something */
 	    count = -what;
@@ -440,9 +508,20 @@ int what;		/* should be a long */
 		}
 
 		/* if there's anything here, stop running */
-		if (OBJ_AT(u.ux,u.uy) && flags.run && flags.run != 8 && !flags.nopick) nomul(0);
+		if (OBJ_AT(u.ux,u.uy) && flags.run
+		    && flags.run != 8 && !flags.nopick) {
+		  nomul(0
+#ifdef HELPLESS
+			, 0
+#endif
+			);
+		}
 	}
 
+#ifdef ITEMCAT_JP
+        jpick_head=(struct jpick *) 0;
+#endif
+
 	add_valid_menu_class(0);	/* reset */
 	if (!u.uswallow) {
 		objchain = level.objects[u.ux][u.uy];
@@ -528,7 +607,19 @@ menu_pickup:
 				   FALSE,
 #endif
 				   &via_menu)) {
-		    if (!via_menu) return (0);
+		    if (!via_menu)
+#ifdef ITEMCAT_JP
+                    {
+                            if(jpick_head) {
+                                    jpick_ctg=&ctg_justpicked;
+                                    DESTROY_JPICK(&jtmp)
+                            } else
+                                    jpick_head=jtmp;
+                            return (0);
+                    }
+#else
+                            return (0);
+#endif /* ITEMCAT_JP */
 		    n = query_objlist("Pick up what?",
 				  objchain,
 				  traverse_how|(selective ? 0 : INVORDER_SORT),
@@ -592,6 +683,13 @@ end_query:
 		/* see whether there's anything else here, after auto-pickup is done */
 		if (autopickup) check_here(n_picked > 0);
 	}
+#ifdef ITEMCAT_JP
+        if(jpick_head) {
+                jpick_ctg=&ctg_justpicked;
+                DESTROY_JPICK(&jtmp)
+        } else
+                jpick_head=jtmp;
+#endif
 	return (n_tried > 0);
 }
 
@@ -690,9 +788,15 @@ menu_item **pick_list;		/* return list of items picked */
 int how;			/* type of query */
 boolean FDECL((*allow), (OBJ_P));/* allow function */
 {
+#ifdef SORTLOOT
+	int i, j;
+#endif
 	int n;
 	winid win;
 	struct obj *curr, *last;
+#ifdef SORTLOOT
+	struct obj **oarray;
+#endif
 	char *pack;
 	anything any;
 	boolean printed_type_name;
@@ -717,6 +821,33 @@ boolean FDECL((*allow), (OBJ_P));/* allow function */
 	    return 1;
 	}
 
+#ifdef SORTLOOT
+	/* Make a temporary array to store the objects sorted */
+	oarray = (struct obj **)alloc(n*sizeof(struct obj*));
+
+	/* Add objects to the array */
+	i = 0;
+	for (curr = olist; curr; curr = FOLLOW(curr, qflags)) {
+	  if ((*allow)(curr)) {
+	    if (iflags.sortloot == 'f' ||
+		(iflags.sortloot == 'l' && !(qflags & USE_INVLET)))
+	      {
+		/* Insert object at correct index */
+		for (j = i; j; j--)
+		  {
+		    if (strcmpi(cxname2(curr), cxname2(oarray[j-1]))>0) break;
+		    oarray[j] = oarray[j-1];
+		  }
+		oarray[j] = curr;
+		i++;
+	      } else {
+		/* Just add it to the array */
+		oarray[i++] = curr;
+	      }
+	  }
+	}
+#endif /* SORTLOOT */
+
 	win = create_nhwindow(NHW_MENU);
 	start_menu(win);
 	any.a_obj = (struct obj *) 0;
@@ -730,7 +861,12 @@ boolean FDECL((*allow), (OBJ_P));/* allow function */
 	pack = flags.inv_order;
 	do {
 	    printed_type_name = FALSE;
+#ifdef SORTLOOT
+	    for (i = 0; i < n; i++) {
+		curr = oarray[i];
+#else /* SORTLOOT */
 	    for (curr = olist; curr; curr = FOLLOW(curr, qflags)) {
+#endif /* SORTLOOT */
 		if ((qflags & FEEL_COCKATRICE) && curr->otyp == CORPSE &&
 		     will_feel_cockatrice(curr, FALSE)) {
 			destroy_nhwindow(win);	/* stop the menu and revert */
@@ -758,6 +894,9 @@ boolean FDECL((*allow), (OBJ_P));/* allow function */
 	    pack++;
 	} while (qflags & INVORDER_SORT && *pack);
 
+#ifdef SORTLOOT
+	free(oarray);
+#endif
 	end_menu(win, qstr);
 	n = select_menu(win, how, pick_list);
 	destroy_nhwindow(win);
@@ -796,6 +935,13 @@ int how;			/* type of query */
 	boolean collected_type_name;
 	char invlet;
 	int ccount;
+#ifdef ITEMCAT
+        boolean do_unident = FALSE;
+        boolean do_rustprone = FALSE;
+#endif
+#ifdef ITEMCAT_JP
+        boolean do_justpicked = FALSE;
+#endif
 	boolean do_unpaid = FALSE;
 	boolean do_blessed = FALSE, do_cursed = FALSE, do_uncursed = FALSE,
 	    do_buc_unknown = FALSE;
@@ -821,6 +967,19 @@ int how;			/* type of query */
 	    num_buc_types++;
 	}
 
+#ifdef ITEMCAT
+        if ((qflags & UNIDENTIFIED) && count_buc(olist, UNIDENTIFIED))
+            do_unident = TRUE;
+
+        if (iflags.like_swimming && (qflags & RUSTPRONE) && count_buc(olist, RUSTPRONE))
+            do_rustprone = TRUE;
+
+#endif
+#ifdef ITEMCAT_JP
+        if ((qflags & JUSTPICKED) && jpick_head!=(struct jpick *) 0)
+            do_justpicked = TRUE;
+#endif
+
 	ccount = count_categories(olist, qflags);
 	/* no point in actually showing a menu for a single category */
 	if (ccount == 1 && !do_unpaid && num_buc_types <= 1 && !(qflags & BILLED_TYPES)) {
@@ -905,6 +1064,26 @@ int how;			/* type of query */
 			"Auto-select every item being worn" :
 			"Auto-select every item", MENU_UNSELECTED);
 	}
+#ifdef ITEMCAT_JP
+        if (do_justpicked) {
+		invlet = 'P';
+		any.a_void = 0;
+		any.a_int = 'P';
+		add_menu(win, NO_GLYPH, &any, invlet, 0, ATR_NONE,
+			*jpick_ctg,
+			MENU_UNSELECTED);
+        }
+#endif /*ITEMCAT_JP*/
+#ifdef ITEMCAT
+	if (do_unident) {
+		invlet = 'I';
+		any.a_void = 0;
+		any.a_int = 'I';
+		add_menu(win, NO_GLYPH, &any, invlet, 0, ATR_NONE,
+			"Unidentified Items",
+			MENU_UNSELECTED);
+	}
+#endif /* ITEMCAT */
 	/* items with b/u/c/unknown if there are any */
 	if (do_blessed) {
 		invlet = 'B';
@@ -935,6 +1114,16 @@ int how;			/* type of query */
 			"Items of unknown B/C/U status",
 			MENU_UNSELECTED);
 	}
+#ifdef ITEMCAT
+	if (iflags.like_swimming && do_rustprone) {
+		invlet = 'r';
+		any.a_void = 0;
+		any.a_int = 'r';
+		add_menu(win, NO_GLYPH, &any, invlet, 0, ATR_NONE,
+			"Items known to be Rustprone",
+			MENU_UNSELECTED);
+	}
+#endif /* ITEMCAT */
 	end_menu(win, qstr);
 	n = select_menu(win, how, pick_list);
 	destroy_nhwindow(win);
@@ -1301,7 +1490,13 @@ boolean telekinesis;	/* not picking it up directly by hand */
 		    obj->quan -= count;
 	    }
 	    flags.botl = 1;
-	    if (flags.run) nomul(0);
+	    if (flags.run) {
+	      nomul(0
+#ifdef HELPLESS
+		    , 0
+#endif
+		    );
+	    }
 	    return 1;
 #endif
 	} else if (obj->otyp == CORPSE) {
@@ -1373,6 +1568,9 @@ struct obj *
 pick_obj(otmp)
 struct obj *otmp;
 {
+#ifdef ITEMCAT_JP
+        struct jpick *pick;
+#endif
 	obj_extract_self(otmp);
 	if (!u.uswallow && otmp != uball && costly_spot(otmp->ox, otmp->oy)) {
 	    char saveushops[5], fakeshop[2];
@@ -1394,7 +1592,18 @@ struct obj *otmp;
 	if (otmp->no_charge)	/* only applies to objects outside invent */
 	    otmp->no_charge = 0;
 	newsym(otmp->ox, otmp->oy);
-	return addinv(otmp);	/* might merge it with other objects */
+#ifdef ITEMCAT_JP
+        otmp=addinv(otmp); /* might merge it with other objects */
+        if(otmp->oclass!=COIN_CLASS) {
+                pick=(struct jpick *) alloc(sizeof(struct jpick));
+                pick->next_pick=jpick_head;
+                pick->o=otmp;
+                jpick_head=pick;
+        }
+	return otmp;
+#else
+	return addinv(otmp);
+#endif /* ITEMCAT_JP */
 }
 
 /*
@@ -1931,6 +2140,9 @@ register struct obj *obj;
 	boolean is_gold = (obj->oclass == COIN_CLASS);
 	int res, loadlev;
 	long count;
+#ifdef ITEMCAT_JP
+        struct jpick *pick;
+#endif
 
 	if (!current_container) {
 		impossible("<out> no current_container?");
@@ -1985,6 +2197,14 @@ register struct obj *obj;
 		verbalize("You sneaky cad! Get out of here with that pick!");
 
 	otmp = addinv(obj);
+#ifdef ITEMCAT_JP
+        if(!is_gold) {
+                pick=(struct jpick *) alloc(sizeof(struct jpick));
+                pick->next_pick=jpick_head;
+                pick->o=otmp;
+                jpick_head=pick;
+        }
+#endif
 	loadlev = near_capacity();
 	prinv(loadlev ?
 	      (loadlev < MOD_ENCUMBER ?
@@ -2101,7 +2321,11 @@ register int held;
 	    (void) chest_trap(obj, HAND, FALSE);
 	    /* even if the trap fails, you've used up this turn */
 	    if (multi >= 0) {	/* in case we didn't become paralyzed */
-		nomul(-1);
+		nomul(-1
+#ifdef HELPLESS
+		      , "opening a container"
+#endif
+		      );
 		nomovemsg = "";
 	    }
 	    return 1;
@@ -2186,6 +2410,14 @@ ask_again2:
 				      FALSE,
 #endif
 				      &menu_on_request)) {
+#ifdef ITEMCAT_JP
+                        /* normally one wouldn't use traditional + itemcat_jp,
+                         * so we don't make extra checks whether something
+                         * relevant was in fact picked up, just destroy the
+                         * list for consistency. */
+                        jpick_ctg=&ctg_justremoved;
+                        DESTROY_JPICK(&jpick_head)
+#endif
 			if (askchain((struct obj **)&current_container->cobj,
 				     (one_by_one ? (char *)0 : select),
 				     allflag, out_container,
@@ -2311,14 +2543,27 @@ boolean put_in;
     menu_item *pick_list;
     int mflags, res;
     long count;
+#ifdef ITEMCAT_JP
+    struct jpick *jtmp;
+#endif
 
     if (retry) {
 	all_categories = (retry == -2);
     } else if (flags.menu_style == MENU_FULL) {
 	all_categories = FALSE;
 	Sprintf(buf,"%s what type of objects?", put_in ? putin : takeout);
-	mflags = put_in ? ALL_TYPES | BUC_ALLBKNOWN | BUC_UNKNOWN :
-		          ALL_TYPES | CHOOSE_ALL | BUC_ALLBKNOWN | BUC_UNKNOWN;
+	mflags = put_in ? ALL_TYPES | BUC_ALLBKNOWN | BUC_UNKNOWN
+#ifdef ITEMCAT_JP
+                | JUSTPICKED
+#endif
+#ifdef ITEMCAT
+                | UNIDENTIFIED | RUSTPRONE
+#endif
+                        : ALL_TYPES | CHOOSE_ALL | BUC_ALLBKNOWN | BUC_UNKNOWN
+#ifdef ITEMCAT
+                | UNIDENTIFIED | RUSTPRONE
+#endif
+        ;
 	n = query_category(buf, put_in ? invent : container->cobj,
 			   mflags, &pick_list, PICK_ANY);
 	if (!n) return 0;
@@ -2334,11 +2579,22 @@ boolean put_in;
     }
 
     if (loot_everything) {
+#ifdef ITEMCAT_JP
+        jtmp=jpick_head;
+        jpick_head=(struct jpick *) 0;
+#endif
 	for (otmp = container->cobj; otmp; otmp = otmp2) {
 	    otmp2 = otmp->nobj;
 	    res = out_container(otmp);
 	    if (res < 0) break;
 	}
+#ifdef ITEMCAT_JP
+        if(jpick_head) {
+                jpick_ctg=&ctg_justremoved;
+                DESTROY_JPICK(&jtmp)
+        } else
+                jpick_head=jtmp;
+#endif
     } else {
 	mflags = INVORDER_SORT;
 	if (put_in && flags.invlet_constant) mflags |= USE_INVLET;
@@ -2348,6 +2604,12 @@ boolean put_in;
 			  all_categories ? allow_all : allow_category);
 	if (n) {
 		n_looted = n;
+#ifdef ITEMCAT_JP
+                if(!put_in) {
+                        jtmp=jpick_head;
+                        jpick_head=(struct jpick *) 0;
+                }
+#endif
 		for (i = 0; i < n; i++) {
 		    otmp = pick_list[i].item.a_obj;
 		    count = pick_list[i].count;
@@ -2364,6 +2626,15 @@ boolean put_in;
 			break;
 		    }
 		}
+#ifdef ITEMCAT_JP
+                if(!put_in) {
+                        if(jpick_head) {
+                                jpick_ctg=&ctg_justremoved;
+                                DESTROY_JPICK(&jtmp)
+                        } else
+                                jpick_head=jtmp;
+                }
+#endif
 		free((genericptr_t)pick_list);
 	}
     }
diff --git a/src/pline.c b/src/pline.c
index 8210f8d..9a29931 100644
--- a/src/pline.c
+++ b/src/pline.c
@@ -15,6 +15,11 @@ static boolean no_repeat = FALSE;
 
 static char *FDECL(You_buf, (int));
 
+#if defined(DUMP_LOG) && defined(DUMPMSGS)
+char msgs[DUMPMSGS][BUFSZ];
+int lastmsg = -1;
+#endif
+
 /*VARARGS1*/
 /* Note that these declarations rely on knowledge of the internals
  * of the variable argument handling stuff in "tradstdc.h"
@@ -55,6 +60,12 @@ pline VA_DECL(const char *, line)
 	    Vsprintf(pbuf,line,VA_ARGS);
 	    line = pbuf;
 	}
+#if defined(DUMP_LOG) && defined(DUMPMSGS)
+	if (DUMPMSGS > 0 && !program_state.gameover) {
+	  lastmsg = (lastmsg + 1) % DUMPMSGS;
+	  strncpy(msgs[lastmsg], line, BUFSZ);
+	}
+#endif
 	if (!iflags.window_inited) {
 	    raw_print(line);
 	    return;
diff --git a/src/polyself.c b/src/polyself.c
index b051acb..64939fb 100644
--- a/src/polyself.c
+++ b/src/polyself.c
@@ -729,7 +729,11 @@ rehumanize()
 	    done(DIED);
 	}
 	if (!uarmg) selftouch("No longer petrify-resistant, you");
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 
 	flags.botl = 1;
 	vision_full_recalc = 1;
@@ -1019,7 +1023,11 @@ dogaze()
 			    nomul((u.ulevel > 6 || rn2(4)) ?
 				    -d((int)mtmp->m_lev+1,
 					    (int)mtmp->data->mattk[0].damd)
-				    : -200);
+				    : -200
+#ifdef HELPLESS
+				  , "frozen by a monster's gaze"
+#endif
+				  );
 			    return 1;
 			} else
 			    You("stiffen momentarily under %s gaze.",
diff --git a/src/potion.c b/src/potion.c
index 04abd41..2163443 100644
--- a/src/potion.c
+++ b/src/potion.c
@@ -316,7 +316,11 @@ ghost_from_bottle()
 		Hallucination ? rndmonnam() : (const char *)"ghost");
 	if(flags.verbose)
 	    You("are frightened to death, and unable to move.");
-	nomul(-3);
+	nomul(-3
+#ifdef HELPLESS
+	      , "being frightened to death"
+#endif
+	      );
 	nomovemsg = "You regain your composure.";
 }
 
@@ -603,7 +607,11 @@ peffects(otmp)
 		    else
 			Your("%s are frozen to the %s!",
 			     makeplural(body_part(FOOT)), surface(u.ux, u.uy));
-		    nomul(-(rn1(10, 25 - 12*bcsign(otmp))));
+		    nomul(-(rn1(10, 25 - 12*bcsign(otmp)))
+#ifdef HELPLESS
+			  , "frozen by a potion"
+#endif
+			  );
 		    nomovemsg = You_can_move_again;
 		    exercise(A_DEX, FALSE);
 		}
@@ -1255,7 +1263,11 @@ register struct obj *obj;
 		kn++;
 		if (!Free_action) {
 		    pline("%s seems to be holding you.", Something);
-		    nomul(-rnd(5));
+		    nomul(-rnd(5)
+#ifdef HELPLESS
+			  , "frozen by a potion"
+#endif
+			  );
 		    nomovemsg = You_can_move_again;
 		    exercise(A_DEX, FALSE);
 		} else You("stiffen momentarily.");
@@ -1264,7 +1276,11 @@ register struct obj *obj;
 		kn++;
 		if (!Free_action && !Sleep_resistance) {
 		    You_feel("rather tired.");
-		    nomul(-rnd(5));
+		    nomul(-rnd(5)
+#ifdef HELPLESS
+			  , "sleeping off a magical draught"
+#endif
+			  );
 		    nomovemsg = You_can_move_again;
 		    exercise(A_DEX, FALSE);
 		} else You("yawn.");
@@ -1539,13 +1555,22 @@ dodip()
 	here = levl[u.ux][u.uy].typ;
 	/* Is there a fountain to dip into here? */
 	if (IS_FOUNTAIN(here)) {
+#ifdef PARANOID
+		Sprintf(qbuf, "Dip %s into the fountain?", the(xname(obj)));
+		if(yn(qbuf) == 'y') {
+#else
 		if(yn("Dip it into the fountain?") == 'y') {
+#endif
 			dipfountain(obj);
 			return(1);
 		}
 	} else if (is_pool(u.ux,u.uy)) {
 		tmp = waterbody_name(u.ux,u.uy);
+#ifdef PARANOID
+		Sprintf(qbuf, "Dip %s into the %s?", the(xname(obj)), tmp);
+#else
 		Sprintf(qbuf, "Dip it into the %s?", tmp);
+#endif
 		if (yn(qbuf) == 'y') {
 		    if (Levitation) {
 			floating_above(tmp);
@@ -1562,7 +1587,12 @@ dodip()
 		}
 	}
 
+#ifdef PARANOID
+	Sprintf(qbuf, "dip %s into", the(xname(obj)));
+	if(!(potion = getobj(beverages, qbuf)))
+#else
 	if(!(potion = getobj(beverages, "dip into")))
+#endif
 		return(0);
 	if (potion == obj && potion->quan == 1L) {
 		pline("That is a potion bottle, not a Klein bottle!");
diff --git a/src/pray.c b/src/pray.c
index 0df2855..449ab8c 100644
--- a/src/pray.c
+++ b/src/pray.c
@@ -1206,7 +1206,11 @@ dosacrifice()
 		    if (sgn(u.ualign.type) == sgn(dmon->data->maligntyp))
 			dmon->mpeaceful = TRUE;
 		    You("are terrified, and unable to move.");
-		    nomul(-3);
+		    nomul(-3
+#ifdef HELPLESS
+			  , "being terrified of a demon"
+#endif
+			  );
 		} else pline_The("%s.", demonless_msg);
 	    }
 
@@ -1579,7 +1583,11 @@ dopray()
 	}
     }
 #endif
-    nomul(-3);
+    nomul(-3
+#ifdef HELPLESS
+	  , "praying"
+#endif
+	  );
     nomovemsg = "You finish your prayer.";
     afternmv = prayer_done;
 
@@ -1739,7 +1747,11 @@ doturn()
 		    }
 	    }
 	}
-	nomul(-5);
+	nomul(-5
+#ifdef HELPLESS
+	      , "trying to turn the monsters"
+#endif
+	      );
 	return(1);
 }
 
diff --git a/src/priest.c b/src/priest.c
index 5681930..d8c2e50 100644
--- a/src/priest.c
+++ b/src/priest.c
@@ -393,7 +393,11 @@ register int roomno;
 		    set_malign(mtmp);
 		    if(flags.verbose)
 			You("are frightened to death, and unable to move.");
-		    nomul(-3);
+		    nomul(-3
+#ifdef HELPLESS
+			  , "frightened to death"
+#endif
+			  );
 		    nomovemsg = "You regain your composure.";
 	       }
 	   }
diff --git a/src/role.c b/src/role.c
index c751d10..8ea9eaa 100644
--- a/src/role.c
+++ b/src/role.c
@@ -196,7 +196,11 @@ const struct Role roles[] = {
 	PM_ARCH_PRIEST, PM_ACOLYTE, PM_NALZOK,
 	PM_HUMAN_ZOMBIE, PM_WRAITH, S_ZOMBIE, S_WRAITH,
 	ART_MITRE_OF_HOLINESS,
+#ifdef PRIEST_RACES
+	MH_HUMAN|MH_ORC|MH_GNOME|MH_DWARF|MH_ELF | ROLE_MALE|ROLE_FEMALE |
+#else
 	MH_HUMAN|MH_ELF | ROLE_MALE|ROLE_FEMALE |
+#endif
 	  ROLE_LAWFUL|ROLE_NEUTRAL|ROLE_CHAOTIC,
 	/* Str Int Wis Dex Con Cha */
 	{   7,  7, 10,  7,  7,  7 },
diff --git a/src/save.c b/src/save.c
index 9291eb9..2c9a5dc 100644
--- a/src/save.c
+++ b/src/save.c
@@ -48,6 +48,10 @@ static long nulls[10];
 #define HUP
 #endif
 
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+#endif
+
 /* need to preserve these during save to avoid accessing freed memory */
 static unsigned ustuck_id = 0, usteed_id = 0;
 
@@ -57,7 +61,11 @@ dosave()
 	clear_nhwindow(WIN_MESSAGE);
 	if(yn("Really save?") == 'n') {
 		clear_nhwindow(WIN_MESSAGE);
-		if(multi > 0) nomul(0);
+		if(multi > 0) nomul(0
+#ifdef HELPLESS
+				    , 0
+#endif
+				    );
 	} else {
 		clear_nhwindow(WIN_MESSAGE);
 		pline("Saving...");
@@ -953,12 +961,34 @@ free_dungeons()
 	return;
 }
 
+#ifdef MENU_COLOR
+void
+free_menu_coloring()
+{
+    struct menucoloring *tmp = menu_colorings;
+
+    while (tmp) {
+	struct menucoloring *tmp2 = tmp->next;
+# ifdef MENU_COLOR_REGEX
+	(void) regfree(&tmp->match);
+# else
+	free(tmp->match);
+# endif
+	free(tmp);
+	tmp = tmp2;
+    }
+}
+#endif /* MENU_COLOR */
+
 void
 freedynamicdata()
 {
 	unload_qtlist();
 	free_invbuf();	/* let_to_name (invent.c) */
 	free_youbuf();	/* You_buf,&c (pline.c) */
+#ifdef MENU_COLOR
+	free_menu_coloring();
+#endif
 	tmp_at(DISP_FREEMEM, 0);	/* temporary display effects */
 #ifdef FREE_ALL_MEMORY
 # define freeobjchn(X)	(saveobjchn(0, X, FREE_SAVE),  X = 0)
diff --git a/src/shk.c b/src/shk.c
index 53c868b..296d43f 100644
--- a/src/shk.c
+++ b/src/shk.c
@@ -833,6 +833,12 @@ register struct obj *obj, *merge;
 #endif
 		}
 	}
+
+	/* fix for C343-218, C343-275 and C343-276 */
+	if (obj == uwep) uwepgone();
+	if (obj == uswapwep) uswapwepgone();
+	if (obj == uquiver) uqwepgone();
+
 	dealloc_obj(obj);
 }
 #endif /* OVLB */
diff --git a/src/sounds.c b/src/sounds.c
index ebd51aa..7e9ff7e 100644
--- a/src/sounds.c
+++ b/src/sounds.c
@@ -325,7 +325,11 @@ register struct monst *mtmp;
 	growl_verb = growl_sound(mtmp);
     if (growl_verb) {
 	pline("%s %s!", Monnam(mtmp), vtense((char *)0, growl_verb));
-	if(flags.run) nomul(0);
+	if(flags.run) nomul(0
+#ifdef HELPLESS
+			    , 0
+#endif
+			    );
 	wake_nearto(mtmp->mx, mtmp->my, mtmp->data->mlevel * 18);
     }
 }
@@ -366,7 +370,11 @@ register struct monst *mtmp;
     }
     if (yelp_verb) {
 	pline("%s %s!", Monnam(mtmp), vtense((char *)0, yelp_verb));
-	if(flags.run) nomul(0);
+	if(flags.run) nomul(0
+#ifdef HELPLESS
+			    , 0
+#endif
+			    );
 	wake_nearto(mtmp->mx, mtmp->my, mtmp->data->mlevel * 12);
     }
 }
@@ -398,7 +406,11 @@ register struct monst *mtmp;
     }
     if (whimper_verb) {
 	pline("%s %s.", Monnam(mtmp), vtense((char *)0, whimper_verb));
-	if(flags.run) nomul(0);
+	if(flags.run) nomul(0
+#ifdef HELPLESS
+			    , 0
+#endif
+			    );
 	wake_nearto(mtmp->mx, mtmp->my, mtmp->data->mlevel * 6);
     }
 }
@@ -627,7 +639,11 @@ register struct monst *mtmp;
 	case MS_BONES:
 	    pline("%s rattles noisily.", Monnam(mtmp));
 	    You("freeze for a moment.");
-	    nomul(-2);
+	    nomul(-2
+#ifdef HELPLESS
+		  , "scared by rattling"
+#endif
+		  );
 	    break;
 	case MS_LAUGH:
 	    {
diff --git a/src/spell.c b/src/spell.c
index 4659cfa..c0f478b 100644
--- a/src/spell.c
+++ b/src/spell.c
@@ -325,7 +325,11 @@ learn()
 	if (Confusion) {		/* became confused while learning */
 	    (void) confused_book(book);
 	    book = 0;			/* no longer studying */
-	    nomul(delay);		/* remaining delay is uninterrupted */
+	    nomul(delay
+#ifdef HELPLESS
+		  , "reading a book"
+#endif
+		  );		/* remaining delay is uninterrupted */
 	    delay = 0;
 	    return(0);
 	}
@@ -463,7 +467,11 @@ register struct obj *spellbook;
 		if (too_hard) {
 		    boolean gone = cursed_book(spellbook);
 
-		    nomul(delay);			/* study time */
+		    nomul(delay
+#ifdef HELPLESS
+			  , "reading a book"
+#endif
+			  );			/* study time */
 		    delay = 0;
 		    if(gone || !rn2(3)) {
 			if (!gone) pline_The("spellbook crumbles to dust!");
@@ -478,7 +486,11 @@ register struct obj *spellbook;
 		    if (!confused_book(spellbook)) {
 			spellbook->in_use = FALSE;
 		    }
-		    nomul(delay);
+		    nomul(delay
+#ifdef HELPLESS
+			  , "reading a book"
+#endif
+			  );
 		    delay = 0;
 		    return(1);
 		}
@@ -1114,6 +1126,35 @@ int *spell_no;
 	return FALSE;
 }
 
+#ifdef DUMP_LOG
+void 
+dump_spells()
+{
+	int i;
+	char buf[BUFSZ];
+
+	if (spellid(0) == NO_SPELL) {
+	    dump("", "You didn't know any spells.");
+	    dump("", "");
+	    return;
+	}
+	dump("", "Spells known in the end");
+
+	Sprintf(buf, "%-20s   Level    %-12s Fail", "    Name", "Category");
+	dump("  ",buf);
+	for (i = 0; i < MAXSPELL && spellid(i) != NO_SPELL; i++) {
+		Sprintf(buf, "%c - %-20s  %2d%s   %-12s %3d%%",
+			spellet(i), spellname(i), spellev(i),
+			spellknow(i) ? " " : "*",
+			spelltypemnemonic(spell_skilltype(spellid(i))),
+			100 - percent_success(i));
+		dump("  ", buf);
+	}
+	dump("","");
+
+} /* dump_spells */
+#endif
+
 /* Integer square root function without using floating point. */
 STATIC_OVL int
 isqrt(val)
diff --git a/src/steal.c b/src/steal.c
index 1feed77..0a55c22 100644
--- a/src/steal.c
+++ b/src/steal.c
@@ -382,7 +382,11 @@ gotobj:
 				  equipname(otmp));
 			named++;
 			/* the following is to set multi for later on */
-			nomul(-armordelay);
+			nomul(-armordelay
+#ifdef HELPLESS
+			      , "taking off clothes"
+#endif
+			      );
 			remove_worn_item(otmp, TRUE);
 			otmp->cursed = curssv;
 			if(multi < 0){
diff --git a/src/teleport.c b/src/teleport.c
index c913e3c..219c8af 100644
--- a/src/teleport.c
+++ b/src/teleport.c
@@ -326,7 +326,11 @@ boolean allow_drag;
 	newsym(u.ux0,u.uy0);
 	see_monsters();
 	vision_full_recalc = 1;
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 	vision_recalc(0);	/* vision before effects */
 	spoteffects(TRUE);
 	invocation_message();
diff --git a/src/timeout.c b/src/timeout.c
index 6a336d6..13eb4eb 100644
--- a/src/timeout.c
+++ b/src/timeout.c
@@ -35,7 +35,11 @@ stoned_dialogue()
 	if (i == 5L)
 		HFast = 0L;
 	if (i == 3L)
-		nomul(-3);
+		nomul(-3
+#ifdef HELPLESS
+		      , "getting stoned"
+#endif
+		      );
 	exercise(A_DEX, FALSE);
 }
 
@@ -137,7 +141,11 @@ slime_dialogue()
 	if (i == 3L) {	/* limbs becoming oozy */
 	    HFast = 0L;	/* lose intrinsic speed */
 	    stop_occupation();
-	    if (multi > 0) nomul(0);
+	    if (multi > 0) nomul(0
+#ifdef HELPLESS
+				 , 0
+#endif
+				 );
 	}
 	exercise(A_DEX, FALSE);
 }
@@ -327,7 +335,11 @@ nh_timeout()
 			/* otherwise handle fumbling msgs locally. */
 			if (u.umoved && !Levitation) {
 			    slip_or_trip();
-			    nomul(-2);
+			    nomul(-2
+#ifdef HELPLESS
+				  , "fumbling"
+#endif
+				  );
 			    nomovemsg = "";
 			    /* The more you are carrying the more likely you
 			     * are to make noise when you fumble.  Adjustments
@@ -362,7 +374,11 @@ int how_long;
 boolean wakeup_msg;
 {
 	stop_occupation();
-	nomul(how_long);
+	nomul(how_long
+#ifdef HELPLESS
+	      , "sleeping"
+#endif
+	      );
 	/* generally don't notice sounds while sleeping */
 	if (wakeup_msg && multi == how_long) {
 	    /* caller can follow with a direct call to Hear_again() if
@@ -1220,7 +1236,11 @@ do_storms()
 	pline("Kaboom!!!  Boom!!  Boom!!");
 	if(!u.uinvulnerable) {
 	    stop_occupation();
-	    nomul(-3);
+	    nomul(-3
+#ifdef HELPLESS
+		  , "hiding from thunderstorm"
+#endif
+		  );
 	}
     } else
 	You_hear("a rumbling noise.");
diff --git a/src/topten.c b/src/topten.c
index 19a0488..0627461 100644
--- a/src/topten.c
+++ b/src/topten.c
@@ -31,14 +31,14 @@ static long final_fpos;
 #define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
 #define dealloc_ttentry(ttent) free((genericptr_t) (ttent))
 #define NAMSZ	10
-#define DTHSZ	100
+#define DTHSZ	132
 #define ROLESZ   3
 #define PERSMAX	 3		/* entries per name/uid per char. allowed */
 #define POINTSMIN	1	/* must be > 0 */
 #define ENTRYMAX	100	/* must be >= 10 */
 
 #if !defined(MICRO) && !defined(MAC) && !defined(WIN32)
-#define PERS_IS_UID		/* delete for PERSMAX per name; now per uid */
+/*#define PERS_IS_UID*/		/* delete for PERSMAX per name; now per uid */
 #endif
 struct toptenentry {
 	struct toptenentry *tt_next;
@@ -252,6 +252,7 @@ int how;
 	FILE *rfile;
 	register int flg = 0;
 	boolean t0_used;
+	char buf[15];
 #ifdef LOGFILE
 	FILE *lfile;
 #endif /* LOGFILE */
@@ -331,6 +332,16 @@ int how;
 			(void) strncat(t0->death, killer, DTHSZ);
 			break;
 	}
+#ifdef LOG_MOVES
+	/* jl 08.2000 - 09.2003 */
+	sprintf(buf," {%ld}",moves);
+	if (strlen(t0->death) + strlen(buf) < DTHSZ)
+	    Strcat(t0->death, buf);
+	if (wizard && strlen(t0->death) < DTHSZ - 6)
+	    Strcat(t0->death, " {wiz}");
+	if (discover && strlen(t0->death) < DTHSZ - 6)
+	    Strcat(t0->death, " {exp}");
+#endif
 	t0->birthdate = yyyymmdd(u.ubirthday);
 	t0->deathdate = yyyymmdd((time_t)0L);
 	t0->tt_next = 0;
@@ -358,9 +369,29 @@ int how;
 	      "Since you were in %s mode, the score list will not be checked.",
 		    wizard ? "wizard" : "discover");
 		topten_print(pbuf);
+#ifdef DUMP_LOG
+		if (dump_fn[0]) {
+		  dump("", pbuf);
+		  dump("", "");
+		}
+#endif
 	    }
 	    goto showwin;
 	}
+#ifdef FORGET_QUITTER
+	if (how == QUIT) {
+	    char pbuf[]="Since you quit, the score list will not be checked.";
+	    topten_print("");
+	    topten_print(pbuf);
+#ifdef DUMP_LOG
+	    if (dump_fn) {
+		dump("", "");
+		dump("", pbuf);
+	    }
+#endif
+	    goto showwin;
+	}
+#endif
 
 	if (!lock_file(RECORD, SCOREPREFIX, 60))
 		goto destroywin;
@@ -378,6 +409,9 @@ int how;
 	}
 
 	HUP topten_print("");
+#ifdef DUMP_LOG
+	dump("", "");
+#endif
 
 	/* assure minimum number of points */
 	if(t0->points < POINTSMIN) t0->points = 0;
@@ -422,6 +456,10 @@ int how;
 				    t1->points);
 			    topten_print(pbuf);
 			    topten_print("");
+#ifdef DUMP_LOG
+			    dump("", pbuf);
+			    dump("", "");
+#endif
 			}
 		    }
 		    if(occ_cnt < 0) {
@@ -452,17 +490,27 @@ int how;
 			goto destroywin;
 		}
 #endif	/* UPDATE_RECORD_IN_PLACE */
-		if(!done_stopprint) if(rank0 > 0){
-		    if(rank0 <= 10)
+		if(rank0 > 0){
+		    if(rank0 <= 10) {
+			if(!done_stopprint) 
 			topten_print("You made the top ten list!");
-		    else {
+#ifdef DUMP_LOG
+			dump("", "You made the top ten list!");
+#endif
+		    } else {
 			char pbuf[BUFSZ];
 			Sprintf(pbuf,
 			  "You reached the %d%s place on the top %d list.",
 				rank0, ordin(rank0), ENTRYMAX);
-			topten_print(pbuf);
+			if(!done_stopprint) topten_print(pbuf);
+#ifdef DUMP_LOG
+			dump("", pbuf);
+#endif
 		    }
-		    topten_print("");
+		    if(!done_stopprint) topten_print("");
+#ifdef DUMP_LOG
+		    dump("", "");
+#endif
 		}
 	}
 	if(rank0 == 0) rank0 = rank1;
@@ -475,7 +523,7 @@ int how;
 		    && rank >= rank0
 #endif
 		) writeentry(rfile, t1);
-	    if (done_stopprint) continue;
+	    /* if (done_stopprint) continue; */
 	    if (rank > flags.end_top &&
 		    (rank < rank0 - flags.end_around ||
 		     rank > rank0 + flags.end_around) &&
@@ -488,8 +536,12 @@ int how;
 		)) continue;
 	    if (rank == rank0 - flags.end_around &&
 		    rank0 > flags.end_top + flags.end_around + 1 &&
-		    !flags.end_own)
-		topten_print("");
+		    !flags.end_own) {
+		if(!done_stopprint) topten_print("");
+#ifdef DUMP_LOG
+		dump("", "");
+#endif
+	    }
 	    if(rank != rank0)
 		outentry(rank, t1, FALSE);
 	    else if(!rank1)
@@ -546,7 +598,10 @@ outheader()
 	bp = eos(linebuf);
 	while(bp < linebuf + COLNO - 9) *bp++ = ' ';
 	Strcpy(bp, "Hp [max]");
-	topten_print(linebuf);
+	if(!done_stopprint) topten_print(linebuf);
+#ifdef DUMP_LOG
+	dump("", linebuf);
+#endif
 }
 
 /* so>0: standout line; so=0: ordinary line */
@@ -664,9 +719,16 @@ boolean so;
 	    if (so) {
 		while (bp < linebuf + (COLNO-1)) *bp++ = ' ';
 		*bp = 0;
-		topten_print_bold(linebuf);
-	    } else
-		topten_print(linebuf);
+		if(!done_stopprint) topten_print_bold(linebuf);
+#ifdef DUMP_LOG
+		dump("*", linebuf[0]==' '? linebuf+1: linebuf);
+#endif
+	    } else {
+		if(!done_stopprint) topten_print(linebuf);
+#ifdef DUMP_LOG
+		dump(" ", linebuf[0]==' '? linebuf+1: linebuf);
+#endif
+	    }
 	    Sprintf(linebuf, "%15s %s", "", linebuf3);
 	    lngr = strlen(linebuf);
 	}
@@ -688,9 +750,12 @@ boolean so;
 	    if (so >= COLNO) so = COLNO-1;
 	    while (bp < linebuf + so) *bp++ = ' ';
 	    *bp = 0;
-	    topten_print_bold(linebuf);
+	    if(!done_stopprint) topten_print_bold(linebuf);
 	} else
-	    topten_print(linebuf);
+	    if(!done_stopprint) topten_print(linebuf);
+#ifdef DUMP_LOG
+	dump(" ", linebuf[0]==' '? linebuf+1: linebuf);
+#endif
 }
 
 STATIC_OVL int
diff --git a/src/trap.c b/src/trap.c
index d336276..0f55bf6 100644
--- a/src/trap.c
+++ b/src/trap.c
@@ -591,7 +591,11 @@ unsigned trflags;
 	boolean webmsgok = (!(trflags & NOWEBMSG));
 	boolean forcebungle = (trflags & FORCEBUNGLE);
 
-	nomul(0);
+	nomul(0
+#ifdef HELPLESS
+	      , 0
+#endif
+	      );
 
 	/* KMH -- You can't escape the Sokoban level traps */
 	if (In_sokoban(&u.uz) &&
@@ -1415,7 +1419,11 @@ int style;
 				break;
 			}
 		} else if (bhitpos.x == u.ux && bhitpos.y == u.uy) {
-			if (multi) nomul(0);
+			if (multi) nomul(0
+#ifdef HELPLESS
+					 , 0
+#endif
+					 );
 			if (thitu(9 + singleobj->spe,
 				  dmgval(singleobj, &youmonst),
 				  singleobj, (char *)0))
@@ -2678,12 +2686,15 @@ xchar x, y;
     return retval;
 }
 
-void
+/* returns TRUE if obj is destroyed */
+boolean
 water_damage(obj, force, here)
 register struct obj *obj;
 register boolean force, here;
 {
 	struct obj *otmp;
+	struct obj *obj_original = obj;
+	boolean obj_destroyed = FALSE;
 
 	/* Scrolls, spellbooks, potions, weapons and
 	   pieces of armor may get affected by the water */
@@ -2724,6 +2735,7 @@ register boolean force, here;
 				/* damage player/monster? */
 				pline("A potion explodes!");
 				delobj(obj);
+				obj_destroyed = (obj == obj_original);
 				continue;
 			} else if (obj->odiluted) {
 				obj->otyp = POT_WATER;
@@ -2740,7 +2752,9 @@ register boolean force, here;
 			   (uarmc->cursed && !rn2(3)))
 				obj->oeroded++;
 		}
+		obj_destroyed = FALSE;
 	}
+	return obj_destroyed;
 }
 
 /*
@@ -3741,7 +3755,11 @@ boolean disarm;
 		case 3:
 			if (!Free_action) {                        
 			pline("Suddenly you are frozen in place!");
-			nomul(-d(5, 6));
+			nomul(-d(5, 6)
+#ifdef HELPLESS
+			      , "frozen by a trap"
+#endif
+			      );
 			exercise(A_DEX, FALSE);
 			nomovemsg = You_can_move_again;
 			} else You("momentarily stiffen.");
diff --git a/src/uhitm.c b/src/uhitm.c
index 3dd028a..ce9501f 100644
--- a/src/uhitm.c
+++ b/src/uhitm.c
@@ -99,6 +99,9 @@ register struct monst *mtmp;
 struct obj *wep;	/* uwep for attack(), null for kick_monster() */
 {
 	char qbuf[QBUFSZ];
+#ifdef PARANOID
+	char buf[BUFSZ];
+#endif
 
 	/* if you're close enough to attack, alert any waiting monster */
 	mtmp->mstrategy &= ~STRAT_WAITMASK;
@@ -199,11 +202,26 @@ struct obj *wep;	/* uwep for attack(), null for kick_monster() */
 			return(FALSE);
 		}
 		if (canspotmon(mtmp)) {
+#ifdef PARANOID
+			Sprintf(qbuf, "Really attack %s? [no/yes]",
+				mon_nam(mtmp));
+			if (iflags.paranoid_hit) {
+				getlin (qbuf, buf);
+				(void) lcase (buf);
+				if (strcmp (buf, "yes")) {
+				  flags.move = 0;
+				  return(TRUE);
+				}
+			} else {
+#endif
 			Sprintf(qbuf, "Really attack %s?", mon_nam(mtmp));
 			if (yn(qbuf) != 'y') {
 				flags.move = 0;
 				return(TRUE);
 			}
+#ifdef PARANOID
+			}
+#endif
 		}
 	}
 
@@ -1813,7 +1831,11 @@ register struct attack *mattk;
 				 */
 				You("digest %s.", mon_nam(mdef));
 				if (Slow_digestion) tmp *= 2;
-				nomul(-tmp);
+				nomul(-tmp
+#ifdef HELPLESS
+				      , "digesting something"
+#endif
+				      );
 				nomovemsg = msgbuf;
 			    } else pline("%s", msgbuf);
 			    if (mdef->data == &mons[PM_GREEN_SLIME]) {
@@ -2267,7 +2289,11 @@ uchar aatyp;
 			else {
 			    You("are frozen by %s gaze!",
 				  s_suffix(mon_nam(mon)));
-			    nomul((ACURR(A_WIS) > 12 || rn2(4)) ? -tmp : -127);
+			    nomul((ACURR(A_WIS) > 12 || rn2(4)) ? -tmp : -127
+#ifdef HELPLESS
+				  , "frozen by a monster's gaze"
+#endif
+				  );
 			}
 		    } else {
 			pline("%s cannot defend itself.",
@@ -2279,7 +2305,11 @@ uchar aatyp;
 		} else { /* gelatinous cube */
 		    You("are frozen by %s!", mon_nam(mon));
 	    	    nomovemsg = 0;	/* default: "you can move again" */
-		    nomul(-tmp);
+		    nomul(-tmp
+#ifdef HELPLESS
+			  , "frozen by a monster"
+#endif
+			  );
 		    exercise(A_DEX, FALSE);
 		}
 		break;
diff --git a/src/vault.c b/src/vault.c
index 8f8b27e..5fdd2c4 100644
--- a/src/vault.c
+++ b/src/vault.c
@@ -260,7 +260,14 @@ fnd:
 	}
 
 	stop_occupation();		/* if occupied, stop it *now* */
-	if (multi > 0) { nomul(0); unmul((char *)0); }
+	if (multi > 0) {
+	  nomul(0
+#ifdef HELPLESS
+		, 0
+#endif
+		);
+	  unmul((char *)0);
+	}
 	trycount = 5;
 	do {
 	    getlin("\"Hello stranger, who are you?\" -", buf);
diff --git a/src/version.c b/src/version.c
index b35475c..181a192 100644
--- a/src/version.c
+++ b/src/version.c
@@ -16,6 +16,9 @@
 
 /* #define BETA_INFO "" */	/* "[ beta n]" */
 
+/* Don't store SCORE_ON_BOTL option in save file or bones */
+#define HIDDEN_FEATURES (1L << 21)
+
 /* fill buffer with short version (so caller can avoid including date.h) */
 char *
 version_string(buf)
@@ -70,6 +73,11 @@ struct version_info *version_data;
 const char *filename;
 boolean complain;
 {
+	boolean check=TRUE;
+#ifdef HIDDEN_FEATURES
+	unsigned long true_features = version_data->feature_set;
+	version_data->feature_set &= ~HIDDEN_FEATURES;
+#endif
 	if (
 #ifdef VERSION_COMPATIBILITY
 	    version_data->incarnation < VERSION_COMPATIBILITY ||
@@ -80,7 +88,7 @@ boolean complain;
 	  ) {
 	    if (complain)
 		pline("Version mismatch for file \"%s\".", filename);
-	    return FALSE;
+	    check = FALSE;
 	} else if (
 #ifndef IGNORED_FEATURES
 		   version_data->feature_set != VERSION_FEATURES ||
@@ -93,9 +101,12 @@ boolean complain;
 	    if (complain)
 		pline("Configuration incompatibility for file \"%s\".",
 		      filename);
-	    return FALSE;
+	    check = FALSE;
 	}
-	return TRUE;
+#ifdef HIDDEN_FEATURES
+	version_data->feature_set = true_features;
+#endif
+	return check;
 }
 
 /* this used to be based on file date and somewhat OS-dependant,
@@ -130,7 +141,11 @@ store_version(fd)
 int fd;
 {
 	const static struct version_info version_data = {
+#ifdef HIDDEN_FEATURES
+			VERSION_NUMBER, VERSION_FEATURES & ~HIDDEN_FEATURES,
+#else
 			VERSION_NUMBER, VERSION_FEATURES,
+#endif
 			VERSION_SANITY1, VERSION_SANITY2
 	};
 
diff --git a/src/vis_tab.c b/src/vis_tab.c
new file mode 100644
index 0000000..2721e88
--- /dev/null
+++ b/src/vis_tab.c
@@ -0,0 +1,8 @@
+/* This source file is generated by 'makedefs'.  Do not edit. */
+#include "config.h"
+#ifdef VISION_TABLES
+#include "vis_tab.h"
+
+#endif /* VISION_TABLES */
+
+/*vis_tab.c*/
diff --git a/src/weapon.c b/src/weapon.c
index a595df7..c314893 100644
--- a/src/weapon.c
+++ b/src/weapon.c
@@ -9,6 +9,10 @@
  */
 #include "hack.h"
 
+#ifdef DUMP_LOG
+STATIC_DCL int FDECL(enhance_skill, (boolean));
+#endif
+
 /* Categories whose names don't come from OBJ_NAME(objects[type])
  */
 #define PN_BARE_HANDED			(-1)	/* includes martial arts */
@@ -851,6 +855,23 @@ const static struct skill_range {
  */
 int
 enhance_weapon_skill()
+#ifdef DUMP_LOG
+{
+	return enhance_skill(FALSE);
+}
+
+void dump_weapon_skill()
+{
+	enhance_skill(TRUE);
+}
+
+int enhance_skill(boolean want_dump)
+/* This is the original enhance_weapon_skill() function slightly modified
+ * to write the skills to the dump file. I added the wrapper functions just
+ * because it looked like the easiest way to add a parameter to the
+ * function call. - Jukka Lahtinen, August 2001
+ */
+#endif
 {
     int pass, i, n, len, longest,
 	to_advance, eventually_advance, maxxed_cnt;
@@ -860,8 +881,15 @@ enhance_weapon_skill()
     anything any;
     winid win;
     boolean speedy = FALSE;
+#ifdef DUMP_LOG
+    char buf2[BUFSZ];
+    boolean logged;
+#endif
 
 #ifdef WIZARD
+#ifdef DUMP_LOG
+	if (!want_dump)
+#endif
 	if (wizard && yn("Advance skills without practice?") == 'y')
 	    speedy = TRUE;
 #endif
@@ -878,6 +906,11 @@ enhance_weapon_skill()
 		else if (peaked_skill(i)) maxxed_cnt++;
 	    }
 
+#ifdef DUMP_LOG
+	    if (want_dump)
+		dump("","Your skills at the end");
+	    else {
+#endif
 	    win = create_nhwindow(NHW_MENU);
 	    start_menu(win);
 
@@ -905,6 +938,9 @@ enhance_weapon_skill()
 		add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE,
 			     "", MENU_UNSELECTED);
 	    }
+#ifdef DUMP_LOG
+	    } /* want_dump or not */
+#endif
 
 	    /* List the skills, making ones that could be advanced
 	       selectable.  List the miscellaneous skills first.
@@ -916,8 +952,26 @@ enhance_weapon_skill()
 		/* Print headings for skill types */
 		any.a_void = 0;
 		if (i == skill_ranges[pass].first)
+#ifdef DUMP_LOG
+		if (want_dump) {
+		    dump("  ",(char *)skill_ranges[pass].name);
+		    logged=FALSE;
+		} else
+#endif
 		    add_menu(win, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
 			     skill_ranges[pass].name, MENU_UNSELECTED);
+#ifdef DUMP_LOG
+		if (want_dump) {
+		    if (P_SKILL(i) > P_UNSKILLED) {
+		 	Sprintf(buf2,"%-*s [%s]",
+			    longest, P_NAME(i),skill_level_name(i, buf));
+			dump("    ",buf2);
+			logged=TRUE;
+		    } else if (i == skill_ranges[pass].last && !logged) {
+			dump("    ","(none)");
+		    }
+               } else {
+#endif
 
 		if (P_RESTRICTED(i)) continue;
 		/*
@@ -962,6 +1016,9 @@ enhance_weapon_skill()
 		any.a_int = can_advance(i, speedy) ? i+1 : 0;
 		add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE,
 			 buf, MENU_UNSELECTED);
+#ifdef DUMP_LOG
+		} /* !want_dump */
+#endif
 	    }
 
 	    Strcpy(buf, (to_advance > 0) ? "Pick a skill to advance:" :
@@ -971,6 +1028,12 @@ enhance_weapon_skill()
 		Sprintf(eos(buf), "  (%d slot%s available)",
 			u.weapon_slots, plur(u.weapon_slots));
 #endif
+#ifdef DUMP_LOG
+	    if (want_dump) {
+		dump("","");
+		n=0;
+	    } else {
+#endif
 	    end_menu(win, buf);
 	    n = select_menu(win, to_advance ? PICK_ONE : PICK_NONE, &selected);
 	    destroy_nhwindow(win);
@@ -987,6 +1050,9 @@ enhance_weapon_skill()
 		    }
 		}
 	    }
+#ifdef DUMP_LOG
+	    }
+#endif
 	} while (speedy && n > 0);
 	return 0;
 }
diff --git a/src/worm.c b/src/worm.c
index 0380e3f..ecab99a 100644
--- a/src/worm.c
+++ b/src/worm.c
@@ -303,6 +303,23 @@ wormhitu(worm)
 	    (void) mattacku(worm);
 }
 
+/*  cutoff()
+ *
+ *  Remove the tail of a worm and adjust the hp of the worm.
+ */
+void
+cutoff(worm, tail)
+    struct monst *worm;
+    struct wseg *tail;
+{
+	if (flags.mon_moving)
+	    pline("Part of the tail of %s is cut off.", mon_nam(worm));
+	else
+	    You("cut part of the tail off of %s.", mon_nam(worm));
+	toss_wsegs(tail, TRUE);
+	if (worm->mhp > 1) worm->mhp /= 2;
+}
+
 /*  cutworm()
  *
  *  Check for mon->wormno before calling this function!
@@ -368,17 +385,15 @@ cutworm(worm, x, y, weap)
 
     /* Sometimes the tail end dies. */
     if (rn2(3) || !(new_wnum = get_wormno())) {
-	if (flags.mon_moving)
-	    pline("Part of the tail of %s is cut off.", mon_nam(worm));
-	else
-	    You("cut part of the tail off of %s.", mon_nam(worm));
-	toss_wsegs(new_tail, TRUE);
-	if (worm->mhp > 1) worm->mhp /= 2;
+	cutoff(worm, new_tail);
 	return;
     }
 
     remove_monster(x, y);		/* clone_mon puts new head here */
-    new_worm = clone_mon(worm, x, y);
+    if (!(new_worm = clone_mon(worm, x, y))) {
+	cutoff(worm, new_tail);
+	return;
+    }
     new_worm->wormno = new_wnum;	/* affix new worm number */
 
     /* Devalue the monster level of both halves of the worm. */
diff --git a/src/zap.c b/src/zap.c
index 991c429..d6ab6c9 100644
--- a/src/zap.c
+++ b/src/zap.c
@@ -2467,7 +2467,7 @@ register struct	obj	*obj;
 	    } else if (u.dz) {
 		disclose = zap_updown(obj);
 	    } else {
-		(void) bhit(u.dx,u.dy, rn1(8,6),ZAPPED_WAND, bhitm,bhito, obj);
+		(void) bhit(u.dx,u.dy, rn1(8,6),ZAPPED_WAND, bhitm,bhito, obj, NULL);
 	    }
 	    /* give a clue if obj_zapped */
 	    if (obj_zapped)
@@ -2615,16 +2615,18 @@ register struct monst *mtmp;
  *  one is revealed for a weapon, but if not a weapon is left up to fhitm().
  */
 struct monst *
-bhit(ddx,ddy,range,weapon,fhitm,fhito,obj)
+bhit(ddx,ddy,range,weapon,fhitm,fhito,obj,obj_destroyed)
 register int ddx,ddy,range;		/* direction and range */
 int weapon;				/* see values in hack.h */
 int FDECL((*fhitm), (MONST_P, OBJ_P)),	/* fns called when mon/obj hit */
     FDECL((*fhito), (OBJ_P, OBJ_P));
 struct obj *obj;			/* object tossed/used */
+boolean *obj_destroyed;			/* has object been deallocated? Pointer to boolean, may be NULL */
 {
 	struct monst *mtmp;
 	uchar typ;
 	boolean shopdoor = FALSE, point_blank = TRUE;
+	if (obj_destroyed) { *obj_destroyed = FALSE; }
 
 	if (weapon == KICKED_WEAPON) {
 	    /* object starts one square in front of player */
@@ -2668,6 +2670,7 @@ struct obj *obj;			/* object tossed/used */
 		    hits_bars(&obj, x - ddx, y - ddy,
 			      point_blank ? 0 : !rn2(5), 1)) {
 		/* caveat: obj might now be null... */
+		if (obj == NULL && obj_destroyed) { *obj_destroyed = TRUE; }
 		bhitpos.x -= ddx;
 		bhitpos.y -= ddy;
 		break;
@@ -3436,7 +3439,11 @@ register int dx,dy;
 		miss(fltxt,mon);
 	    }
 	} else if (sx == u.ux && sy == u.uy && range >= 0) {
-	    nomul(0);
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );
 #ifdef STEED
 	    if (u.usteed && !rn2(3) && !mon_reflects(u.usteed, (char *)0)) {
 		    mon = u.usteed;
@@ -3466,7 +3473,11 @@ register int dx,dy;
 		if (!Blind) Your(vision_clears);
 	    }
 	    stop_occupation();
-	    nomul(0);
+	    nomul(0
+#ifdef HELPLESS
+		  , 0
+#endif
+		  );
 	}
 
 	if(!ZAP_POS(lev->typ) || (closed_door(sx, sy) && (range >= 0))) {
diff --git a/sys/share/pcunix.c b/sys/share/pcunix.c
index 1f1149e..e6cf9fe 100644
--- a/sys/share/pcunix.c
+++ b/sys/share/pcunix.c
@@ -8,11 +8,11 @@
 #include "wintty.h"
 
 #include	<sys/stat.h>
-#if defined(WIN32) || defined(MSDOS)
+#if defined(WIN32) || defined(MSDOS) || defined(PC_LOCKING)
 #include	<errno.h>
 #endif
 
-#if defined(WIN32) || defined(MSDOS)
+#if defined(WIN32) || defined(MSDOS) || defined(PC_LOCKING)
 extern char orgdir[];
 # ifdef WIN32
 extern void NDECL(backsp);
diff --git a/sys/unix/Makefile.top b/sys/unix/Makefile.top
index 2f11c35..450ff65 100644
--- a/sys/unix/Makefile.top
+++ b/sys/unix/Makefile.top
@@ -234,12 +234,12 @@ install: $(GAME) recover $(VARDAT) dungeon spec_levs
 # set up the directories
 # not all mkdirs have -p; those that don't will create a -p directory
 	-mkdir -p $(SHELLDIR)
-	-rm -rf $(GAMEDIR) $(VARDIR)
-	-mkdir -p $(GAMEDIR) $(VARDIR) $(VARDIR)/save
+#	-rm -rf $(GAMEDIR) $(VARDIR)
+	-mkdir -p $(GAMEDIR) $(VARDIR) $(VARDIR)/save $(VARDIR)/bones
 	-rmdir ./-p
-	-$(CHOWN) $(GAMEUID) $(GAMEDIR) $(VARDIR) $(VARDIR)/save
-	$(CHGRP) $(GAMEGRP) $(GAMEDIR) $(VARDIR) $(VARDIR)/save
-	chmod $(DIRPERM) $(GAMEDIR) $(VARDIR) $(VARDIR)/save
+	-$(CHOWN) $(GAMEUID) $(GAMEDIR) $(VARDIR) $(VARDIR)/save $(VARDIR)/bones
+	$(CHGRP) $(GAMEGRP) $(GAMEDIR) $(VARDIR) $(VARDIR)/save $(VARDIR)/bones
+	chmod $(DIRPERM) $(GAMEDIR) $(VARDIR) $(VARDIR)/save $(VARDIR)/bones
 # set up the game files
 	( $(MAKE) dofiles )
 # set up some additional files
diff --git a/sys/unix/nethack.sh b/sys/unix/nethack.sh
index 600e1da..575edba 100644
--- a/sys/unix/nethack.sh
+++ b/sys/unix/nethack.sh
@@ -63,6 +63,14 @@ case $1 in
 		exec $HACK "$@"
 		;;
 	*)
-		exec $HACK "$@" $MAXNROFPLAYERS
+#		Alt key as 'meta'
+		if [ "$TERM" == "linux" ]
+			then setmetamode meta > /dev/null
+		fi
+		$HACK "$@" $MAXNROFPLAYERS
+#		Change alt key back
+		if [ "$TERM" == "linux" ]
+			then setmetamode esc > /dev/null
+		fi
 		;;
 esac
diff --git a/sys/unix/unixmain.c b/sys/unix/unixmain.c
index a13514f..ba2588b 100644
--- a/sys/unix/unixmain.c
+++ b/sys/unix/unixmain.c
@@ -262,6 +262,7 @@ char *argv[];
 #endif
 		check_special_room(FALSE);
 		wd_message();
+		save_currentstate();
 
 		if (discover || wizard) {
 			if(yn("Do you want to keep the save file?") == 'n')
diff --git a/util/Makefile b/util/Makefile
new file mode 100644
index 0000000..e2936a8
--- /dev/null
+++ b/util/Makefile
@@ -0,0 +1,403 @@
+#	Makefile for NetHack's utility programs.
+#	SCCS Id: @(#)Makefile.utl	3.4	1997/04/19
+
+# newer makes predefine $(MAKE) to 'make' and do smarter processing of
+# recursive make calls if $(MAKE) is used
+# these makes allow $(MAKE) to be overridden by the environment if someone
+# wants to (or has to) use something other than the standard make, so we do
+# not want to unconditionally set $(MAKE) here
+#
+# unfortunately, some older makes do not predefine $(MAKE); if you have one of
+# these, uncomment the following line
+# (you will know that you have one if you get complaints about unable to
+# execute things like 'foo.o')
+# MAKE = make
+
+# if you are using gcc as your compiler,
+#	uncomment the CC definition below if it's not in your environment
+# CC = gcc
+#
+#	For Bull DPX/2 systems at B.O.S. 2.0 or higher use the following:
+#
+# CC = gcc -ansi -D_BULL_SOURCE -D_XOPEN_SOURCE -D_POSIX_SOURCE
+# 
+#	If you are using GCC 2.2.2 or higher on a DPX/2, just use:
+#
+# CC = gcc -ansi
+#
+#	For HP/UX 10.20 with GCC:
+# CC = gcc -D_POSIX_SOURCE
+#
+# if your make doesn't define a default SHELL properly, you may need
+#    the line below (Atari users will need a bourne work-alike)
+# SHELL = /bin/sh
+# for Atari
+# SHELL=E:/GEMINI2/MUPFEL.TTP
+
+# flags may have to be changed as required
+# flags for 286 Xenix:
+# CFLAGS = -Ml2t16 -O -LARGE -I../include
+# LFLAGS = -Ml -F 4000 -SEG 512
+
+# flags for 286 Microport SysV-AT
+# CFLAGS = -DDUMB -Ml -I../include
+# LFLAGS = -Ml
+
+# flags for Atari GCC (3.2.1)
+# CFLAGS = -O -I../include
+# LFLAGS = -s
+# flags for Atari GCC (3.3)
+# CFLAGS = -mshort -O2 -I../include
+# LFLAGS = -mshort -s
+
+# flags for Apollos using their native cc
+# (as long as it claims to be __STDC__ but isn't)
+# CFLAGS = -DAPOLLO -O -I../include
+
+# flags for AIX 3.1 cc on IBM RS/6000 to define
+# a suitable subset of standard libraries
+# (note that there is more info regarding the "-qchars=signed"
+# switch in file Install.unx note 8)
+# CFLAGS = -D_NO_PROTO -D_XOPEN_SOURCE -O -I../include -qchars=signed
+# and for AIX 3.2:
+# CFLAGS = -D_NO_PROTO -D_XOPEN_SOURCE -D_ALL_SOURCE -O -I../include -qchars=signed
+
+# flags for A/UX 2.01 using native cc or c89
+# gcc predefines AUX so that's not needed there
+# CFLAGS = -ZS -D_POSIX_SOURCE -O -I../include -DAUX
+
+# flags for IRIX 4.0.x using native cc
+# SGI cc 3.10 will fail to compile makedefs with -O
+# CFLAGS = -I../include -D__STDC__ -woff 100,293
+
+# flags for Linux
+#   compile normally
+# CFLAGS = -O2 -fomit-frame-pointer -I../include
+# LFLAGS = -L/usr/X11R6/lib
+#   OR compile backwards compatible a.out format
+# CFLAGS = -O2 -b i486-linuxaout -fomit-frame-pointer -I../include
+# LFLAGS = -b i486-linuxaout -L/usr/X11R6/lib
+
+# flags for BeOS using the command line
+# remember to uncomment flex and bison below
+#   BeOS on a Mac/BeBox:
+#CC = mwcc
+#CFLAGS = -I../include
+#   BeOS on Intel:
+# the default values are fine
+
+# flags for debugging:
+# CFLAGS = -g -I../include
+
+CFLAGS = -O -I../include
+LFLAGS =
+
+LIBS =
+ 
+# If you are cross-compiling, you must use this:
+#OBJDIR = .
+# otherwise, you can save a little bit of disk space with this:
+OBJDIR = ../src
+
+# yacc/lex programs to use to generate *_comp.h, *_lex.c, and *_yacc.c.
+# if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
+YACC     = yacc
+LEX      = lex
+# YACC     = bison -y
+# YACC     = byacc
+# LEX      = flex
+ 
+# these are the names of the output files from YACC/LEX. Under MS-DOS
+# and similar systems, they may differ
+YTABC = y.tab.c
+YTABH = y.tab.h
+LEXYYC = lex.yy.c
+# YTABC = y_tab.c
+# YTABH = y_tab.h
+# LEXYYC = lexyy.c
+
+
+
+# ----------------------------------------
+#
+# Nothing below this line should have to be changed.
+
+# timestamps for primary header files, matching src/Makefile
+CONFIG_H = ../src/config.h-t
+HACK_H	 = ../src/hack.h-t
+
+# utility .c files
+MAKESRC = makedefs.c
+SPLEVSRC = lev_yacc.c lev_lex.c lev_main.c
+DGNCOMPSRC = dgn_yacc.c dgn_lex.c dgn_main.c
+RECOVSRC = recover.c
+DLBSRC = dlb_main.c
+UTILSRCS = $(MAKESRC) panic.c $(SPLEVSRC) $(DGNCOMPSRC) $(RECOVSRC) $(DLBSRC)
+
+# files that define all monsters and objects
+CMONOBJ = ../src/monst.c ../src/objects.c
+OMONOBJ = $(OBJDIR)/monst.o $(OBJDIR)/objects.o
+# files that provide access to NetHack's names
+CNAMING = ../src/drawing.c ../src/decl.c $(CMONOBJ)
+ONAMING = $(OBJDIR)/drawing.o $(OBJDIR)/decl.o $(OMONOBJ)
+# dynamic memory allocation
+CALLOC = ../src/alloc.c panic.c
+OALLOC = $(OBJDIR)/alloc.o panic.o
+
+# object files for makedefs
+MAKEOBJS = makedefs.o $(OMONOBJ)
+
+# object files for special levels compiler
+SPLEVOBJS = lev_yacc.o lev_lex.o lev_main.o $(OALLOC) $(ONAMING)
+
+# object files for dungeon compiler
+DGNCOMPOBJS = dgn_yacc.o dgn_lex.o dgn_main.o $(OALLOC)
+
+# object files for recovery utility
+RECOVOBJS = recover.o
+
+# object files for the data librarian
+DLBOBJS = dlb_main.o $(OBJDIR)/dlb.o $(OALLOC)
+
+# flags for creating distribution versions of sys/share/*_lex.c, using
+# a more portable flex skeleton, which is not included in the distribution.
+# hopefully keeping this out of the section to be edited will keep too
+# many people from being confused by it...
+# FLEXDIST = -L -S../sys/share/flexhack.skl
+FLEXDIST =
+#
+# flags for creating distribution versions of sys/share/*_yacc.c, without
+# line numbers so patches from version to version are practical
+# YACCDIST = -l
+YACCDIST =
+
+
+#	dependencies for makedefs
+#
+makedefs:	$(MAKEOBJS)
+	$(CC) $(LFLAGS) -o makedefs $(MAKEOBJS)
+
+makedefs.o: makedefs.c $(CONFIG_H) ../include/permonst.h \
+		../include/objclass.h ../include/monsym.h \
+		../include/artilist.h ../include/dungeon.h ../include/obj.h \
+		../include/monst.h ../include/you.h ../include/flag.h \
+		../include/dlb.h ../include/patchlevel.h ../include/qtext.h
+
+../include/onames.h: makedefs
+	./makedefs -o
+../include/pm.h: makedefs
+	./makedefs -p
+../src/monstr.c: makedefs
+	./makedefs -m
+../include/vis_tab.h: makedefs
+	./makedefs -z
+# makedefs -z makes both vis_tab.h and vis_tab.c, but writes the .h first
+../src/vis_tab.c: ../include/vis_tab.h
+
+lintdefs:
+	@lint -axbh -I../include -DLINT $(MAKESRC) $(CMONOBJ) | sed '/_flsbuf/d'
+
+
+# we defer this makedefs call to the src Makefile, since it knows all about
+# the main src and include files date.h is a timestamp for
+../include/date.h::
+	@( cd ../src ; $(MAKE) ../include/date.h )
+
+# support code used by several of the utility programs (but not makedefs)
+panic.o:     panic.c $(CONFIG_H)
+
+
+#	dependencies for lev_comp
+#
+lev_comp:  $(SPLEVOBJS)
+	$(CC) $(LFLAGS) -o lev_comp $(SPLEVOBJS) $(LIBS)
+
+lev_yacc.o:  lev_yacc.c $(HACK_H) ../include/sp_lev.h
+lev_main.o:  lev_main.c $(HACK_H) ../include/sp_lev.h ../include/tcap.h \
+		../include/date.h
+
+# see lev_comp.l for WEIRD_LEX discussion
+# egrep will return failure if it doesn't find anything, but we know there
+# is one "_cplusplus" inside a comment
+lev_lex.o:   lev_lex.c $(HACK_H) ../include/lev_comp.h ../include/sp_lev.h
+	@echo $(CC) -c $(CFLAGS) lev_lex.c
+	@$(CC) -c $(CFLAGS) -DWEIRD_LEX=`egrep -c _cplusplus lev_lex.c` lev_lex.c
+
+../include/lev_comp.h: lev_yacc.c
+
+lev_yacc.c: lev_comp.y
+	$(YACC) $(YACCDIST) -d lev_comp.y
+	mv $(YTABC) lev_yacc.c
+	mv $(YTABH) ../include/lev_comp.h
+
+lev_lex.c: lev_comp.l
+	$(LEX) $(FLEXDIST) lev_comp.l
+	mv $(LEXYYC) lev_lex.c
+
+# with all of extern.h's functions to complain about, we drown in
+# 'defined but not used' without -u
+lintlev:
+	@lint -axhu -I../include -DLINT $(SPLEVSRC) $(CALLOC) $(CNAMING) | sed '/_flsbuf/d'
+
+
+#	dependencies for dgn_comp
+#
+dgn_comp:  $(DGNCOMPOBJS)
+	$(CC) $(LFLAGS) -o dgn_comp $(DGNCOMPOBJS) $(LIBS)
+
+dgn_yacc.o:  dgn_yacc.c $(CONFIG_H) ../include/dgn_file.h ../include/date.h
+dgn_main.o:  dgn_main.c $(CONFIG_H) ../include/dlb.h
+
+# see dgn_comp.l for WEIRD_LEX discussion
+dgn_lex.o:   dgn_lex.c $(CONFIG.H) ../include/dgn_comp.h ../include/dgn_file.h
+	@echo $(CC) -c $(CFLAGS) dgn_lex.c
+	@$(CC) -c $(CFLAGS) -DWEIRD_LEX=`egrep -c _cplusplus dgn_lex.c` dgn_lex.c
+
+
+../include/dgn_comp.h: dgn_yacc.c
+
+dgn_yacc.c: dgn_comp.y
+	$(YACC) $(YACCDIST) -d dgn_comp.y
+	mv $(YTABC) dgn_yacc.c
+	mv $(YTABH) ../include/dgn_comp.h
+
+dgn_lex.c: dgn_comp.l
+	$(LEX) $(FLEXDIST) dgn_comp.l
+	mv $(LEXYYC) dgn_lex.c
+
+# with all of extern.h's functions to complain about, we drown in
+# 'defined but not used' without -u
+lintdgn:
+	@lint -axhu -I../include -DLINT $(DGNCOMPSRC) $(CALLOC) | sed '/_flsbuf/d'
+
+
+#	dependencies for recover
+#
+recover: $(RECOVOBJS)
+	$(CC) $(LFLAGS) -o recover $(RECOVOBJS) $(LIBS)
+
+recover.o: recover.c $(CONFIG_H) ../include/date.h
+
+
+#	dependencies for dlb
+#
+dlb:	$(DLBOBJS)
+	$(CC) $(LFLAGS) -o dlb $(DLBOBJS) $(LIBS)
+
+dlb_main.o: dlb_main.c $(CONFIG_H) ../include/dlb.h ../include/date.h
+	$(CC) $(CFLAGS) -c dlb_main.c
+
+
+
+#	dependencies for tile utilities
+#
+TEXT_IO = tiletext.o tiletxt.o $(ONAMING)
+GIFREADERS = gifread.o $(OALLOC)
+PPMWRITERS = ppmwrite.o $(OALLOC)
+
+tileutils: tilemap gif2txt txt2ppm tile2x11
+
+gif2txt: $(GIFREADERS) $(TEXT_IO)
+	$(CC) $(LFLAGS) -o gif2txt $(GIFREADERS) $(TEXT_IO) $(LIBS)
+txt2ppm: $(PPMWRITERS) $(TEXT_IO)
+	$(CC) $(LFLAGS) -o txt2ppm $(PPMWRITERS) $(TEXT_IO) $(LIBS)
+
+tile2x11: tile2x11.o $(TEXT_IO)
+	$(CC) $(LFLAGS) -o tile2x11 tile2x11.o $(TEXT_IO) $(LIBS)
+
+tile2img.ttp: tile2img.o bitmfile.o $(TEXT_IO)
+	$(CC) $(LFLAGS) -o tile2img.ttp tile2img.o bitmfile.o $(TEXT_IO) $(LIBS)
+
+tile2bmp: tile2bmp.o $(TEXT_IO)
+	$(CC) $(LFLAGS) -o tile2bmp tile2bmp.o $(TEXT_IO)
+
+xpm2img.ttp: xpm2img.o bitmfile.o
+	$(CC) $(LFLAGS) -o xpm2img.ttp xpm2img.o bitmfile.o $(LIBS)
+
+tile2beos: tile2beos.o $(TEXT_IO)
+	$(CC) $(LFLAGS) -o tile2beos tile2beos.o $(TEXT_IO) -lbe
+
+tilemap: ../win/share/tilemap.c $(HACK_H)
+	$(CC) $(CFLAGS) $(LFLAGS) -o tilemap ../win/share/tilemap.c $(LIBS)
+../src/tile.c: tilemap
+	./tilemap
+
+../include/tile.h: ../win/share/tile.h
+	cp ../win/share/tile.h ../include/tile.h
+tiletext.o: ../win/share/tiletext.c $(CONFIG_H) ../include/tile.h
+	$(CC) $(CFLAGS) -c ../win/share/tiletext.c
+tiletxt.o: ../win/share/tilemap.c $(HACK_H)
+	$(CC) $(CFLAGS) -c -DTILETEXT ../win/share/tilemap.c
+	mv tilemap.o tiletxt.o
+
+gifread.o: ../win/share/gifread.c $(CONFIG_H) ../include/tile.h
+	$(CC) $(CFLAGS) -c ../win/share/gifread.c
+ppmwrite.o: ../win/share/ppmwrite.c $(CONFIG_H) ../include/tile.h
+	$(CC) $(CFLAGS) -c ../win/share/ppmwrite.c
+
+tile2bmp.o: ../win/share/tile2bmp.c $(HACK_H) ../include/tile.h
+	$(CC) $(CFLAGS) -c ../win/share/tile2bmp.c
+
+tile2x11.o: ../win/X11/tile2x11.c $(HACK_H) ../include/tile.h \
+						../include/tile2x11.h
+	$(CC) $(CFLAGS) -c ../win/X11/tile2x11.c
+
+tile2img.o: ../win/gem/tile2img.c $(HACK_H) ../include/tile.h \
+						../include/bitmfile.h
+	$(CC) $(CFLAGS) -c ../win/gem/tile2img.c
+xpm2img.o: ../win/gem/xpm2img.c $(HACK_H) ../include/bitmfile.h
+	$(CC) $(CFLAGS) -c ../win/gem/xpm2img.c
+bitmfile.o: ../win/gem/bitmfile.c ../include/bitmfile.h
+	$(CC) $(CFLAGS) -c ../win/gem/bitmfile.c
+
+tile2beos.o: ../win/BeOS/tile2beos.cpp $(HACK_H) ../include/tile.h
+	$(CXX) $(CFLAGS) -c ../win/BeOS/tile2beos.cpp
+
+# using dependencies like
+#	../src/foo::
+#		@( cd ../src ; $(MAKE) foo )
+# would always force foo to be up-to-date according to the src Makefile
+# when it's needed here.  unfortunately, some makes believe this syntax
+# means foo always changes, instead of foo should always be checked.
+# therefore, approximate via config.h dependencies, and hope that anybody
+# changing anything other than basic configuration also knows when not
+# to improvise things not in the instructions, like 'make makedefs' here
+# in util...
+
+# make sure object files from src are available when needed
+#
+$(OBJDIR)/alloc.o: ../src/alloc.c $(CONFIG_H)
+	$(CC) $(CFLAGS) -c ../src/alloc.c -o $@
+$(OBJDIR)/drawing.o: ../src/drawing.c $(CONFIG_H)
+	$(CC) $(CFLAGS) -c ../src/drawing.c -o $@
+$(OBJDIR)/decl.o: ../src/decl.c $(CONFIG_H)
+	$(CC) $(CFLAGS) -c ../src/decl.c -o $@
+$(OBJDIR)/monst.o: ../src/monst.c $(CONFIG_H)
+	$(CC) $(CFLAGS) -c ../src/monst.c -o $@
+$(OBJDIR)/objects.o: ../src/objects.c $(CONFIG_H)
+	$(CC) $(CFLAGS) -c ../src/objects.c -o $@
+$(OBJDIR)/dlb.o: ../src/dlb.c $(HACK_H) ../include/dlb.h
+	$(CC) $(CFLAGS) -c ../src/dlb.c -o $@
+
+# make sure hack.h dependencies get transitive information
+$(HACK_H): $(CONFIG_H)
+	@( cd ../src ; $(MAKE) $(HACK_H) )
+$(CONFIG_H): ../include/config.h
+	@( cd ../src ; $(MAKE) $(CONFIG_H) )
+
+tags: $(UTILSRCS)
+	@ctags -tw $(UTILSRCS)
+
+clean:
+	-rm -f *.o
+
+spotless: clean
+	-rm -f lev_lex.c lev_yacc.c dgn_lex.c dgn_yacc.c
+	-rm -f ../include/lev_comp.h ../include/dgn_comp.h
+	-rm -f ../include/tile.h
+	-rm -f makedefs lev_comp dgn_comp recover dlb
+	-rm -f gif2txt txt2ppm tile2x11 tile2img.ttp xpm2img.ttp tilemap
+
+tileedit: tileedit.cpp $(TEXT_IO)
+	$(QTDIR)/bin/moc -o tileedit.moc tileedit.h
+	$(CC) -o tileedit -I../include -I$(QTDIR)/include -L$(QTDIR)/lib tileedit.cpp $(TEXT_IO) -lqt
diff --git a/util/makedefs b/util/makedefs
new file mode 100755
index 0000000..0021e10
Binary files /dev/null and b/util/makedefs differ
diff --git a/util/makedefs.c b/util/makedefs.c
index 23dace2..94c28ef 100644
--- a/util/makedefs.c
+++ b/util/makedefs.c
@@ -417,6 +417,9 @@ do_rumors()
  * This should go away in the next version update.
  */
 #define IGNORED_FEATURES	( 0L \
+				| (1L << 17)	/* TEXTCOLOR */ \
+				| (1L << 20)	/* EXP_ON_BOTL */ \
+				| (1L << 21)	/* SCORE_ON_BOTL */ \
 				| (1L << 23)	/* TIMED_DELAY */ \
 				)
 
@@ -775,6 +778,82 @@ static const char *build_opts[] = {
 		"zero-compressed save files",
 #endif
 		save_bones_compat_buf,
+#ifdef AOY_CONTAINER
+		"patch: baggable special items",
+#endif
+#ifdef HPMON
+		"patch: colored Hp monitor",
+#endif
+#ifdef DUMP_LOG
+		"patch: dump game end info",
+#endif
+#ifdef DYNKEY
+		"patch: dynamic keybinding",
+#endif
+#ifdef DEATH_EXPLORE
+		"patch: explore mode at death",
+#endif
+#ifdef ENL_STATS
+		"patch: extra status attributes",
+#endif
+#ifdef GERMANKB
+		"patch: german keyboard (hardcoded)",
+#endif
+#ifdef HELPLESS
+		"patch: helplessness reasons",
+#endif
+#if defined(ITEMCAT) || defined(ITEMCAT_JP)
+		"patch: item categories",
+#endif
+#ifdef LOG_MOVES
+		"patch: log move counter",
+#endif
+#ifdef FORGET_QUITTER
+		"patch: no record entry for quitting",
+#endif
+#ifdef SHOP_CREDIT
+		"patch: no shop credit",
+#endif
+#ifdef QWERTZ
+		"patch: optionally change y/z commands",
+#endif
+#ifdef ARTI_WITH_OWNER
+		"patch: owned artifacts",
+#endif
+#ifdef PARANOID
+		"patch: paranoid",
+#endif
+#ifdef PRIEST_RACES
+		"patch: priests for every race",
+#endif
+#ifdef PROMPT_LOGEXP
+		"patch: prompt explore/wizard mode logging",
+#endif
+#ifdef QUIVER_FIRED
+		"patch: quiver with the f command",
+#endif
+#ifdef SHOW_EXTINCT
+		"patch: show extinct monsters",
+#endif
+#ifdef SHOW_BORN
+		"patch: show monsters born",
+#endif
+#ifdef SORTLOOT
+		"patch: sortloot",
+#endif
+#ifdef ADJSPLIT
+		"patch: splittable #adjust",
+#endif
+#ifdef MENU_COLOR
+# ifdef MENU_COLOR_REGEX
+		"patch: tty menu colors via regular expressions",
+# else
+		"patch: tty menu colors via pmatch",
+# endif
+#endif
+#ifdef WIN_EDGE
+		"patch: win_edge",
+#endif
 		"basic NetHack features"
 	};
 
diff --git a/win/tty/wintty.c b/win/tty/wintty.c
index 9cba7d7..7b45844 100644
--- a/win/tty/wintty.c
+++ b/win/tty/wintty.c
@@ -125,6 +125,10 @@ static char obuf[BUFSIZ];	/* BUFSIZ is defined in stdio.h */
 static char winpanicstr[] = "Bad window id %d";
 char defmorestr[] = "--More--";
 
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+#endif
+
 #ifdef CLIPPING
 # if defined(USE_TILES) && defined(MSDOS)
 boolean clipping = FALSE;	/* clipping on? */
@@ -162,7 +166,7 @@ STATIC_DCL void FDECL(invert_all, (winid,tty_menu_item *,tty_menu_item *, CHAR_P
 STATIC_DCL void FDECL(process_menu_window, (winid,struct WinDesc *));
 STATIC_DCL void FDECL(process_text_window, (winid,struct WinDesc *));
 STATIC_DCL tty_menu_item *FDECL(reverse, (tty_menu_item *));
-STATIC_DCL const char * FDECL(compress_str, (const char *));
+const char * FDECL(compress_str, (const char *));
 STATIC_DCL void FDECL(tty_putsym, (winid, int, int, CHAR_P));
 static char *FDECL(copy_of, (const char *));
 STATIC_DCL void FDECL(bail, (const char *));	/* __attribute__((noreturn)) */
@@ -1128,6 +1132,28 @@ invert_all(window, page_start, page_end, acc)
     }
 }
 
+#ifdef MENU_COLOR
+STATIC_OVL boolean
+get_menu_coloring(str, color, attr)
+char *str;
+int *color, *attr;
+{
+    struct menucoloring *tmpmc;
+    if (iflags.use_menu_color)
+	for (tmpmc = menu_colorings; tmpmc; tmpmc = tmpmc->next)
+# ifdef MENU_COLOR_REGEX
+	    if (re_search(&tmpmc->match, str, strlen(str), 0, 9999, 0) >= 0) {
+# else
+	    if (pmatch(tmpmc->match, str)) {
+# endif
+		*color = tmpmc->color;
+		*attr = tmpmc->attr;
+		return TRUE;
+	    }
+    return FALSE;
+}
+#endif /* MENU_COLOR */
+
 STATIC_OVL void
 process_menu_window(window, cw)
 winid window;
@@ -1204,6 +1230,10 @@ struct WinDesc *cw;
 		for (page_lines = 0, curr = page_start;
 			curr != page_end;
 			page_lines++, curr = curr->next) {
+#ifdef MENU_COLOR
+		    int color = NO_COLOR, attr = ATR_NONE;
+		    boolean menucolr = FALSE;
+#endif
 		    if (curr->selector)
 			*rp++ = curr->selector;
 
@@ -1219,6 +1249,13 @@ struct WinDesc *cw;
 		     * actually output the character.  We're faster doing
 		     * this.
 		     */
+#ifdef MENU_COLOR
+		   if (iflags.use_menu_color &&
+		       (menucolr = get_menu_coloring(curr->str, &color,&attr))) {
+		       term_start_attr(attr);
+		       if (color != NO_COLOR) term_start_color(color);
+		   } else
+#endif
 		    term_start_attr(curr->attr);
 		    for (n = 0, cp = curr->str;
 #ifndef WIN32CON
@@ -1236,6 +1273,12 @@ struct WinDesc *cw;
 				(void) putchar('#'); /* count selected */
 			} else
 			    (void) putchar(*cp);
+#ifdef MENU_COLOR
+		   if (iflags.use_menu_color && menucolr) {
+		       if (color != NO_COLOR) term_end_color();
+		       term_end_attr(attr);
+		   } else
+#endif
 		    term_end_attr(curr->attr);
 		}
 	    } else {
@@ -1529,11 +1572,19 @@ tty_display_nhwindow(window, blocking)
 	/* avoid converting to uchar before calculations are finished */
 	cw->offx = (uchar) (int)
 	    max((int) 10, (int) (ttyDisplay->cols - cw->maxcol - 1));
-	if(cw->type == NHW_MENU)
+	if(cw->type == NHW_MENU
+#ifdef WIN_EDGE
+	    || iflags.win_edge
+#endif
+	)
 	    cw->offy = 0;
 	if(ttyDisplay->toplin == 1)
 	    tty_display_nhwindow(WIN_MESSAGE, TRUE);
-	if(cw->offx == 10 || cw->maxrow >= (int) ttyDisplay->rows) {
+	if(cw->offx == 10 || cw->maxrow >= (int) ttyDisplay->rows
+#ifdef WIN_EDGE
+	    || iflags.win_edge
+#endif
+	) {
 	    cw->offx = 0;
 	    if(cw->offy) {
 		tty_curs(window, 1, 0);
@@ -1722,7 +1773,7 @@ tty_putsym(window, x, y, ch)
 }
 
 
-STATIC_OVL const char*
+const char*
 compress_str(str)
 const char *str;
 {
